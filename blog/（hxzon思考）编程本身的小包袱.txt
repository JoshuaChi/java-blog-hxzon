（hxzon思考）编程本身的小包袱

by hxzon
====
编程里的问题分两种，一种是业务本身的问题，一种是编程本身的问题。
编程语言是工具和原材料，所以，它自身的问题是自找的“小包袱”。

====
1，“接口继承”和“实现继承”

接口的意义是用代码本身来表达一种契约。
用代码来表示契约，对比文档标注，好处是强制性。

“实现继承”则是为了代码复用。
用“实现继承”来实现复用，是因为编程语言有缺陷。
我很喜欢scala的“混入”，比实现继承更佳。

1.1，
C++因为支持多重继承，所以会产生菱形继承的问题。
菱形继承问题就是有两种实现都匹配调用规则。
clojure解决这个问题很直接，用prefer明确指明哪个实现优先。

1.2，
层级问题：java通过继承来静态形成层级，
clojure则使用元数据来表达层级。
因此，在clojure里，可以“任意地”“动态地”建立层级，不必为了得到层级而继承。
层级只是一种数据分类，而接口是为了订立契约，不是用来表达层级关系的。

====
2，异常处理

==
2.1，受检异常vs非受检异常
http://www.mindview.net/Etc/Discussions/CheckedExceptions

受检异常的优点是明确标出了抛出哪些异常。

但我一直很痛恨受检异常。
首先，受检异常强迫你在代码中捕获，带来两种“繁琐”：切断了变量的作用域；嵌套try catch。
其次，当不宜或无法立刻处理受检异常时，需要继续往上抛，
这时异常变成方法签名的一部分，后续如果更改就会显得“僵硬”。

非受检异常的缺点是方法签名本身没有明确标明可能抛出的异常。
但我想，有朝一日，ide足够发达的话，应该可以自动列出所有可能的异常。
非受检异常的优点，就是避免了“受检异常”上述的所有缺点。

相比受检异常的“繁琐”和“僵硬”，“非检查异常”的缺点不足挂齿。

我更亲睐使用“非受检异常”。

==
2.2，异常vs返回值

在不支持“多返回值”和元组的语言里，如果有别的值需要返回，就没办法用返回值来表示错误。

我觉得两种方式的本质区别是：
异常允许此刻不检查不处理，留到更合适的上层处理。
返回值则要求立刻检查并处理。
所以我觉得返回值就是“受检异常”的另一种表达方式，
但是没有“受检异常”的“繁琐”和“僵硬”的缺点。

我觉得异常更灵活，更简洁。
有人反对异常，因为异常隐藏着中断逻辑。

==
2.3，common lisp的状况系统

状况系统，允许底层和中层函数提供多种“修复策略”，
而高层函数可选择使用哪种“修复策略”。
产生状况时，调用栈可以不用回退。
状况系统，比java的异常系统更灵活。

====
3，编译型和虚拟机型

go将虚拟机编译进程序当中。

我一直在想的问题是，虚拟机所提供的所有功能，有没有可能不用虚拟机也能提供。
这个问题我还没有想好。

来自别人的说法：

不能提供“所有”，原因是虚拟机运行于用户的电脑（或生产环境），而编译器运行于开发的机器，
所以编译器（和开发人员）可能完全无法预知用户的电脑的配置情况，
编译器只能对有限的硬件猜测做保守的优化。
而虚拟机在安装时，可以精确检测电脑的指令集等性能相关的参数而做优化。

（
虚拟机能够提供运行时信息，从而实现动态性。（有性能损耗。）

编译型只能通过代码生成代码（预处理文本宏，模板）？
C++的多态是在编译期？

lisp通过语法宏，在编译期完成语法转换，从而完全不需要运行时的元信息。（最佳？）
）

====
4，数据类型

代码中声明类型，就限制了代码的通用性。
有类型的好处是可以编译检查。
我比较喜欢common lisp的方式，动态类型，
但是在需要的地方可以加上类型声明，帮助编译器优化，
毕竟只有人才知道自己想干什么，例如不需要通用。

====
5，给一个类（你无法修改）添加方法

支持元编程的语言，能运行时修改，做这种事很easy。

给一个类添加方法只是为了直观，不然直接用静态方法就可以了。
（对第一个参数重载，就能实现多态。）

scala提供了隐式转换，定义的时候就是静态方法，用的时候像这个类有了你要的方法。

====
6，多态

多态就是根据数据“类型”，自动调用合适的具体实现。

common lisp支持多重方法，方法中的每个参数都可以特化。

面向对象的多态，只是很受限的多重方法的一个特例。

====
7，代码复用

静态方法的缺点是不直观。

“实现继承”可以复用方法，但是却产生了层级（而我们可能本不需要这个层级），本末倒置。
如果语言不支持多继承，则不能从多个类复用方法。

scala的混入是很灵活的多继承，不仅可在类级别混入，也可在实例级别混入。

lisp提供宏，用代码来生成代码，我觉得是终极的武器。

====
8，dsl，领域专用语言

每种组件形式都代表了特定的抽象维度，组件复用只能在其维度上进行抽象层次的提升。
程序包含了逻辑和控制两个维度。
程序的本质复杂性就是逻辑，非本质复杂性就是控制。

逻辑决定了程序的本质复杂性，
但接口不是表达逻辑的通用方式，那么是否存在表达逻辑的通用方式呢？
答案是：有！
这就是元(Meta)，包括元语言(Meta Language)和元数据(Meta Data)两个方面。
元语言就是配置的语法和语义，
元数据就是具体的配置，它们之间的关系就是C语言和C程序之间的关系；
但是，同时元又非常神奇，
因为元既是数据也是代码，在表达逻辑和语义方面具有无与伦比的灵活性。
至此，我们终于找到了让代码变得简洁、优雅、易理解、易维护的终极方法，
这就是： 通过元语言抽象让逻辑和控制彻底解耦！

元驱动编程和普通编程方法相比在生产力、可靠性和简洁性方面的确是数量级的提升，
在我看来它就是软件开发的银弹！

==
为什么化学家和生物学家不使用基本粒子来描述他们的领域呢？
那是因为基本粒子无法提供足够的“抽象”。

虽然物质都是原子构成的，但是化学家用原子就太底层了，所以它们用分子。
这就是领域专用语言的好处，和领域里的概念吻合。

（
隐式上下文。语法需要（简洁）。

动态类型。避免人为限制类型。

类型自动推断。语法需要（简洁）。

类型化。语法需要（明确）。
（如果是希望编辑器能提供检查信息，则类型化既不是唯一，也不是最佳的选择。）

元编程。运行时生成代码。
（有无可能完全不需要运行时生成代码？）

编译时代码生成。（宏。）

//灵巧api（连贯接口）。
）

====
9，变量可见性

让变量和函数私有，一是为了屏蔽细节，二是为了避免意外调用。

js没有提供私有可见性，需要一些技巧才能实现私有可见性。

java提供私有可见性，可通过反射绕过。

clojure用元数据来标明私有可见性，这防止你意外调用，
但如果你知道自己想干什么，就可以简单而明确地有意绕过。

我觉得编程语言就该这样，防止意外，而不是防止欺骗。

====
10，鸭子类型

鸭子类型就是有匹配的方法即可，不必实现接口。

实现接口表明遵守契约。
有匹配的方法不代表是遵守契约。

ruby就是鸭子类型。

java，必须实现接口。
对于不受控制的类，因为无法让它实现接口，就需要另想别的方式，再次把问题复杂化。

go，也是有匹配方法即可，“实现方”不必实现接口。
但和ruby不同，go可以事后（且是“另外的”）定义接口，也就是“调用方”也可定义接口。
但我觉得接口还是应该“实现方”定义，因为有匹配方法，始终不代表是遵守契约。（hxzon：？）

clojure的“协议扩展”，可后期实现接口，
即后期才表明实现契约，即明确又灵活，是最佳的。

====
11，常量

大部分语言都有常量，但是它们提供的常量，都只是运行时不会改变（即编译期常量）。
但还有一种需求，是运行时统一改变。
在这些语言里只能使用全局变量。
但我觉得这种“统一改变”和普通变量的修改是不同的，
所以需要有一种方式，明确的，而不是意外的，修改这种“全局常量”。
clojure提供了 var 引用类型 和 alter-var-root 函数。

====
12，js中的with 和 clojure中的doto

js中的with被视为糟粕，因为操作的可能是对象的字段，也可能是外部环境的变量。容易出错。

clojure中的doto，操作的是明确指定的对象。简洁好用。

====
13，延迟求值

延迟求值在理念上和并发相违背，
并发的目的，就是需要某个值时，它已经准备好。

延迟减少了不必要的计算，有些值可能永远未被用到。
但这不是重点。

延迟求值，在于提供一种假象，所有的值都在那，即便是无限序列。
这一点上，怎么并发都无能为力。

====
14，common lisp的广义函数 vs clojure的多重方法

（common lisp的多重方法指“真正的”多重方法，即确实对多个参数进行特化。）

common lisp定义广义函数时指定了参数个数，clojure则不指定任何参数（参数由注册的“实现体”决定）。
common lisp的“实现体”在参数上“基于类型”或者“基于某个实例”特化。
因此common lisp的转发只依赖于“实现体”，但是转发只能是“基于类型”或者“基于某个实例”的特化。

clojure定义多重方法时指定转发函数，“实现体”则指定转发值。
因此clojure的转发同时依赖于“转发函数”和“实现体”的转发值，但是转发很灵活，不必是“基于类型”。

相比较下，clojure更灵活。

====
15，不确定性计算

不确定性计算就是一个函数的返回值是几个可能值中的某一个。
每一个不确定表达式产生一个选择点，不确定性求值器会系统的尝试这些可能值，直到求出答案。
不确定性计算让程序员只提问题要求，不必思考怎么搜索答案。

====
16，续延

续延是在运行中被暂停了的程序：即含有计算状态的单个函数型对象。
当这个对象被求值时，就会在它上次停下来的地方重新启动之前保存下来的计算。
对于求解特定类型的问题，能够保存程序的状态并在之后重启是非常有用的。
例如在多进程中，续延可以很方便地表示挂起的进程。
而在非确定性的搜索问题里，续延可以用来表示搜索树中的节点。

续延可以理解成是一种广义的闭包。
闭包就是一个函数加上一些指向闭包创建时可见的词法变量的指针。
续延则是一个函数加上一个指向其创建时所在的整个栈的指针。
当续延被求值时，它返回的是使用自己的“栈拷贝”算出的结果，而没有用当前栈。
如果某个续延是在 T1 时刻创建的，而在 T2 时刻被求值，那么它求值时使用的将是 T1 时刻的栈。

使用续延的搜索方式带来了一种编写程序的新思路：
将合适的代码放在栈上，然后不断地返回到那里来获得结果。

dft-node 的优势在于，可以同时运行它的多个实例。
而通过续延，则能非常自然地维护两个正在进行的遍历操作的状态。

续延的过人之处在于，即使“没有”持久性的数据结构“与之关联”，
它同样可以在任何的计算过程中“轻松保存我们的位置”。
这一计算甚至也不需要具有有限数量的状态，只要重启它们有限次就行了。

====
17，一种数据结构

lisp里面用点对，点对就是一个两元素列表，第二个元素要么为空，要么又是一个点对。
clojure最出色的不是并发，而是它的数据结构思想。
向量，列表，set，映射，都可以转成序列（即点对）。

向量和列表可以看成下标到值的映射，set可以看成元素自身到自身的映射。

所以，clojure的操作，对向量、列表、set、映射都是通用的。

对比起java，映射甚至不是collection的子类，违背人的直觉。

用clojure写代码思想包袱可以很轻，不管你是用map，还是用bean，语法都是一样的。
不必纠结map灵活却性能低，bean性能好但又不够灵活。

数据结构也分两种，业务本身的，编程本身的，所以clojure提供了 defrecord 和 deftype 。

====
18，erlang

在erlang里，本地进程之间，和本地线程与其它主机进程之间的通信是一样的。
所以，一个本地程序，切换模式，就可以分布式运行了。 

====
19，c

在看c++的设计和演化时，我突然想到，
c本来就是面向机器设计的，不是生产力语言，所以不需要提供各种高级功能。
c的问题在于语法，最明显的一点，
c的声明既有前缀方式又有后缀方式，当两种方式同时用时，看起来就复杂了，
甚至还会出现歧义。出现歧义的时候又必须靠括号解决，更更复杂了。
你每看一遍代码，就得在脑子里解析一遍语法。
如果c当初改用S表达式，那么就可以用语法宏而不是用文本宏来代码生成代码了，
c程序员会不会轻松很多？

====
20，js，原型继承

不需要类，都是实例。
对象即是原型的实例（不修改字段和方法时），也是原型的“子类”（修改了字段和方法时）。

缺点：不会自动调用父类的构造函数。

====
21，按名调用

按名调用，所以改变一个名字（变量）所指的对象，所以使用到这个名字的地方都会自动更新。

====
22，编译单元

java有编译单元，编译单元为类，类内的方法没有先后顺序。
编译单元间也可以相互引用。
但这也导致允许出现循环依赖。（但同一模块内部循环依赖是合理的。）

clojure的方法，源文件，有先后顺序。
可使用专门的源文件，放置公共函数的声明。

====
23，



