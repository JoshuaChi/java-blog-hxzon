（hxzon学习笔记）hibernate-Chapter 5. Basic O-R Mapping（5.1.3，锁优化字段）

http://docs.jboss.org/hibernate/orm/4.3/manual/en-US/html/ch05.html#mapping-declaration

=======
5.1. Mapping declaration

5.1.1. Entity
5.1.2. Identifiers
5.1.3. Optimistic locking properties (optional)
5.1.4. Property
5.1.5. Embedded objects (aka components)
5.1.6. Inheritance strategy
5.1.7. Mapping one to one and one to many associations
5.1.8. Natural-id
5.1.9. Any
5.1.10. Properties
5.1.11. Some hbm.xml specificities

==
5.2. Hibernate types
5.2.1. Entities and values
5.2.2. Basic value types
5.2.3. Custom value types
5.3. Mapping a class more than once
5.4. SQL quoted identifiers
5.5. Generated properties
5.6. Column transformers: read and write expressions
5.7. Auxiliary database objects

=========
5.1.3. Optimistic locking properties (optional)

When using long transactions or conversations that span several database transactions, it is useful to store versioning data to ensure that if the same entity is updated by two conversations, the last to commit changes will be informed and not override the other conversation's work. It guarantees some isolation while still allowing for good scalability and works particularly well in read-often write-sometimes situations.

You can use two approaches: a dedicated version number or a timestamp.

A version or timestamp property should never be null for a detached instance. Hibernate will detect any instance with a null version or timestamp as transient, irrespective of what other unsaved-value strategies are specified. Declaring a nullable version or timestamp property is an easy way to avoid problems with transitive reattachment in Hibernate. It is especially useful for people using assigned identifiers or composite keys.

========
5.1.3.1. Version number

You can add optimistic locking capability to an entity using the @Version annotation:

@Entity
public class Flight implements Serializable {
...
    @Version
    @Column(name="OPTLOCK")
    public Integer getVersion() { ... }
}           
The version property will be mapped to the OPTLOCK column, and the entity manager will use it to detect conflicting updates (preventing lost updates you might otherwise see with the last-commit-wins strategy).

The version column may be a numeric. Hibernate supports any kind of type provided that you define and implement the appropriate UserVersionType.

The application must not alter the version number set up by Hibernate in any way. To artificially increase the version number, check in Hibernate Entity Manager's reference documentation LockModeType.OPTIMISTIC_FORCE_INCREMENT or LockModeType.PESSIMISTIC_FORCE_INCREMENT.

If the version number is generated by the database (via a trigger for example), make sure to use @org.hibernate.annotations.Generated(GenerationTime.ALWAYS).

To declare a version property in hbm.xml, use:

<version
        column="version_column"                            (1)
        name="propertyName"                                (2)
        type="typename"                                    (3)
        access="field|property|ClassName"                  (4)
        unsaved-value="null|negative|undefined"            (5)
        generated="never|always"                           (6)
        insert="true|false"                                (7)
        node="element-name|@attribute-name|element/@attribute|."
/>
1	column (optional - defaults to the property name): the name of the column holding the version number.
2	name: the name of a property of the persistent class.
3	type (optional - defaults to integer): the type of the version number.
4	access (optional - defaults to property): the strategy Hibernate uses to access the property value.
5	unsaved-value (optional - defaults to undefined): a version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. Undefined specifies that the identifier property value should be used.
6	generated (optional - defaults to never): specifies that this version property value is generated by the database. See the discussion of generated properties for more information.
7	insert (optional - defaults to true): specifies whether the version column should be included in SQL insert statements. It can be set to false if the database column is defined with a default value of 0.

=========
5.1.3.2. Timestamp

Alternatively, you can use a timestamp. Timestamps are a less safe implementation of optimistic locking. However, sometimes an application might use the timestamps in other ways as well.

Simply mark a property of type Date or Calendar as @Version.

@Entity
public class Flight implements Serializable {
...
    @Version
    public Date getLastUpdate() { ... }
}           
When using timestamp versioning you can tell Hibernate where to retrieve the timestamp value from - database or JVM - by optionally adding the @org.hibernate.annotations.Source annotation to the property. Possible values for the value attribute of the annotation are org.hibernate.annotations.SourceType.VM and org.hibernate.annotations.SourceType.DB. The default is SourceType.DB which is also used in case there is no @Source annotation at all.

Like in the case of version numbers, the timestamp can also be generated by the database instead of Hibernate. To do that, use @org.hibernate.annotations.Generated(GenerationTime.ALWAYS).

In hbm.xml, use the <timestamp> element:

<timestamp
        column="timestamp_column"                          (1)
        name="propertyName"                                (2)
        access="field|property|ClassName"                  (3)
        unsaved-value="null|undefined"                     (4)
        source="vm|db"                                     (5)
        generated="never|always"                           (6)
        node="element-name|@attribute-name|element/@attribute|."
/>
1	column (optional - defaults to the property name): the name of a column holding the timestamp.
2	name: the name of a JavaBeans style property of Java type Date or Timestamp of the persistent class.
3	access (optional - defaults to property): the strategy Hibernate uses for accessing the property value.
4	unsaved-value (optional - defaults to null): a version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. Undefined specifies that the identifier property value should be used.
5	source (optional - defaults to vm): Where should Hibernate retrieve the timestamp value from? From the database, or from the current JVM? Database-based timestamps incur an overhead because Hibernate must hit the database in order to determine the "next value". It is safer to use in clustered environments. Not all Dialects are known to support the retrieval of the database's current timestamp. Others may also be unsafe for usage in locking due to lack of precision (Oracle 8, for example).
6	generated (optional - defaults to never): specifies that this timestamp property value is actually generated by the database. See the discussion of generated properties for more information.
Note
<Timestamp> is equivalent to <version type="timestamp">. And <timestamp source="db"> is equivalent to <version type="dbtimestamp">

