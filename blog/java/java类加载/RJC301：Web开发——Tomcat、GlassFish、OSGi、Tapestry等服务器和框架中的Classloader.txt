RJC301：Web开发——Tomcat、GlassFish、OSGi、Tapestry等服务器和框架中的Classloader
译者： Elaine.Ye 原作者：Jevgeni Kabanov
发表时间：2011-04-04

http://article.yeeyan.org/view/213582/184632

====
在本文中，我们会回顾真实的服务器、容器和框架是如何使用动态的类加载器（classloader）来重载Java类和应用的。
我们还会谈到如何以最佳的方式来使用它们以达成更快的重载和重部署。

重载Java类系列的其他文章
RJC101: Objects, Classes and ClassLoaders
RJC201: How do Classloader leaks happen?
RJC301: Classloaders in Web Development — Tomcat, GlassFish, OSGi, Tapestry 5 and so on（本文）
RJC401: HotSwap and JRebel — Behind the Scenes
RJC501: How Much Does Turnaround Cost?

====
Java EE（web）应用

对于一个Java EE web应用来说，为了能够运行，应用需要被打包成一个有着.WAR后缀名的归档文件，并被部署到像Tomcat一类的servlet容器上。
这在生产中是有意义的，因为这给你提供了一种简单的组装和部署应用的方式，
不过在开发这一应用时，你通常只是希望编辑应用的文件，然后在浏览器中查看变化情况。

一个Java EE的企业级应用需要被打包成一个有着.EAR后缀名的归档文件。
该文件包含了多个web应用和EJB模块，因此其通常需要一些时间来组装和部署。
就在最近，有超过1100个EE开发者告诉了我们，他们需要多少时间来组装和部署这样的应用，我们在Redeploy and Restart Report一文中汇编了调查的结果。

插入的说明：平均的重部署和重启动时间是2.5分钟——这高出了我们的预期。

在 Reloading Java Classes 101一文中，我们研究了如何使用动态的类加载器来重载Java类和应用。
在本文中，我们将看一看服务器和框架是如何使用动态的类加载器来为开发周期提速的。
我们使用Apache Tomcat来作为主要的例子，当行为在其他的容器中有所不同时我们会给出说明
（Tomcat也和JBoss和GlassFish有直接的关系，因为这些容器都嵌入Tomcat来做servlet容器）。

====
重部署

要使用动态的类加载器的话，我们首先必须创建它们。
在部署你的应用时，服务器会为每个应用（就企业级应用这一情况来说，还有每个应用模块）都创建一个类加载器。
这些类加载器形成的层次结构如图说明：

classloaders-jee

在Tomcat中，每个.WAR应用由StandardContext类的一个实例来管理，
该类实例创建了一个被用来加载web应用类的WebappClassLoader实例。
当某个用户在Tomcat的管理器（Manager应用）中点击“reload”时，下面的情况会发生：

StandardContext.reload()方法被调用
之前的WebappClassLoader实例被一个新的实例代替
所有到servlet的引用都被丢弃
新的servlet被创建
这些servlet的Servlet.init() 方法被调用

tomcat-cl-reload

调用Servlet.init()的过程使用由新的类加载器实例加载的更新后的类来重建“初始化”的应用状态。
这一方法存在的主要问题是，要重建“初始化”状态的话，我们要从头开始运行初始化过程，
这通常包括了加载和处理元数据/配置、准备缓存、运行各种检查等等。
在一个足够大的应用程序中，这可能要需要很多分钟的时间，
不过在一个小的应用中，这通常只需要几秒钟，足够快到感觉就像是瞬间的事，通常这点都会在在Glassfish v3 的推广演示中给予证明。

如果你的应用是作为一个.EAR归档文件部署的话，那么许多的服务器还都允许每个应用模块在其更新之后做单独的重新部署，
这样就可以节省你的时间，否则的话，在重新部署之后，你要花时间来等待没有被更新的模块重做初始化。

====
热部署

Web容器通常会有一个特殊的目录（比如说Tomcat中的“webapps”、JBoss中的“deploy”），该目录会被定期扫描，
以找出新的web应用或是现有应用发生的改变。
当扫描器检测到有一个已部署的.WAR应用被更新了时，扫描器就会引发一个重部署过程
（在Tomcat中其调用StandardContext.reload()方法）。
因为这一过程是在用户一端没有任何附加行为的情况下发生的，因此其通常被称为“热部署（Hot Deployment）”。

所有广泛使用的应用服务器都支持热部署，并赋予了不同的名称，
比如：自动部署（autodeployment）、快速部署（rapid deployment）、自动发布（autopublishing）、热重载（hot reload）等等。
在一些容器中，你可以通过配置来让服务器监控某个特定路径下的归档文件，
而不是把归档文件移到预先定义好的目录下。

通常情况下，重部署过程可以从IDE中触发（比如说，当用户保持一个文件时），
这样的话，无需用户任何额外的干涉就可以做到重载应用了。
虽然应用对于用户来说是透明地重载的，但是当在管理控制台中点击“Reload”按钮时，这一过程依然是要要花费同样多的时间，
因此，比如说，代码所做的更改就不能是浏览器中立刻可见到的。

另一个会在一般的重部署和特殊的热部署过程中发生的问题是类加载器泄漏。
正如我们在Reloading Java Classes 201中所做的回顾一样，类加载器是如此出奇容易地发生泄漏，很快就用完堆（heap），
然后引发一个OutOfMemoryError错误。
由于每次部署都会创建新的类加载器，因此通常在一个足够大的应用上仅做几次重部署就会耗尽内存（无论是在开发过程中还是生产过程中）。

====
展开式部署

一项被大多数web容器支持的附加功能就是所谓的“展开式部署（exploded deployment）”，也被称为“非打包式的”或是“目录”部署。
这种方式不是部署一个.WAR的归档文件，而是可以部署一个有着与.WAR归档文件有着完全相同的内容布局的目录：

exploded

何苦要这样做呢？嗯，打包一个归档文件是一项代价不菲的操作，因此部署目录可以节省下来很不少的构建时间。
而且，把工程的目录设置成与.WAR归档文件的布局完全一样的做法通常都是可行的。
而这还意味着一项附加的好处，即只在原来的位置上编辑文件就可以了，不需要把他们复制到服务器上。
不幸的是，在不做重部署的情况下Java类是不能被重载的，因此，修改一个.java文件依然意味着要等待应用的重新初始化。

对于某些服务器来说，找出展开式目录中触发了热重部署的确切文件是很有意义的。
有时候，重部署被触发仅是因为“web.xml”文件的时间戳发生了变化，或者是如GlassFish中的情况一样，
仅是某个特殊的“.reload”文件的时间戳发生了变化。
在大部分的服务器中，部署描述符或是已编译类发生的任何变化都会引发一个热的重部署。

如果你的服务器仅支持复制到一个特殊的目录下（比如Tomcat的“webapps”、JBoss的“deploy”目录）这种部署方式的话，
则你可以通过创建一个从特殊目录到你的工程工作区的符号链接（symlink）来省略这一复制过程。
在Linux和Mac OS X上你可以使用常见的“ln -s”命令做到这一点，
而在Windows上，你应该需要下载Sysinternals的 “junction” 这一实用工具。

如果你使用Maven的话，则在你的工作区中做展开式的开发设置会很复杂。
如果你的应用是一个单独的web应用的话，则你可以使用Maven的Jetty插件，
该插件直接使用来自Mave的源和目标工程目录的类和资源。
不幸的是，Maven的Jetty插件并不支持部署多个web应用、EJB模块或是EAR，在后一种情况中，你会卡在进行工件构建这一环节上。

====
会话的持久

由于我们谈论的话题是重载类，而重部署涉及了应用的重新初始化，
因此在这里讨论一下会话状态（session state）是很有意义的。
一个HTTP会话通常会保持诸如登录凭据和对话状态一类的信息，在开发一个web应用时，
会话的丢失意味着要花时间登录并浏览发生了改变的页面——这是大多数的web容器试图通过以下这一做法来解决的一些事情，
即序列化HttpSession映射中的所有对象，然后再在新的类加载器中反序列化它们。
基本上，他们会复制所有的会话状态，而这就要求所有的会话属性都要实现Serializable
（以确保会话属性能够被写到数据库或是文件中以备后用），这一实现在大多数情况下都是不做限定的。

hot-deploy-session

会话的持久化功能在大多数主流的容器中已存在多年（比如说Tomcat中的Restart Persistence ），
但众所周知，在Glassfish的v3之前的版本中，这一功能是缺失的。

====
OSGi

围绕着OSGi做什么与不做什么这一话题存在着许多的误解，
我们如果忽略掉与当前讨论的问题无关的方面的话，OSGi基本上就是模块的一个集合，
每个模块都被包装在自己的类加载器中，该集合可被随意丢弃和重新创建。
在集合被重创建时，这些模块以与web应用完全相同的方式进行初始化。

osgi

OSGi和web容器的不同之处在于，OSGi是一些暴露给你的应用的东西，你使用它们来把应用分割成多个任意小的模块。
因此，按照设计，这些模块可能会比我们惯于构建的单一体的web应用要小很多。
而且，由于这些模块的每一个都较小，我们可以一个接一个地“重部署”它们，重初始化工作会花费更少的时间。
这一时间取决于你如何设计你的应用（且仍有可能是显著而不可忽略的）。

====
Tapestry 5、RIFE和Grails

近来一些web框架，比如说Tapestry 5、RIFE和Grails等，利用它们已需要维护应用的状态这样一个事实，采取了不同的做法。
它们要确保状态是可序列化的，否则就是要很容易可重创建的，
这样的话在扔掉一个类加载器之后，就不存在任何需要重新初化的东西了。

这意味着应用的开发者使用了框架的组件，而这些组件的生命周期是由框架来处理的。
框架会初始化（基于一些配置，这些配置或是基于xml的，或是基于注解的）、运行和销毁这些组件。

由于组件的生命周期是由框架进行管理的，因此在新的类加载器中，在无需用户干预的情况下重建组件是很容易的事情，
从而也造出了重载代码的效果。
在后台，旧的组件被销毁（类加载器被丢弃），
新的组件被创建（在一个新的类加载器中该类被再次读入），旧的状态或被反序列化，或基于配置创建。

component

这一做法有着很明显的优势，就是非常快，因为组件很小而且类加载器是小粒度的，
因此代码的重载是瞬间的事情，在开发应用时予人一种流畅的体验。
然而这样的做法并非总是可行的，因为其要求组件完全由框架来管理。
这种方法也会导致不同的类版本之间的不兼容性，在其他类中引发ClassCastException异常。

====
我们已经谈论了很多——且一路做着简化

值得一提的是，使用类加载器进行代码重载确实不会如我们在这里描述的那样一帆风顺——这只是一个介绍性的文章系列。
特别是随着一些更细粒度的方法（比如说有着每一个组件的类加载器的框架、手动的类加载器删除和重建等）的出现，
在你开始混合使用旧的和新的类时，地狱之门就有可能被打开了。
你可以保留所有种类的到旧的对象和类的引用，这些类和对象会和新载入的那些发生冲突
（一个常见的问题是会收到一个ClassCastException异常），因此要密切留意一路发生的事情。

旁注：在处理这一问题时，某种程度上来说其实是Groovy处理得更好一些，
因为所有通过元对象协议（Meta-Object Protocol ）的调用都没有受制于这一类问题。

本文涉及了如下问题：

动态的类加载器如何用来重载Java类和应用？
Tomcat、GlassFish(含v3)和其他的服务器如何重载Java类和应用？
OSGi如何改善了重载和重部署所需的时间？
框架（包括Tapestry 5、RIFE、Grails）是如何重载Java类和应用的？

接下来，我们将通过一个HotSwap和JRebel的调查来继续探讨类加载器和重部署过程，
HotSwap和JRebel是两个用来减少重载和重部署的时间花费的工具。

