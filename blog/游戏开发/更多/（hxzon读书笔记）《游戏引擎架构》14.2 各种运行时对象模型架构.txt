（hxzon读书笔记）《游戏引擎架构》14.2 各种运行时对象模型架构

=======
第14章  运行时游戏性基础系统 637

14.1 游戏性基础系统的组件 637

14.2 各种运行时对象模型架构 640

14.3 世界组块的数据格式 657
14.4 游戏世界的加载和串流 663
14.5 对象引用与世界查询 670
14.6 实时更新游戏对象 676
14.7 事件与消息泵 690

14.8 脚本 707
14.9 高层次的游戏流程 726
========
14.2 各种运行时对象模型架构

14.2.1.1 一个简单以C实现的基于对象的模型：《迅雷赛艇》
14.2.1.2 单一庞大的类层次结构

14.2.1.3 深宽层次结构的问题
类的理解、维护及修改
不能表达多维的分类
多重继承：致命钻石
mix-in类
冒泡效应

14.2.1.4 使用合成简化层次结构
把“是一个”改为“有一个”
组件的创建及拥有权
14.2.1.5 通用组件
14.2.1.6 纯组件模型 

14.2.2 以属性为中心的各种架构 
14.2.2.1 通过属性类实现行为 
14.2.2.2 通过脚本实现行为 
14.2.2.3 对比属性与组件 
14.2.2.4 以属性为中心的设计的优缺点 
14.2.2.5 延伸阅读

========
游戏设计师使用世界编辑器时，会面对一个抽象的游戏对象模型。
该模型定义了游戏世界中能出现的多种动态元素，指定它们的行为是怎样的，它们有哪些属性。
在运行时，游戏性基础系统必须提供这些对象模型的具体实现。
此模型是任何游戏性基础系统中最巨大的组件。

运行时对象模型的实现，可能与工具方的抽象对象模型相似，也可能不相似。
例如，运行时对象模型可能完全不是用面向对象编程语言来实现的，它也可能是用一组互相连接的实例表示的单个抽象游戏对象。
无论设计是怎样的，运行时对象模型必须忠实地复制出世界编辑器所展示的对象类型、属性及行为。

相对设计师所见的工具方抽象对象模型，运行时对象模型是其游戏中的表现。
运行时对象模型有不同设计，但多数游戏引擎会采用以下两种基本架构风格之一。

以对象为中心（object-centric）：此风格中，每个工具方游戏对象，在运行时是以单个类实例或数个相连的实例所表示。
每个对象含一组属性及行为，这些都会封装在那些对象实例的类（或多个类）之中。
游戏世界只不过是游戏对象的集合。

以属性为中心（property-centric）：此风格中，每个工具方游戏对象仅以唯一标识符表示（可实现为整数、字符串散列标识符或字符串）。
每个对象的属性分布于多个数据表，每种属性类型对应一个表，这些属性以对象标识符为键（而非集中在单个类实例或相连的实例集合）。
属性本身通常是实现为硬编码的类之实例。
而游戏对象的行为，则是隐含地由它组成的属性集合所定义的。
例如，若某对象含“血量”属性，该对象就能被攻击、扣血，并最终死亡。
若对象含“网格实例”属性，那么它就能在三维中渲染为三角形网格的实例。

以上的两个架构风格都有其独特的优缺点。
我们将逐一探究它们的一些细节，当在某方面其中一个风格可能极优于另一风格时，我们会特别指明。

========
14.2.1.5 通用组件

另一个更有弹性（但实现起来更棘手）的方法是，于根游戏对象类加入通用组件的链表。
在这种设计中，组件通常都会继承自一个共有的基类，使迭代链表时能利用该基类的多态操作，
例如，查询该类的类型，或逐一向组件传送事件以供处理。
此设计令根游戏对象类几乎不用关心有哪些组件类型，因而在大部分情况下，可以无须修改游戏对象就能创建新的组件类型。
此设计也能让每个游戏对象拥有任意数量的同类型组件实例。
（硬编码的设计只容许固定的数量，具体视乎游戏对象类里每个组件类型有多少个指针。）

图14.9展示了这种设计。
相比硬编码的组件模型，这种设计较难实现，因为我们必须以完全通用的方式来编写游戏对象的代码。
同样地，组件类也不可以假设在某游戏对象中有哪些组件。
是使用硬编码组件指针的设计，还是使用通用组件的链表，并不是一个简单的决策。
两者各有优缺点，各游戏团队会有不同之选。

====
14.2.1.6 纯组件模型

若我们把组件的概念发挥至极致，会是如何的呢？
我们可以把GameObject根类的几乎所有功能移到多个组件类中。
那么，游戏对象类就差不多变成一个无行为的容器，它含有唯一标识符及一些组件的指针，但自己却不含任何逻辑。
既然如此，何不删去那个根类呢？
要这么做，其中一个方法是把游戏对象的标识符复制至每个组件中。
那么组件就能逻辑地以标识符分组方式连接起来。
若能提供一个以标识符查找组件的快速方法，我们便无须GameObject这个枢纽。
笔者称这种架构为纯组件模型（pure component model），如图14.10所示。

刚开始时，可能会觉得纯组件模型并不简单，而且它也带有一些问题。
例如，我们仍要定义游戏所需的具体游戏对象类型，并且在创建那些对象时安插正确的组件实例。
之前的GameObject的层次结构可以帮助我们处理组件创建。
若使用纯组件模型，取而代之，我们可以用工厂模式（factory pattern），对每个游戏对象定义一个工厂类（factory class），
内含一个虚拟建构函数创建该对象类型所需的组件。
又或者，我们可以改用数据驱动模型，通过由引擎读取文本文件所定义的游戏对象类型，决定为游戏对象创建哪些组件。

==
另一个纯组件模型的问题，在于组件间的通信。
我们的中央GameObject当作“枢纽”，可编排多个组件间的通信。
在纯组件架构中，我们需要一个高效的方法，令单个对象中的组件能互相通信。
当然，组件可以使用游戏对象的唯一标识符来查找该对象的其他组件。
然而，我们很可能需要更高效的机制，例如，预先把组件连接成循环链表。

在这种意义上，纯组件模型中，某游戏对象与另一游戏对象的通信也面对相同困难。
我们不能再通过GameObject实例做通信媒介，而必须事前知道我们要与哪一个组件通信，
又或是对目标游戏对象的所有组件广播信息。
这两种方法都不甚理想。

纯组件模型可以在真实游戏项目实施，或许也有成功的实例。
这类模型都有其优缺点，再次，我们不能清楚确定这些设计是否比其他设计更好。
除非读者是研发团队的成员，那么应该会选择自己最方便且最有信心的架构，而该架构又是最能配合开发中的游戏的。

=========
14.2.2 以属性为中心的各种架构

惯用面向对象语言的程序员，常会自然地使用对象属性（数据成员）和行为（方法、成员函数）去思考问题。
这称为以对象为中心的视图（object-centric view）：

对象1
位置= (0;3;15)
定向= (0;43;0)

对象2
位置= ( 12;0;8)
血量= 15

对象3
定向= (0; 87;10)

然而，我们也可以属性为中心来思考，而不是对象。
我们先定义游戏对象可能含有的属性集合，然后为每个属性建表，每个表含有各个对象对应该属性的值，这些属性值以对象唯一标识符为键。
这称为以属性为中心的视图（property-centric view）。

位置
对象1 = (0;3;15)
对象2 = ( 12;0;8)

定向
对象1 = (0;43;0)
对象3 = (0; 87;10)

血量
对象2 = 15

以属性为中心的对象模型曾成功地应用在许多商业游戏中，包括《杀出重围2（DeusEx 2）》及《神偷（Thief）》系列。
延伸阅读（14.2.2.5节）提供这些项目中对象模型设计的更多细节。

相对于对象模型，以属性为中心的设计更类似关系数据库。
每个属性像是数据库表的一列（或独立的表），以游戏对象的唯一标识符为主键（primary key）。
当然，在面向对象模型中，对象不仅以属性定义，还需要定义其行为。
若我们有了属性的表，如何实现行为呢？
各游戏引擎给出不同的答案，但最常见的方法是把行为实现在两个地方：
（a）在属性本身，及/或（b）通过脚本。
我们进一步探讨这两种做法。

====
14.2.2.1 通过属性类实现行为

每种属性可以实现为属性类（property class）。
属性可以是简单的单值，如布尔值或浮点数，也可以复杂到如一个渲染用的三角形网格，或是一个人工智能“脑”。
每个属性类可以通过硬编码方法（成员函数）来产生行为。
某游戏对象的整体行为仍是由其全部属性的行为结集而得。

例如，若游戏对象含有Health（血量）属性的实例，该对象就能受损，并最终被毁或被杀。
对于游戏对象的任何攻击，Health对象都能扣减适当的建康值作为回应。

属性对象也可以与该游戏对象中的其他属性对象交流，以产生合作行为。
例如，当Health属性检测并回应了一个攻击，它可以发一个消息给AnimatedSkeleton（带动画的骨骼）属性，从而令游戏对象播放一个合适的受击动画。
相似地，当Health属性检测到游戏对象快要死去或被毁，它能告诉RigidBodyDynamics（属性）触发物理驱动的自爆，或是“布娃娃”模拟。

====
14.2.2.2 通过脚本实现行为

另一选择，是把属性值以原始方式储存于一个或多个如数据库的表里，然后用脚本代码实现对象的行为。
每个游戏对象可能有一个名为ScriptId的特殊属性，若对象含该属性，那么它就是用来指定管理对象行为的脚本部分
（指脚本函数，若脚本支持面向对象则是指脚本对象）。
脚本代码也可能用于回应游戏世界中的事件。
14.7节将会谈及更多有关事件系统的细节，而14.8节则会讨论有关游戏脚本语言。

在一些以属性为中心的引擎里，核心属性是由工程师硬编码的类，
但引擎还会提供一些机制给游戏设计师及程序员，以完全使用脚本实现一些新的属性。
这种方法曾成功应用到一些游戏，例如《末日危城（Dungeon Siege）》。

====
14.2.2.3 对比属性与组件

笔者需要交待一下，14.2.2.5节所参考的文章中，许多作者使用“组件”一词去代表笔者在此所指的“属性对象”。
在14.2.1.4节中，笔者使用“组件”一词指以对象为中心的设计中的子对象，而这个“组件”和属性对象并不怎么相似。

然而，属性对象和组件在很多方面都是密切相关的。
在两种设计中，单个逻辑游戏对象都是由多个子对象所组成的。
主要的区别在于子对象的角色。
在以属性为中心的设计中，每个子对象定义游戏对象本身的某个属性（如血量、视觉表示方式、物品清单、某种魔法能量等）；
而在以组件为中心（以对象为中心）的设计中，子对象通常用作表示某底层引擎子系统（渲染器、动画、碰撞及动力学等）。
这个区别如此细微，在许多情况下这个区别的存在都几乎无所谓了。
读者可称自己的设计为纯组件模型（14.2.1.6节），或是以属性为中心模型，看你觉得哪一个名称较为合适。
但是到了最后，读者应会得到实质上相同的结果：
一个由一组子对象所合成而成的逻辑游戏对象，并从这组子对象中获取所需的行为。

====
14.2.2.4 以属性为中心的设计的优缺点

以属性为中心的方式富有许多潜在优点。
它趋向更有效地使用内存，因为我们只需储存实际上用到的属性（即是说，我们不会有一些对象，内含未用的数据成员）。
它也更容易使用数据驱动的方式来建模，设计师能轻松定义新的属性，无须重新编译游戏，因为根本不用改变游戏对象类的定义。
仅当定义新的属性类型时，才需要程序员的介入（假设属性不能通过脚本定义）。

属性中心设计也可能比对象中心模型更缓存友好，因为相同类型的数据在内存中是连续储存的。
这是在当今游戏硬件中的常用的优化技巧，因为这些硬件的内存存取成本远高于执行指令和运算。
（例如，在PS3上缓存命中失败的成本，等同于执行数千条CPU指令的成本。）
把数据连续储存于内存之中，能减少或消除缓存命中失败，
因为当我们存取数据数组的某元素时，其附近的大量元素也会被载入相同的缓存线（cache line）之中。
此数据布局设计方式有时候称为数组之结构（struct of array，SoA），相比更传统的方式为结构之数组（array of struct，AoS）。

以下的代码片段展示了这两种内存布局方式的区别。
（注意，我们并不会完全以这种方式来实现游戏对象模型，
此例子是为了展示以属性为中心的设计可以产生连续的类型数组，而不是复杂对象的单个数组。）

static const U32 MAX_GAME_OBJECTS = 1024;
// 传统结构之数组（ AoS）方式
struct GameObject
{
U32 m_uniqueId;
Vector m_pos;
Quaternion m_rot;
float m_health;
// ……
};

GameObjectg_aAllGameObjects[MAX_GAME_OBJECTS];

// 对缓存更友好的数组之结构 （ SoA）方式
struct AllGameObjects
{
U32 m_aUniqueId[MAX_GAME_OBJECTS];
Vector m_aPos[MAX_GAME_OBJECTS];
Quaternion m_aRot[MAX_GAME_OBJECTS];
float m_aHealth[MAX_GAME_OBJECTS];
// ……
};

AllGameObjects g_allGameObjects;

==
以属性为中心的模型也有其缺点。
例如，当游戏对象只是属性的大杂烩，就会更难以维系那些属性之间的关系。
单凭凑齐一些细粒度的属性去实现一个大规模的行为，并非易事。
这种系统也可能更难以除错，因为程序员不能一次性地把游戏对象拉到监视视窗中检查它的属性。

====
14.2.2.5 延伸阅读

一些游戏业界的杰出工程师曾在各个游戏开发会议上发表过有关属性为中心的架构的简报，这些简报可以通过以下网址取得。
（hxzon：都是ppt）

Rob Fermier，“Creating a Data Driven Engine”，Game Developer's Conference，2002.

Scott Bilas，“A Data-Driven Game Object System”，Game Developer's Conference，
2002.

Alex Duran，“Building Object Systems: Features，Tradeoffs，and Pitfalls”，Game Developer's Conference，2003.

Jeremy Chatelaine，“Enabling Data Driven Tuning via Existing Tools”，Game De-veloper's Conference，2003.

Doug Church，“Object Systems”，于2003年韩国首尔的一个游戏开发会议发表；会议由Chris Hecker、Casey Muratori、Jon Blow和Doug Church组织。

（本节结束）

