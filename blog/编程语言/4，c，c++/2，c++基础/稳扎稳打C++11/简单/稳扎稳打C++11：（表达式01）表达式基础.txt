稳扎稳打C++11：（表达式01）表达式基础
来源：ilanever.com | 作者：LanPei | 创建时间：2014-1-21 23:30:16
http://ilanever.com/article/sitedetail.html?id=236

hxzon学习笔记：

1，粗略地讲，当我们将一个对象作为右值时，我们使用对象的值（它的内容），
当我们将一个对象作为左值时，我们使用对象的标识（它在内存中的位置）。

2，左值与右值另一个不同点是，（hxzon重要）
当使用decltype时：当我们将decltype应用到一个表达式（除了变量）时，
如果表达式产生一个左值，那么decltype的结果将是一个引用类型。
例如：假设p是int*，解引用p产生一个左值，所以decltype(*p)的类型是int&；
另一方面，对p求址产生一个右值，所以decltype(&p)的类型是int**。

3，因为我们不能指定计算顺序，所以当我们在一个表达式中引用和改变同一个对象时就是错误的。


====
目录

基本概念
优先级和相关性
计算顺序

====
一个表达式（expression）由一个或者多个操作数（operand）组成，经过计算后将返回一个结果。
最简单的表达式就是一个字面量或者变量，这种表达式的结果就是字面量或者变量的值。

基本概念 

运算符可以分为一元运算符（unary operator）、二元运算符（binary operator）和三元运算符（ternary operator）。
理解由多个运算符组成的表达式需要理解运算符的优先级（precedence）和相关性（associativity）以及操作数的计算顺序（order of evaluation）。

作为计算的一部分，操作数经常从一个类型被转换到另一个类型。

C++定义了运算符应用到内置类型和复合类型时的作用。
我们也可以为类的运算符定义其他的作用，这叫做运算符重载（overloaded operator）。
运算符重载可改变运算符操作数的类型和结果，但无法改变操作数的个数以及运算符的优先级和相关性。

左值（lvalue）和右值（rvalue）在C++中是两个比较重要的概念。
这两个概念继承自C，在C中左值指在赋值符号左手边的值，右值指在赋值符号右手边的值。
然而在C++中，这两个概念就没那么简单了。

粗略地讲，当我们将一个对象作为右值时，我们使用对象的值（它的内容），
当我们将一个对象作为左值时，我们使用对象的标识（它在内存中的位置）。

左值和右值不同的一点是，当需要用右值时，我们可以使用左值；当需要使用左值时，我们不能使用右值。

左值与右值另一个不同点是，（hxzon重要）
当使用decltype时：当我们将decltype应用到一个表达式（除了变量）时，
如果表达式产生一个左值，那么decltype的结果将是一个引用类型。
例如：假设p是int*，解引用p产生一个左值，所以decltype(*p)的类型是int&；
另一方面，对p求址产生一个右值，所以decltype(&p)的类型是int**。

运算符因是否需要左值或右值操作数而不同，也因是否返回左值和右值而不同。
赋值运算符需要左值作为它的左手边操作数，并将它的左手边操作数作为左值返回。
求址运算符需要一个左值操作数，并将指向它的操作数的指针作为右值返回。
内置的解引用和下标运算符以及迭代器解引用和string和vector的下标运算符都产生左值。
内置的和迭代器的递增和递减运算符需要左值操作数，并且大多数情况下都是返回左值。

====
优先级和相关性 

拥有高优先级的操作数比拥有低优先级的操作数组合的更加紧密。相关性决定了怎样组合同等优先级的操作数。
我们可以使用小括号重写正常的分组。

====
计算顺序 

优先级指定了操作数如何分组。但它并不规定操作数的计算顺序。
因为我们不能指定计算顺序，所以当我们在一个表达式中引用和改变同一个对象时就是错误的。（hxzon注意）

如下例所示：

#include <iostream>
 
using namespace std;
 
int main()
{
    int i = 0;
    cout << i << " " << ++i << endl;
     
    /*
    Environment:
        g++4.8.1
    Output:
        1 1
    */
     
    return 0;
}

