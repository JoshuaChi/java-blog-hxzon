（hxzon读书笔记）《SQL反模式》-存储树形结构

by hxzon
=====
第3章，单纯的树：如何存储树形结构。

========
解决方案1，使用邻接表（使用parentId）。

优点：
1，查询直接后代或直接父亲容易。
2，插入，断开，移动一个子树容易，只需修改parentId。
3，没有层级限制。

缺点：
1，查询所有后代或所有祖先困难。
2，删除一个子树（非仅仅断开）困难，需从最低级别的节点开始删除。

适用情况：有些数据库支持with关键字加“公共表表达式”，或者有特殊语法。

========
解决方案2，使用路径枚举（xx/yy/zz/a）。

优点：
1，查询所有祖先容易，where 'xx/yy' like path||'%';
2，查询所有后代容易，where path like 'xx/yy'||'%';
3，使用聚合容易。

缺点：有层级限制，字段长度影响层级数。

========
解决方案3，使用嵌套集。
每个节点有两个值，nsleft的数值小于所有后代，nsright的数值大于所有后代，
即夹在这两个值中间的节点为该节点的后代。

优点：
1，删除一个枝节点（非删除子树），它的后代会自动代替被删除的节点。

缺点：
1，获取直接父亲或者直接后代困难。
2，插入，移动节点困难，需要重新计算左右值。

适用情况：查询性能要求高，其它操作不频繁的场景。

========
解决方案4，使用闭包表。

使用一张额外的表treepaths，所有祖孙关系都存成一行（包括节点到自身）。

ancestor
descendant


优点：
1，查询所有后代，所有祖先都很容易。

hxzon：直接后代，直接父亲，不如邻接表，路径枚举容易。
可通过增加一个pathLength字段更快的查找直接后代和直接父亲。

2，插入新节点容易。

insert into treePaths(ancestor,descendant)
select t.ancestor,#myId
from treePaths t
where t.descendant = #myParentId
union all
select #myId,#myId

3，删除一个叶节点容易。

delete from treepaths where descendant = #myId

4，删除子树容易。

delete from treepaths
where descendant in
(
select descendant from treepaths where ancestor = #myId --所有myId的后代
)

5，移动一棵子树。

首先断开这棵子树（所有子节点）与所有祖先的关系。

delete from treepaths
where descendant in
(select descendant from treepaths where ancestor = #myId) --所有myId的后代，含myId自身
and ancestor in
(select ancestor from treepaths where descendant = #myId and ancestor!=descendant) --所有myId的祖先，不含myId自身

新父亲的所有祖先与子树（所有子节点）进行笛卡尔积。

insert into treepaths(ancestor,descendant)
selec supertree.ancestor,subtree.descendant
from treepaths supertree
cross join treepaths subtree
where supertree.descendant = #myNewParentId
and subtree.ancestor = #myId

6，删除treepaths的一行时，并不真正删除数据。

7，上述方案中，唯一此方案，允许一个节点属于多棵树。

参考书籍1：Jeo Celko《Trees and Hierarchies in SQL for Smarties》，介绍分层查询。
参考书籍2：Vadim Tropashko《SQL Design Patterns》，更加正规和理论化。

=======
hxzon总结：

闭包表最优，最通用，各项操作都很简单，支持一个节点属于多棵树，属于冗余换时间。

邻接表次之，查询树困难，如果数据库支持递归查询则很高效。

路径枚举各项查询都很简单，但是层级数受字段长度限制，也没有引用完整性，性能可能是个问题。

嵌套集，除了查询所有子代性能高，插入、删除、查询直接子代直接父亲都很复杂，没有引用完整性。

=======
create table if not exists htree_tree(
anc_id varchar(32),
desc_id varchar(32),
lvldiff int
);

delimiter //

drop procedure if exists tree_find_ancs//

create procedure tree_find_ancs(in p_myId varchar(32))
begin
select anc_id,lvldiff from htree_tree where desc_id = p_myId order by lvldiff desc;
end//

--注意，varchar必须指明长度。

create procedure tree_find_descs(in p_myId varchar(32))
begin
select desc_id,lvldiff from htree_tree where anc_id = p_myId order by lvldiff asc;
end//

create procedure tree_find_parent(in p_myId varchar(32))
begin
select anc_id,lvldiff from htree_tree where desc_id = p_myId and lvldiff=1;
end//

create procedure tree_find_children(in p_myId varchar(32))
begin
select desc_id,lvldiff from htree_tree where anc_id = p_myId and lvldiff=1;
end//

create procedure tree_tree(p_myId varchar(32), p_lvl int)
begin
	declare  no_more_descs int default 0;
	declare l_desc_id varchar(255);
	
	declare c1 cursor for select desc_id from htree_tree 
	where anc_id=p_myId and lvldiff = 1;

	declare continue handler for not found set no_more_descs = 1;

	SET @@max_sp_recursion_depth = 13;
	open c1;
	fetch c1 into l_desc_id;

	repeat
	call tree_tree(l_desc_id,p_lvl+1);
	fetch c1 into l_desc_id;
	until no_more_descs = 1
	end repeat;

	close c1;
end//

出错：
Recursive limit 0 (as set by the max_sp_recursion_depth variable) was exceeded for routine
解决：
SET @@max_sp_recursion_depth = 100; 
出错：
Thread stack overrun:  71812 bytes used of a 196608 byte stack, and 128000 bytes needed.  
Use 'mysqld --thread_stack=#' to specify a bigger stack.

drop procedure if exists tree_insert;

create procedure tree_insert(in p_myId varchar(32),in p_pId varchar(32))
begin
	insert into htree_tree(anc_id,desc_id,lvldiff)
	select t.anc_id,p_myId,lvldiff+1
	from htree_tree t
	where t.desc_id = p_pId
	union all
	select p_myId,p_myId,0;
end//

create procedure tree_delete(in p_myId varchar(32))
begin
delete from htree_tree
where desc_id in
(select desc_id from htree_tree where anc_id = p_myId);
end//

因为mysql的限制，所以上述语句会抛出异常：

You can't specify target table 'htree_tree' for update in FROM clause
不能先select出一张表中的某些值，再update这张表(在同一语句中)

drop procedure if exists tree_delete;

create procedure tree_delete(in p_myId varchar(32))
begin
delete from htree_tree
where desc_id in
(select desc_id from
(select desc_id from htree_tree where anc_id = p_myId ) as tmp);
end//

drop procedure if exists tree_move;

create procedure tree_move(in p_myId varchar(32),in p_npId varchar(32))
begin
	declare  no_more_descs int default 0;
	declare l_desc_id varchar(255);
	declare l_lvldiff int;
	
	declare c1 cursor for select desc_id,lvldiff from htree_tree 
	where anc_id=p_myId and lvldiff > 0;

	declare continue handler for not found set no_more_descs = 1;

	delete from htree_tree
	where desc_id in
	(select tmp1.desc_id from
	(select desc_id from htree_tree where anc_id = p_myId) as tmp1)
	and anc_id in
	(select tmp2.anc_id from
	(select anc_id from htree_tree where desc_id = p_myId and anc_id != p_myId) as tmp2); 
	
	delete from htree_tree where anc_id = p_myId and desc_id = p_myId;
	call tree_insert(p_myId,p_npId);
	
	open c1;
	fetch c1 into l_desc_id,l_lvldiff;

	repeat
	insert into htree_tree(anc_id,desc_id,lvldiff)
	select anc_id, l_desc_id,lvldiff+l_lvldiff 
	from (
	select anc_id,lvldiff
	from htree_tree where desc_id = p_myId and lvldiff > 0) as tmp1;

	fetch c1 into l_desc_id,l_lvldiff;
	until no_more_descs = 1
	end repeat;

	close c1;
end//

如何计算 lvldiff ?
为了计算 lvldiff ，插入时没有使用前文的笛卡尔积方式。

create procedure tree_test()
begin
delete from htree_tree;
call tree_insert('a1',null);
call tree_insert('b1','a1');
call tree_insert('b2','a1');
call tree_insert('b3','a1');

call tree_insert('c1','b1');
call tree_insert('c2','b1');
call tree_insert('c3','b1');

call tree_insert('c4','b2');
call tree_insert('c5','b2');
call tree_insert('c6','b2');

call tree_insert('c7','b3');
call tree_insert('c8','b3');
call tree_insert('c9','b3');

call tree_insert('d1','c1');
call tree_insert('d2','c1');

call tree_insert('d3','c2');
call tree_insert('d4','c2');

call tree_insert('d5','c3');
call tree_insert('d6','c3');

call tree_insert('d7','c4');
call tree_insert('d8','c4');

call tree_insert('d9','c5');
call tree_insert('d10','c6');

call tree_insert('e1','d5');
call tree_insert('e2','d5');
end//

delimiter ;

====


call tree_find_parent('c3');

call tree_find_ancs('c3');

call tree_find_children('c3');

call tree_find_descs('c3');

call tree_find_descs('b1');

call tree_find_descs('b3');

call tree_move('c3','b3');

