（hxzon学习笔记）solr入门

by hxzon

====
1，solr/conf/solrconfig.xml

配置讲解见：
《使用 Apache Solr 实现更加灵巧的搜索，第 2 部分：用于企业的 Solr（2007）——管理、配置和性能》

2，管理界面

同样见上文。

http://localhost:8080/solr/admin/analysis.jsp
Analysis 页可接受用于查询和文档的文本片段以及能确定文本该如何分析并返回正被修改的文本的逐步结果的 Field 名称。

统计信息管理页 对于分析缓存的 hit-to-miss 比例以及微调缓存大小的统计数据都非常有用。

=========
3，发布和复制（solrconfig.xml）

对于收到大量查询的应用程序，单一一个 Solr 服务器恐怕不足以满足性能上的需求。
因而，Solr 提供了跨多个服务器复制 Lucene 索引的机制，这些服务器必须是负载均衡的查询服务器的一部分。
复制过程由 solrconfig.xml 文件启动的事件侦听程序和几个 shell 脚本（位于示例应用程序的 dw-solr/solr/bin）处理。

在复制架构中，一个 Solr 服务器充当主服务器，负责向一个或多个处理查询请求的从服务器提供索引的副本（称为 snapshot）。
索引命令发送到主服务器，查询则发送到从服务器。

主服务器可以手动创建快照，也可以通过配置 solrconfig.xml 的 <updateHandler> 部分（请参见清单 1）
来触发接收到 commit 和/或 optimize 事件时的快照创建。
无论是手动创建还是事件驱动的创建，都会在主服务器上调用 snapshooter 脚本，
这会在名为 snapshot.yyyymmddHHMMSS（其中的 yyyymmddHHMMSS 代表实际创建快照的时间）的服务器上创建一个目录。

之后，从服务器使用 rsync 来只复制 Lucene 索引中的那些已被更改的文件。

清单 1. 更新句柄侦听程序

<listener event="postCommit" class="solr.RunExecutableListener">
    <str name="exe">snapshooter</str>
    <str name="dir">solr/bin</str>
    <bool name="wait">true</bool>
    <arr name="args"> <str>arg1</str> <str>arg2</str> </arr>
    <arr name="env"> <str>MYVAR=val1</str> </arr>
</listener>

清单 1 显示了在收到 commit 事件后，在主服务器上创建快照所需的配置。
同样的配置也同样适用处理 optimize 事件。

在这个示例配置中，在 commit 完成后，Solr 调用位于 solr/bin 目录的 snapshooter 脚本，传入指定的参数和环境变量。
wait 实参告知 Solr 在继续之前先等待线程返回。
有关执行 snapshooter 和其他配置脚本的详细信息，
请参见 Solr 网站上的 “Solr Collection and Distribution Scripts” 文档（请参见 参考资料）。

在从服务器上，使用 snappuller shell 脚本从主服务器上检索快照。
snappuller 从主服务器上检索了所需文件后，snapinstaller shell 脚本就可用来安装此快照并告知 Solr 有一个新的快照可用。

根据快照创建的频率，最好是安排系统定期执行这些步骤。

在主服务器上，rsync 守护程序在从服务器获得快照之前必须先行启动。
rsyn 守护程序可用 rsyncd-enable shell 脚本启用，然后再用 rsyncd-start 命令实际启动。

在从服务器上，snappuller-enable shell 脚本必须在调用 snappuller shell 脚本之前运行。

====
排除发布故障

虽然，我们已经竭尽全力地对索引更新的发布进行了优化，但还是有几个常见的场景会为 Solr 带来问题：

优化大型索引可能会非常耗时，而且应该在索引更新不是很频繁的情况下才进行。 
优化会导致多个 Lucene 索引文件合并成一个单一文件。
这就意味者从服务器必须要复制整个索引。

然而，这种方式的优化还是比在每个从服务器上进行优化要好很多。
这些服务器可能与主服务器不同步，导致新副本再次被检索。

如果从主服务器中获取新快照的频率过高，则从服务器的性能可能会降低，
这种降低源于使用 snappuller 复制更改的开销以及在安装新索引时的缓存预热。
有关频繁的索引更新方面的性能均衡的详细信息，
请参见 参考资料 中的 “Solr Performance Factors”。

最终，向从服务器添加、提交和获取更改的频繁程度完全取决于您自己的业务需求和硬件能力。
仔细测试不同的场景将会帮助您定义何时需要创建快照以及何时需要从主服务器中获取这些快照。
有关设置和执行 Solr 发布和复制的更多信息，
请参看 参考资料 中的 “Solr Collection and Distribution” 文档。


===========
4，请求处理程序是由请求中的 qt 参数指定的。

====
5，可以向 Solr 索引 servlet 传递四个不同的索引请求：

add/update 允许您向 Solr 添加文档或更新文档。
直到提交后才能搜索到这些添加和更新。

commit 告诉 Solr，应该使上次提交以来所做的所有更改都可以搜索到。

optimize 重构 Lucene 的文件以改进搜索性能。
索引完成后执行一下优化通常比较好。
如果更新比较频繁，则应该在使用率较低的时候安排优化。
一个索引无需优化也可以正常地运行。
优化是一个耗时较多的过程。

delete 可以通过 id 或查询来指定。
按 id 删除将删除具有指定 id 的文档；按查询删除将删除查询返回的所有文档。

----
添加或更新文档

清单 1. Solr add 命令样例

<add>
    <doc>
        <field name="url">http://localhost/myBlog/solr-rocks.html</field>
        <field name="title">Solr Search is Simply Great</field>
        <field name="keywords">solr,lucene,enterprise,search</field>
        <field name="creationDate">2007-01-06T05:04:00.000Z</field>
        <field name="rating">10</field>
        <field name="content">Solr is a really great open source search server. It scales,
        it's easy to configure and the Solr community is really supportive.</field>
        <field name="published">on</field>
    </doc>
</add>

----
查询

用于 StandardRequestHandler 的 Solr 查询语法
与 Lucene QueryParser 支持的查询语法相同，只是前者加入了一些排序支持。
示例应用程序对输入的值几乎没有进行验证，
而且没有演示如查询增强、短语、范围筛选等功能，所有这些功能在 Solr 和 Lucene 中都有效。

<response>
    <lst name="responseHeader">
        <int name="status">0</int>
        <int name="QTime">6</int>
        <lst name="params">
            <str name="rows">10</str>
            <str name="start">0</str>
            <str name="fl">*,score</str>
            <str name="hl">true</str>
            <str name="q">content:"faceted browsing"</str>
        </lst>
    </lst>
    <result name="response" numFound="1" start="0" maxScore="1.058217">
        <doc>
            <float name="score">1.058217</float>
            <arr name="all">
                <str>http://localhost/myBlog/solr-rocks-again.html</str>
                <str>Solr is Great</str>
                <str>solr,lucene,enterprise,search,greatness</str>
                <str>Solr has some really great features, like faceted browsing
                and replication</str>
            </arr>
            <arr name="content">
                <str>Solr has some really great features, like faceted browsing
                and replication</str>
            </arr>
            <date name="creationDate">2007-01-07T05:04:00.000Z</date>
            <arr name="keywords">
                <str>solr,lucene,enterprise,search,greatness</str>
            </arr>
            <int name="rating">8</int>
            <str name="title">Solr is Great</str>
            <str name="url">http://localhost/myBlog/solr-rocks-again.html</str>
        </doc>
    </result>
    <lst name="highlighting">
        <lst name="http://localhost/myBlog/solr-rocks-again.html">
            <arr name="content">
                <str>Solr has some really great features, like <em>faceted</em>
                <em>browsing</em> and replication</str>
            </arr>
        </lst>
    </lst>
</response>

----
表 2. 醒目显示的查询参数
参数	描述	示例

--
q	
Solr 中用来搜索的查询。
有关该语法的完整描述，请参阅 参考资料 中的 “Lucene QueryParser Syntax”。
可以通过追加一个分号和已索引且未进行断词的字段（下面会进行解释）的名称来包含排序信息。
默认的排序是 score desc，指按记分降序排序。	

q=myField:Java AND otherField:developerWorks; date asc
此查询搜索指定的两个字段并根据一个日期字段对结果进行排序。

--
start	
将初始偏移量指定到结果集中。
可用于对结果进行分页。默认值为 0。	
示例：start=15 返回从第 15 个结果开始的结果。

--
rows	
返回文档的最大数目。默认值为 10。	
示例：rows=25

==
fq	
提供一个可选的筛选器查询。
查询结果被限制为仅搜索筛选器查询返回的结果。
筛选过的查询由 Solr 进行缓存。
它们对提高复杂查询的速度非常有用。	

任何可以用 q 参数传递的有效查询，排序信息除外。

--
hl	
当 hl=true 时，在查询响应中醒目显示片段。
默认为 false。
参看醒目显示参数上的 Solr Wiki 部分可以查看更多选项（见 参考资料）。	

--
fl	
逗号分隔的列表，指定要返回的 字段集。
默认为 “*”，指所有的字段。
“score” 指还应返回记分。	
示例： *,score

=========
6，层面浏览是一种分类方式，用于对已经返回到有意义的、已证实存在的种类的结果进行分类。
层面用于帮助用户缩小搜索结果的范围。

运行层面不需要打开它或在 Solr 中进行配置，但是可能需要按照新的方式对应用程序内容进行索引。

在已索引的字段中完成分层，层面对未进行断词的非小写词最为有效。
（因此我并未包含 content 字段或 Facet Field 下拉列表中添加到文档的其他字段。）
Facet 字段通常不需要存储，因为分层面的总体思想就是显示人类可读的值。

另外还要注意 Solr 没有在层面中创建类别；
必须由应用程序自身在索引期间进行添加，正如在索引应用程序时给文档指派关键字一样。
如果存在层面字段，Solr 就提供了查明这些层面及其计数的逻辑。

====
7，复制字段

<copyField> 机制让您能够创建 all 字段而无需将文档的所有内容手工添加到单独的字段。
复制字段是以多种方式索引相同内容的简便方法。

例如，如果您希望提供区分大小写的精确匹配和忽略大小写的匹配，则可以使用一个复制字段自动分析收到的内容。
然后严格按照收到的内容进行索引（所有的字母使用小写）。

====
8，动态字段

<dynamicField> 
动态字段是一些特殊类型的字段，可以在任何时候将这些字段添加到任何文档中，由字段声明定义它们的属性。

动态字段和普通字段之间的关键区别在于前者不需要在 schema.xml 中提前声明名称。

Solr 将名称声明中的 glob-like 模式应用到所有尚未声明的引入的字段名称，
并根据其 <dynamicField> 声明定义的语义来处理字段。

例如，<dynamicField name="*_i" type="sint" indexed="true" stored="true"/> 
指一个 myRating_i 字段被 Solr 处理为 sint，尽管并未将其声明为字段。
这种处理比较方便，例如，当需要用户定义待搜索内容的时候。

