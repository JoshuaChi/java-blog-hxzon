Linux/UNIX系统编程手册(套装共2册)
凯利斯克 (Michael Kerrisk) (作者), 孙剑 (译者), 许从年 (译者), 董健 (译者), 孙余强 (译者)

出版社: 人民邮电出版社; 第1版 (2014年1月1日)
外文书名: The Linux Programming Interface
平装: 1176页
语种： 简体中文
开本: 16

====
编辑推荐

Linux/UNIX系统编程接口权威巨著，无出其右；
涵盖500多个系统调用和库函数；示例清晰完整，解释巨细靡遗；
涵盖当前UNIX标准（POSI X.1-2001/SUS v3和POSI X.1-2008/SUS v4）；
众多业内专家人士联袂推荐；
Linux/UNIX开发人员的案头必备，注定成为新的经典；


媒体推荐

编写Linux软件时如果只能选择一本参考书，则非本书莫属。
——MARTIN LANDERS，Google公司软件工程师

本书描述精到、示例周详，涵盖了LINUX底层API编程的详尽内容及个中细微之处——无论读者水平如何，都能从本书中受益。
——MEL GORMAN，Understanding the Linux Virtual Memory Manager作者

Michael Kerrisk的这本Linux编程巨著，不但论及LINUX编程、其与各种标准之间的联系，
而且还就作者所知，重点介绍了已获修正的Linux内核bug以及改进颇多的LINUX手册页。
凭此三点，足可让Linux编程更易上手。
本书对各项主题的深入探讨使其成为必备的参考书籍———无论读者在Linux编程方面造诣如何。
——ANDREAS JAEGER ，NOVELL公司OPENSUSE项目经理

Michael用他坚忍不拔的毅力为Linux程序员奉献了这本论述严谨，表述清晰、简洁的权威参考书。
虽然本书是针对Linux程序员而著，但对任何在UNIX/POSIX环境中编程的程序员来说都极具价值。
——DAVID BUTENHOF，Programming with POSIX Threads作者、POSIX /UNIX标准撰写者

本书在重点关注Linux系统的同时，对于UNIX系统和网络编程也阐述透彻，浅显易懂。
无论是初涉UNIX编程的新丁，还是编程经验丰富的UNIX老手（想要了解大行其道的GNU/Linux系统有何新意），我都向他们力荐此书。
——FERNANDO GONT，网络安全研究员、IETF参与者、IETF RFC作者

本书以百科全书般的叙述风格对Linux接口编程作了既深且广的覆盖，还提供了大量教科书风格的编程示例和练习。
本书所包含的各项主题——从原理到可以实际运行的代码——都描述清晰且易于理解。
本书正是专业人士、学生以及教育工作者所期盼的Linux/UNIX参考书。
——ANTHONY ROBINS ，奥塔哥大学计算机科学副教授

无论从精确性、质量还是详细程度来说，本书都令我印象深刻。
身为Linux系统调用的行家，Michael Kerrisk与我们分享了他对Linux API的认知和理解。
——CHRISTOPHE BLAESS，Programmation système en C sous Linux作者

对于治学严谨的专业Linux/UNIX系统程序员而言，本书实为必备的参考书籍。
本书涵盖了所有关键API的使用——同时兼顾Linux和UNIX系统接口，描述清晰，示例具体；
除此之外，还强调了遵从诸如SUS和POSIX 1003.1等标准的重要性和益处。
——ANDREW JOSEY，The OPen Group 标准部总监，POSIX 1003.1工作组主席

由手册页的维护者亲自操刀，以系统程序员视角写出一本百科全书式的LINUX系统编程巨著——还有比着更完美的吗？
本书全面而又详实。我坚信本书将在我的书架上牢牢占据一席之地。
——BILL GALLMEISTER，POSIX.4 Programmer’s Guide: Programming for the Real World

本书是最新最全的Linux/UNIX系统编程参考书。
无论读者是Linux系统编程新兵，还是关注LINUX编程和程序移植性的UNIX系统编程老将，
又或者只是在寻找一本Linux编程接口方面的优秀参考书，Michael Kerrisk的这本大作都笃定是其案头良伴。
——LO?C DOMAIGNé，CORPULS.COM首席软件架构师（嵌入式）

====
作者简介

全球顶尖的Linux内核黑客；
具有20多年的UNIX系统使用和编程经验；
自2004年起，开始维护手册页项目（该项目旨在生成描述Linux内核以及glibc编程API的手册页）；
撰写或合著了250多篇手册页；
极参与对Linux内核/用户空间接口的测试和设计评审工作。

====
目录

《Linux/UNIX系统编程手册（上册）》

第1章 历史和标准 1 
第2章 基本概念 17 
第3章 系统编程概念 34 
第4章 文件I/O：通用的I/O模型 56 
第5章 深入探究文件I/O 72 
第6章 进程 92 
第7章 内存分配 113 

第8章 用户和组 124 

第9章 进程凭证 136 

第10章 时间 151 

第11章 系统限制和选项 173 
第12章 系统和进程信息 183 

第13章 文件I/O缓冲 191 
第14章 系统编程概念 207 
第15章 文件属性 231 
第16章 扩展属性 258 

第17章 访问控制列表 265 

第18章 目录与链接 281 
第19章 监控文件事件 311 
第20章 信号：基本概念 321 
第21章 信号：信号处理器函数 348 
第22章 信号：高级特性 370 
第23章 定时器与休眠 397 
第24章 进程的创建 425 
第25章 进程的终止 440 
第26章 监控子进程 447 
第27章 程序的执行 465 
第28章 详述进程创建和程序执行 487 
第29章 线程：介绍 509 
第30章 线程：线程同步 521 
第31章 线程：线程安全和每线程存储 539 
第32章 线程：线程取消 552 
第33章 线程：更多细节 561 

《Linux/UNIX系统编程手册（下册）》

====
目录

《Linux/UNIX系统编程手册（上册）》

第1章 历史和标准 1 
1.1 UNIX和C语言简史 1 
1.2 Linux简史 4 
1.2.1 GNU项目 4 
1.2.2 Linux内核 5 
1.3 标准化 8 
1.3.1 C编程语言 8 
1.3.2 首个POSIX标准 9 
1.3.3 X/Open公司和TheOpenGroup 10 
1.3.4 SUSv3和POSIX.1—2001 10 
1.3.5 SUSv4和POSIX.1—2008 12 
1.3.6 UNIX标准时间表 12 
1.3.7 实现标准 14 
1.3.8 Linux、标准、Linux标准规范（LinuxStandardBase） 14 
1.4 总结 15 

第2章 基本概念 17 
2.1 操作系统的核心—内核 17 
2.2 shell 19 
2.3 用户和组 20 
2.4 单根目录层级、目录、链接及文件 21 
2.5 文件I/O模型 23 
2.6 程序 24 
2.7 进程 25 
2.8 内存映射 27 
2.9 静态库和共享库 28 
2.10 进程间通信及同步 28 
2.11 信号 29 
2.12 线程 30 
2.13 进程组和shell任务控制 30 
2.14 会话、控制终端和控制进程 30 
2.15 伪终端 31 
2.16 日期和时间 31 
2.17 客户端服务器架构 32 
2.18 实时性 32 
2.19 proc文件系统 33 
2.20 总结 33 

第3章 系统编程概念 34 
3.1 系统调用 34 
3.2 库函数 36 
3.3 标准C语言函数库；GNUC语言函数库（glibc） 37 
3.4 处理来自系统调用和库函数的错误 38 
3.5 关于本书示例程序的注意事项 40 
3.5.1 命令行选项及参数 40 
3.5.2 常用的函数及头文件 40 
3.6 可移植性问题 49 
3.6.1 特性测试宏 49 
3.6.2 系统数据类型 51 
3.6.3 其他的可移植性问题 53 
3.7 总结 54 
3.8 练习 55 

第4章 文件I/O：通用的I/O模型 56 
4.1 概述 56 
4.2 通用I/O 58 
4.3 打开一个文件：open（） 58 
4.3.1 open（）调用中的flags参数 60 
4.3.2 open（）函数的错误 63 
4.3.3 creat（）系统调用 64 
4.4 读取文件内容：read（） 64 
4.5 数据写入文件：write（） 65 
4.6 关闭文件：close（） 66 
4.7 改变文件偏移量：lseek（） 66 
4.8 通用I/O模型以外的操作：ioctl（） 70 
4.9 总结 71 
4.10 练习 71 

第5章 深入探究文件I/O 72 
5.1 原子操作和竞争条件 72 
5.2 文件控制操作：fcntl（） 75 
5.3 打开文件的状态标志 75 
5.4 文件描述符和打开文件之间的关系 76 
5.5 复制文件描述符 78 
5.6 在文件特定偏移量处的I/O：pread（）和pwrite（） 80 
5.7 分散输入和集中输出（Scatter—GatherI/O）：readv（）和writev（） 81 
5.8 截断文件：truncate（）和ftruncate（）系统调用 84 
5.9 非阻塞I/O 84 
5.10 大文件I/O 85 
5.11 /dev/fd目录 88 
5.12 创建临时文件 88 
5.13 总结 90 
5.14 练习 90 

第6章 进程 92 
6.1 进程和程序 92 
6.2 进程号和父进程号 93 
6.3 进程内存布局 94 
6.4 虚拟内存管理 97 
6.5 栈和栈帧 99 
6.6 命令行参数（argc，argv） 99 
6.7 环境列表 101 
6.8 执行非局部跳转：setjmp（）和longjmp（） 106 
6.9 总结 111 
6.9 练习 112 

第7章 内存分配 113 
7.1 在堆上分配内存 113 
7.1.1 调整programbreak：brk（）和sbrk（） 113 
7.1.2 在堆上分配内存：malloc（）和free（） 114 
7.1.3 malloc（）和free（）的实现 117 
7.1.4 在堆上分配内存的其他方法 120 
7.2 在堆栈上分配内存：alloca（） 122 
7.3 总结 123 
7.4 练习 123 

第8章 用户和组 124 
8.1 密码文件：/etc/passwd 124 
8.2 shadow密码文件：/etc/shadow 125 
8.3 组文件：/etc/group 126 
8.4 获取用户和组的信息 127 
8.5 密码加密和用户认证 132 
8.6 总结 135 
8.7 练习 135 

第9章 进程凭证 136 
9.1 实际用户ID和实际组ID 136 
9.2 有效用户ID和有效组ID 136 
9.3 Set—User—ID和Set—Group—ID程序 137 
9.4 保存set—user—ID和保存set—group—ID 138 
9.5 文件系统用户ID和组ID 139 
9.6 辅助组ID 140 
9.7 获取和修改进程凭证 140 
9.7.1 获取和修改实际、有效和保存设置标识 140 
9.7.2 获取和修改文件系统ID 145 
9.7.3 获取和修改辅助组ID 145 
9.7.4 修改进程凭证的系统调用总结 146 
9.7.5 示例：显示进程凭证 148 
9.8 总结 149 
9.9 习题 150 

第10章 时间 151 
10.1 日历时间（CalendarTime） 151 
10.2 时间转换函数 153 
10.2.1 将time_t转换为可打印格式 153 
10.2.2 time_t和分解时间之间的转换 154 
10.2.3 分解时间和打印格式之间的转换 155 
10.3 时区 161 
10.4 地区（Locale） 163 
10.5 更新系统时钟 167 
10.6 软件时钟（jiffies） 168 
10.7 进程时间 168 
10.8 总结 171 
10.9 练习 172 

第11章 系统限制和选项 173 
11.1 系统限制 174 
11.2 在运行时获取系统限制（和选项） 176 
11.3 运行时获取与文件相关的限制（和选项） 178 
11.4 不确定的限制 179 
11.5 系统选项 180 
11.6 总结 181 
11.7 练习 182 

第12章 系统和进程信息 183 
12.1 /proc文件系统 183 
12.1.1 获取与进程有关的信息：/proc/PID 183 
12.1.2 /proc目录下的系统信息 185 
12.1.3 访问/proc文件 186 
12.2 系统标识：uname（） 188 
12.3 总结 190 
12.4 练习 190 

第13章 文件I/O缓冲 191 
13.1 文件I/O的内核缓冲：缓冲区高速缓存 191 
13.2 stdio库的缓冲 194 
13.3 控制文件I/O的内核缓冲 196 
13.4 I/O缓冲小结 200 
13.5 就I/O模式向内核提出建议 201 
13.6 绕过缓冲区高速缓存：直接I/O 202 
13.7 混合使用库函数和系统调用进行文件I/O 204 
13.8 总结 205 
13.9 练习 205 

第14章 系统编程概念 207 
14.1 设备专用文件（设备文件） 207 
14.2 磁盘和分区 208 
14.3 文件系统 209 
14.4 i节点 211 
14.5 虚拟文件系统（VFS） 213 
14.6 日志文件系统 214 
14.7 单根目录层级和挂载点 215 
14.8 文件系统的挂载和卸载 216 
14.8.1 挂载文件系统：mount（） 217 
14.8.2 卸载文件系统：umount（）和umount2（） 222 
14.9 高级挂载特性 223 
14.9.1 在多个挂载点挂载文件系统 224 
14.9.2 多次挂载同一挂载点 224 
14.9.3 基于每次挂载的挂载标志 225 
14.9.4 绑定挂载 225 
14.9.5 递归绑定挂载 226 
14.10 虚拟内存文件系统：tmpfs 227 
14.11 获得与文件系统有关的信息：statvfs（） 228 
14.12 总结 229 
14.13 练习 230 

第15章 文件属性 231 
15.1 获取文件信息：stat（） 231 
15.2 文件时间戳 236 
15.2.1 使用utime（）和utimes（）来改变文件时间戳 238 
15.2.2 使用utimensat（）和futimens（）改变文件时间戳 239 
15.3 文件属主 241 
15.3.1 新建文件的属主 241 
15.3.2 改变文件属主：chown（）、fchown（）和lchown（） 241 
15.4 文件权限 244 
15.4.1 普通文件的权限 244 
15.4.2 目录权限 246 
15.4.3 权限检查算法 246 
15.4.4 检查对文件的访问权限：access（） 248 
15.4.5 Set—User—ID、Set—Group—ID和Sticky位 249 
15.4.6 进程的文件模式创建掩码：umask（） 249 
15.4.7 更改文件权限：chmod（）和fchmod（） 251 
15.5 I节点标志（ext2扩展文件属性） 252 
15.6 总结 256 
15.7 练习 256 

第16章 扩展属性 258 
16.1 概述 258 
16.2 扩展属性的实现细节 260 
16.3 操控扩展属性的系统调用 260 
16.4 总结 264 
16.5 练习 264 

第17章 访问控制列表 265 
17.1 概述 265 
17.2 ACL权限检查算法 267 
17.3 ACL的长、短文本格式 268 
17.4 ACL_mask型ACE和ACL组分类 269 
17.5 getfacl和setfacl命令 270 
17.6 默认ACL与文件创建 271 
17.7 ACL在实现方面的限制 272 
17.8 ACLAPI 273 
17.9 总结 280 
17.10 练习 280 

第18章 目录与链接 281 
18.1 目录和（硬）链接 281 
18.2 符号（软）链接 283 
18.3 创建和移除（硬）链接：link（）和unlink（） 286 
18.4 更改文件名：rename（） 289 
18.5 使用符号链接：symlink（）和readlink（） 290 
18.6 创建和移除目录：mkdir（）和rmdir（） 291 
18.7 移除一个文件或目录：remove（） 292 
18.8 读目录：opendir（）和readdir（） 292 
18.9 文件树遍历：nftw（） 297 
18.10 进程的当前工作目录 301 
18.11 针对目录文件描述符的相关操作 303 
18.12 改变进程的根目录：chroot（） 304 
18.13 解析路径名：realpath（） 306 
18.14 解析路径名字符串：dirname（）和basename（） 307 
18.15 总结 309 
18.16 练习 309 

第19章 监控文件事件 311 
19.1 概述 311 
19.2 inotifyAPI 312 
19.3 inotify事件 313 
19.4 读取inotify事件 315 
19.5 队列限制和/proc文件 319 
19.6 监控文件的旧有系统：dnotify 320 
19.7 总结 320 
19.8 练习 320 

第20章 信号：基本概念 321 
20.1 概念和概述 321 
20.2 信号类型和默认行为 323 
20.3 改变信号处置：signal（） 329 
20.4 信号处理器简介 330 
20.5 发送信号：kill（） 333 
20.6 检查进程的存在 334 
20.7 发送信号的其他方式：raise（）和killpg（） 335 
20.8 显示信号描述 336 
20.9 信号集 337 
20.10 信号掩码（阻塞信号传递） 339 
20.11 处于等待状态的信号 341 
20.12 不对信号进行排队处理 341 
20.13 改变信号处置：sigaction（） 345 
20.14 等待信号：pause（） 346 
20.15 总结 347 
20.16 练习 347 

第21章 信号：信号处理器函数 348 
21.1 设计信号处理器函数 348 
21.1.1 再论信号的非队列化处理 348 
21.1.2 可重入函数和异步信号安全函数 349 
21.1.3 全局变量和sig_atomic_t数据类型 353 
21.2 终止信号处理器函数的其他方法 354 
21.2.1 在信号处理器函数中执行非本地跳转 354 
21.2.2 异常终止进程：abort（） 358 
21.3 在备选栈中处理信号：sigaltstack（） 358 
21.4 SA_SIGINFO标志 361 
21.5 系统调用的中断和重启 366 
21.6 总结 368 
21.7 练习 369 

第22章 信号：高级特性 370 
22.1 核心转储文件 370 
22.2 传递、处置及处理的特殊情况 372 
22.3 可中断和不可中断的进程睡眠状态 373 
22.4 硬件产生的信号 374 
22.5 信号的同步生成和异步生成 374 
22.6 信号传递的时机与顺序 375 
22.7 signal（）的实现及可移植性 376 
22.8 实时信号 378 
22.8.1 发送实时信号 379 
22.8.2 处理实时信号 380 
22.9 使用掩码来等待信号：sigsuspend（） 384 
22.10 以同步方式等待信号 387 
22.11 通过文件描述符来获取信号 390 
22.12 利用信号进行进程间通信 393 
22.13 早期的信号API（SystemV和BSD） 393 
22.14 总结 395 
22.15 练习 396 

第23章 定时器与休眠 397 
第24章 进程的创建 425 
第25章 进程的终止 440 
第26章 监控子进程 447 
第27章 程序的执行 465 
第28章 详述进程创建和程序执行 487 
第29章 线程：介绍 509 
第30章 线程：线程同步 521 
第31章 线程：线程安全和每线程存储 539 
第32章 线程：线程取消 552 
第33章 线程：更多细节 561 

《Linux/UNIX系统编程手册（下册）》


