（hxzon读书笔记）《高性能MySQL(第3版)》第5章，索引

by hxzon
===========
第5章，创建高性能的索引141 

5.1索引基础141 
5.1.1索引的类型142 

5.2索引的优点152 

5.3高性能的索引策略153 
5.3.1独立的列153 
5.3.2前缀索引和索引选择性153 
5.3.3多列索引157 
5.3.4选择合适的索引列顺序159 
5.3.5聚簇索引162 
5.3.6覆盖索引171 
5.3.7使用索引扫描来做排序175 
5.3.8压缩（前缀压缩）索引177 
5.3.9冗余和重复索引178 
5.3.10未使用的索引181 
5.3.11索引和锁181 

5.4索引案例学习183 
5.4.1支持多种过滤条件183 
5.4.2避免多个范围条件185 
5.4.3优化排序186 

5.5维护索引和表187 
5.5.1找到并修复损坏的表187 
5.5.2更新索引统计信息188 
5.5.3减少索引和数据的碎片190 
5.6总结192 

=======
1，索引基础

索引可以包含一个或多个列。
如果包含多个列，列的顺序很重要，
因为mysql只能高效的使用最左边的列。

索引是在存储引擎层，而不是服务器层实现的。

====
1.1，B-Tree索引

“B-Tree”是文档中的说法。
底层存储引擎可能使用不同的存储结构。
NDB集群存储引擎使用了T-Tree结构存储这种索引，虽然名字叫BTREE。
InnoDB使用B+Tree（大部分数据库都使用）。

MyISAM使用前缀压缩技术使得索引更小，
InnoDB则按照原数据格式进行存储。

MyISAM索引通过数据的“物理 位置”引用被索引的行，
而InnoDB根据“主键”引用被索引的行。

B-Tree通常意味着所有的值都是“按顺序存储”的，
并且每一个叶子到根的距离相同。

根节点的槽中存放了指向子节点的指针，根据这些指针向下层寻找。
通过比较节点页的值，可以找到合适的指针进入下层子节点。
这些指针实际上定义了子节点页的值的上限和下限。
叶子节点的指针指向的是被索引的数据。

优势：

-1，全部列匹配
-2，匹配第一列（只使用索引的第一列）
-3，只匹配某一列的值的开头部分（只使用索引的第一列）
-4，范围值（只使用索引的第一列）
-5，第一列精确匹配，第二列范围匹配
-6，只访问索引（不需要访问数据行）

如果order by子句满足上述类型的查询，而这个索引也可以满足对应的排序需求。

限制：
-1，如果不是按照索引的最左列开始，则无法使用索引。
-2，不能跳过索引中的列，例如根据第一列和第三列查找。
-3，如果有某个列是范围查询，则它右边的所有列都无法使用索引。如果范围查询的值数量有限，可以通过使用“多个等于条件”来代替范围条件。

====
1.2，哈希索引

基于哈希表实现，只对“精确匹配所有列”有效。

Memory引擎支持“非唯一”哈希索引。
如果多个列的哈希值相同，会以链表的方式存放。

create table testhash(
    fname varchar(50) not null,
    lname varchar(50) not null,
    key using hash(fname)
}engine=memory;

查询时，mysql会先计算fname的哈希值，然后寻找对应的指针。

限制：
-1，哈希索引只包含哈希值和行指针，不存储字段值，所以不能避免读取行。不过，读内存中的行很快，性能影响不明显。
-2，不是按照索引值顺序存储的，无法用于排序。
-3，不支持索引中“部分列”的查找，因为哈希值是所有列的值。
-4，只支持等值比较，包括=，in(),<=>（注意<>和<=>是不同的操作）。
-5，不支持范围查找。
-6，当出现哈希冲突时，必须遍历链表中的所有行指针，逐行访问比较。
-7，如果哈希冲突很多，一些索引的维护代价很高。
例如从表中删除一行，存储引擎需要遍历链表中的每一行，找到并删除对应行的引用。

使用场景：
例如数据仓库中的一种经典“星型”schema，需要关联很多查找表，
哈希索引很适合查找表的需求。

NDB集群索引支持“唯一”哈希索引，但作用非常特殊。

----
InnoDB有个特殊的功能，“自适应哈希索引（adaptive hash index）”，是完全自动的，内部的行为，用户只能关闭该功能，
不能控制或配置。
当某些索引值被使用得非常频繁时，InnoDB会在内存中，基于B-Tree索引之上，再创建一个哈希索引，
使得B-Tree索引具有哈希索引的一些优点，例如快速的哈希查找。

----
手动哈希

当值很长时，例如URL。

新增一个被索引的url_crc列，使用CRC32做哈希。

select id from url where url="xxx"
and url_cre=CRC32("xxx");

仍然要指定url，防止哈希冲突找到多行。

可以使用触发器来避免手动维护哈希值。

create table pseudohash(
    id int unsigned not null auto_increment,
    url varchar(255) not null,
    url_crc int unsigned not null default 0,
    primary key(id)
);

先临时修改语句分隔符，因为触发器定义中需要使用分号。

delimiter //

create trigger pseudohash_crc_ins
before insert on pseudohash
for each row begin
set new.url_crc=crc32(new.url);
end;
//

create trigger pseudohash_crc_upd
before update on pseudohash
for each row begin
set new.url_crc=crc32(new.url);
end;
//

delimiter ;

不要使用sha1()和md5()做哈希函数，因为哈希值是很长的字符串。
sha1()和md5()是强加密函数，设计目标是最大限度消除冲突，
这里不需要这样高的要求。

如果数据很多，crc32()会出现大量哈希冲突。
可以考虑自己实现一个简单的64位哈希函数，返回整数。
一个简单的办法是使用md5()返回值的一部分。

select conv(right(md5('xxx'),16),16,10) as hash64;

还可以使用Percona Server的 fnv64() 做哈希函数，以插件形式。

====
1.3，空间数据索引（R-Tree）

MyISAM表支持空间索引，可以用作地理数据存储。
和B-Tree索引不同，这类索引无法前缀查询。
空间索引会从所有维度来索引数据。
查询时，可以有效使用任意维度来组合查询。

必须使用mysql的gis相关函数，如 mbrcontains() 来维护数据。

目前mysql的gis支持不完善。
做的比较好的是PostgreSQL的 PostGIS 。

====
1.4，全文索引（搜索引擎）

1.5，TokuDB使用分形树索引（fractal Tree index），
这是一类较新开发的数据结构，
有很多B-Tree的优点，同时避免了B-Tree的一些缺点。
多数情况下，针对InnoDB的讨论也都适用于TokuDB 。

（2014.7.1）

===============
2，索引的优点

-1，大大减少服务器需要扫描的数据量。
-2，可以帮助服务器避免排序和临时表。
-3，可以将随机IO变为顺序IO。

推荐书籍：《relational database Index design and 天河 optimizers》
Wiley出版，Tapio lahdenmaki和mike leach编写。

“三星系统”：
一星：索引将相关的记录放到一起。
二星：索引中的数据顺序和查找中的排列顺序一致。
三星：索引中的列包含了查询中需要的全部列。

对于非常小的表，简单的全表扫描更高效。
对于特大的表，建立和使用索引的代价将随之增长。这时可以使用“分区”。

===========
3，高性能的索引策略

3.1，列独立书写（原文“独立的列”）

列独立书写，指，索引列不能是表达式的一部分，也不能是函数的参数。

select actor_id from actor where actor+1=5;//MySQL无法使用索引，改成 where actor=5-1

select ... where to_days(current_date) - to_days(data_col) <=10;//MySQL也无法使用索引

====
3.2，“前缀索引”，即索引字符列的开头若干字符

很长的字符列，一种方法是模拟哈希索引。（见前文1.2，手动哈希）

另一种方案，索引开头的若干字符。

索引的选择性，指，不重复的索引值（也称为基数，cardinality），和数据表总记录数的比值。
索引的选择性高，则效率越高。
唯一索引的选择性是一，所以性能最好。

诀窍在于选择足够长的前缀，但又不能太长。
即，前缀的基数，应该接近完整列的基数。

计算合适的前缀长度：
select count(distinct city)/count(*) from city_demo;

select count(distinct left(city,3)/count(*) as sel3,
count(distinct left(city,4)count(*) as sel4,
count(distinct left(city,5)count(*) as sel5,
count(distinct left(city,6)count(*) as sel6
from city_demo;

只看“平均选择性”是不够的，如果数据分布不均匀，还需要考虑“最差选择性”。

建立前缀索引：
alter table city_demo add key(city(7));//hxzon：？不用substring？

前缀索引缺点：
MySQL无法使用前缀索引做order by和group by，也无法使用前缀索引做“覆盖扫描”。

==
“后缀索引”也很有用，例如，找某个域名的所有电子邮件地址。
MySQL原生不支持反向索引，但是可以把字符串反转后再存储。
可以用触发器来维护这种索引。

====
3.3，多列索引

常见错误：
-1，为每个列创建独立的索引。
-2，按照错误的顺序建立多列索引。

在多个列上建立单独的单列索引，大部分情况下不能提高MySQL的查询性能。
不过，MySQL5.0和更新版本，引入“索引合并”策略，
一定程序上可以使用表上的多个单列索引来定位行。

select film_id,actor_id from film_actor
where actor_id=1 or film_id=1;

上述查询，两个单列索引都不是好选择。（注意是or）
老版本MySQL会使用全表扫描。

可以改写成union方式：
select film_id,actor_id from actor where actor_id=1
union all
select film_id,actor_id from actor where film_id=1 and actor_id<>1;

但mysql5.0及之后，查询能够同时使用这两个单列索引进行扫描，并将结果进行合并。
这种算法有三个变种：
or条件的联合（union），and条件的相交（intersection），组合前两种情况的联合及相交。

所以上述语句，会使用using union(primary,idx_fk_film_id),using where 。

“索引合并”策略是一种优化结果，实际上说明表上的索引建得很糟糕。

如果有多个索引做相交操作（多个and条件），通常意味着需要一个包含所有相关列的多列索引。

通常来讲，将查询改写成union的方式往往更好。

====
3.4，索引列的顺序（只适用于b-tree索引）

在一个多列的b-tree索引中，索引列的顺序意味着索引首先按最左列排序，其次是第二列，第三列。

“将选择性最高的列，放在索引的最前列”，这条经验法则“没你想象的重要”。
通常不如“避免随机IO”和“排序”那么重要。

当不需要考虑排序和分组时，选择性最高的列放在最前面通常是很好的。
然而，性能不只依赖于所有索引列的选择性，也和查询条件的具体值有关，即“值的分布”。

select count(distinct staff_id)/count(*) as staff_id_selectivity,
count(distinct customer_id)/count(*) as customer_id_selectivity,
count(*)
from payment\G;

看哪列的选择性高，就作为索引第一列。

要注意一些特殊值。
例如，很多应用中，未登陆的用户，用户名都是guest。
此外，系统账号也可能很特殊。
还有一些特别受关注的名人的账号等。

一种解决办法，就是修改应用程序的代码，
区分这类特殊用户和组，使用特别定制的查询。（hxzon：注意）

====
3.5，聚簇索引（即oracle中的“索引组织表”）

聚簇索引不是一种索引类型，而是一种数据的“存储方式”。
InnoDB的聚簇索引实际上在同一个结构中保存了B-树索引和“数据行”。
“聚簇”即表示数据行和相邻的键值紧凑的存储在一起。
一个表只能有一个聚簇索引。（不过，覆盖索引可以模拟多个聚簇索引的情况。）

叶子页包含了行的全部数据，但是节点页只包含了索引列。
一些数据库允许指定哪个索引作为聚簇索引。
但InnoDB只能是“主键”。

聚簇索引的优点：
-1，可以把相关数据保存在一起。
例如电子邮箱，根据用户id来聚集数据，则只需要从磁盘读取“少数数据页”就能获取“某个用户的全部邮件”。
如果没有聚簇索引，可能每封邮件都一次磁盘IO。
-2，数据访问更快。
因为索引和数据在同一个B-树中。
-3，使用“覆盖索引扫描”的查询，可以直接使用叶节点中的“主键值”。

聚簇索引的缺点：
-1，如果数据全部放在“内存”中，则访问顺序不再重要，聚簇索引也就没什么优势。
-2，插入速度严重依赖“插入顺序”。
按照主键顺序插入是最快的。
-3，更新聚簇索引“列”的代价很高。
因为会强制InnoDB将每个被更新的行移动到新的位置。

-4，插入新行，或者主键被更新，需要移动行，可能导致“页分裂”问题。
页分裂会导致表占用更多的磁盘空间。

-5，可能导致“全表扫描变慢”，尤其是“行比较稀疏”，或者“页分裂”导致“数据存储不连续”。

-6，辅助索引（二级索引）可能比想象的要更大，因为辅助索引的叶子节点包含了“引用行的主键列”，
而不是指向行的物理位置的指针。
这样减少了行移动，或数据页分裂时，辅助索引的维护工作。（hxzon：注意）

-7，辅助索引访问需要“两次索引查找”，而不是一次。
对于InnoDB，“自适应哈希索引”能够减少这样的重复工作（两次B-树查找）。

==
3.5.1，InnoDB和myisam的数据分布对比

==
3.5.2，顺序主键什么时候会造成更坏的结果？

对于高并发工作负载，在InnoDB中按主键顺序插入，可能会造成明显的争用，
主键的上界会成为“热点”。
因为所有的插入都发生在这里，所以并发插入可能导致“间隙锁竞争”。

另一个热点可能是auto_increment锁机制。
如果遇到这个问题，可能需要重新考虑设计表或者应用。
或更改innodb_autoinc_lock_mode配置。

====
3.6，覆盖索引

覆盖索引：如果一个索引包含（即“覆盖”）所有需要查询的字段的值。
即查询只需要扫描索引而无须回表。

好处：
-1，索引条目通常远小于数据行大小，极大地减少了数据访问量。
-2，因为索引是按照值顺序存储的（至少单个页内如此），所以对于io密集型的“范围查询”，
比随机从磁盘读取每一行数据的io要少很多。
-3，一些存储引擎，如myisam，在内存中只缓存索引。
-4，InnoDB的辅助索引在叶子节点中保存了行的主键值，所以如果辅助索引能够覆盖查询，
则可以避免对主键索引的二次查询。

哈希索引，空间索引和全文索引都不存储索引列的值，所以不能成为覆盖索引。
MySQL只能使用B-树索引作为覆盖索引。

假设索引覆盖了where中的字段，但没覆盖整个查询涉及的字段，
MySQL5.5和更早版本，也总是会回表获取数据行。

MySQL不能在索引中执行like操作，这是底层存储引擎api的限制。
MySQL能在索引中做最左前缀匹配的like比较，因为该操作可以转成简单的比较。

解决上述两个问题，需要重写查询语句，并巧妙设计索引。

select * fromproducts
join(
select prod_id
from products
where actor='sean carrey' and title like '%apollo%'
) as t1
on (t1.prod_id=products.prod_id);

这种方式称为“延迟关联（deferred join）”，因为延迟了对列的访问。（hxzon：注意）
虽然无法使用索引覆盖整个查询，但总算比完全无法利用索引覆盖好。

不过，这样优化的效果，取决于where条件匹配返回的行数。
-1，如果返回很大的结果集，则看不到优化效果。
大部分时间都花在读取和发送数据上了。
-2，只返回很少的结果集，优化效果很明显。
-3，如果索引过滤时符合第一个条件的结果集已经很小，
则“子查询”带来的成本，反而比表中直接提取完整行更高。

InnoDB的辅助索引，叶子节点都包含了主键的值，
意味着可以有效利用“额外”的主键列来覆盖查询。（hxzon：注意）

注意：上面的很多限制，都是存储引擎api设计导致的。
MySQL5.6包含了一个api重要改进，称为“索引条件推送”，
能大大改善现在的查询执行方式，如此一来，上面的很多技巧也就“不再需要”了。

====
3.7，使用索引扫描来做排序

====
3.8，压缩（前缀压缩）索引

====
3.9，冗余和重复索引

====
3.10，没被使用的索引

====
3.11，索引和锁

===============
4，索引案例学习

支持多种过滤条件
避免多个范围条件
优化排序

===============
5，索引和表的维护

找到并修复损坏的表
更新索引统计信息
减少索引和数据的碎片


















