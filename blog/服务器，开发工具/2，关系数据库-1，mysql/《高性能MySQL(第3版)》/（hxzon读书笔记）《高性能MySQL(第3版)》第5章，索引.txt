（hxzon读书笔记）《高性能MySQL(第3版)》第5章，索引

by hxzon
===========
第5章，创建高性能的索引141 

5.1索引基础141 
5.1.1索引的类型142 

5.2索引的优点152 

5.3高性能的索引策略153 
5.3.1独立的列153 
5.3.2前缀索引和索引选择性153 
5.3.3多列索引157 
5.3.4选择合适的索引列顺序159 
5.3.5聚簇索引162 
5.3.6覆盖索引171 
5.3.7使用索引扫描来做排序175 
5.3.8压缩（前缀压缩）索引177 
5.3.9冗余和重复索引178 
5.3.10未使用的索引181 
5.3.11索引和锁181 

5.4索引案例学习183 
5.4.1支持多种过滤条件183 
5.4.2避免多个范围条件185 
5.4.3优化排序186 

5.5维护索引和表187 
5.5.1找到并修复损坏的表187 
5.5.2更新索引统计信息188 
5.5.3减少索引和数据的碎片190 
5.6总结192 

=======
1，索引基础

索引可以包含一个或多个列。
如果包含多个列，列的顺序很重要，
因为mysql只能高效的使用最左边的列。

索引是在存储引擎层，而不是服务器层实现的。

====
1.1，B-Tree索引

“B-Tree”是文档中的说法。
底层存储引擎可能使用不同的存储结构。
NDB集群存储引擎使用了T-Tree结构存储这种索引，虽然名字叫BTREE。
InnoDB使用B+Tree（大部分数据库都使用）。

MyISAM使用前缀压缩技术使得索引更小，
InnoDB则按照原数据格式进行存储。

MyISAM索引通过数据的“物理 位置”引用被索引的行，
而InnoDB根据“主键”引用被索引的行。

B-Tree通常意味着所有的值都是“按顺序存储”的，
并且每一个叶子到根的距离相同。

根节点的槽中存放了指向子节点的指针，根据这些指针向下层寻找。
通过比较节点页的值，可以找到合适的指针进入下层子节点。
这些指针实际上定义了子节点页的值的上限和下限。
叶子节点的指针指向的是被索引的数据。

优势：

-1，全部列匹配
-2，匹配第一列（只使用索引的第一列）
-3，只匹配某一列的值的开头部分（只使用索引的第一列）
-4，范围值（只使用索引的第一列）
-5，第一列精确匹配，第二列范围匹配
-6，只访问索引（不需要访问数据行）

如果order by子句满足上述类型的查询，而这个索引也可以满足对应的排序需求。

限制：
-1，如果不是按照索引的最左列开始，则无法使用索引。
-2，不能跳过索引中的列，例如根据第一列和第三列查找。
-3，如果有某个列是范围查询，则它右边的所有列都无法使用索引。如果范围查询的值数量有限，可以通过使用“多个等于条件”来代替范围条件。

====
1.2，哈希索引

基于哈希表实现，只对“精确匹配所有列”有效。

Memory引擎支持“非唯一”哈希索引。
如果多个列的哈希值相同，会以链表的方式存放。

create table testhash(
    fname varchar(50) not null,
    lname varchar(50) not null,
    key using hash(fname)
}engine=memory;

查询时，mysql会先计算fname的哈希值，然后寻找对应的指针。

限制：
-1，哈希索引只包含哈希值和行指针，不存储字段值，所以不能避免读取行。不过，读内存中的行很快，性能影响不明显。
-2，不是按照索引值顺序存储的，无法用于排序。
-3，不支持索引中“部分列”的查找，因为哈希值是所有列的值。
-4，只支持等值比较，包括=，in(),<=>（注意<>和<=>是不同的操作）。
-5，不支持范围查找。
-6，当出现哈希冲突时，必须遍历链表中的所有行指针，逐行访问比较。
-7，如果哈希冲突很多，一些索引的维护代价很高。
例如从表中删除一行，存储引擎需要遍历链表中的每一行，找到并删除对应行的引用。

使用场景：
例如数据仓库中的一种经典“星型”schema，需要关联很多查找表，
哈希索引很适合查找表的需求。

NDB集群索引支持“唯一”哈希索引，但作用非常特殊。

----
InnoDB有个特殊的功能，“自适应哈希索引（adaptive hash index）”，是完全自动的，内部的行为，用户只能关闭该功能，
不能控制或配置。
当某些索引值被使用得非常频繁时，InnoDB会在内存中，基于B-Tree索引之上，再创建一个哈希索引，
使得B-Tree索引具有哈希索引的一些优点，例如快速的哈希查找。

----
手动哈希

当值很长时，例如URL。

新增一个被索引的url_crc列，使用CRC32做哈希。

select id from url where url="xxx"
and url_cre=CRC32("xxx");

仍然要指定url，防止哈希冲突找到多行。

可以使用触发器来避免手动维护哈希值。

create table pseudohash(
    id int unsigned not null auto_increment,
    url varchar(255) not null,
    url_crc int unsigned not null default 0,
    primary key(id)
);

先临时修改语句分隔符，因为触发器定义中需要使用分号。

delimiter //

create trigger pseudohash_crc_ins
before insert on pseudohash
for each row begin
set new.url_crc=crc32(new.url);
end;
//

create trigger pseudohash_crc_upd
before update on pseudohash
for each row begin
set new.url_crc=crc32(new.url);
end;
//

delimiter ;

不要使用sha1()和md5()做哈希函数，因为哈希值是很长的字符串。
sha1()和md5()是强加密函数，设计目标是最大限度消除冲突，
这里不需要这样高的要求。

如果数据很多，crc32()会出现大量哈希冲突。
可以考虑自己实现一个简单的64位哈希函数，返回整数。
一个简单的办法是使用md5()返回值的一部分。

select conv(right(md5('xxx'),16),16,10) as hash64;

还可以使用Percona Server的 fnv64() 做哈希函数，以插件形式。

====
1.3，空间数据索引（R-Tree）

MyISAM表支持空间索引，可以用作地理数据存储。
和B-Tree索引不同，这类索引无法前缀查询。
空间索引会从所有维度来索引数据。
查询时，可以有效使用任意维度来组合查询。

必须使用mysql的gis相关函数，如 mbrcontains() 来维护数据。

目前mysql的gis支持不完善。
做的比较好的是PostgreSQL的 PostGIS 。

====
1.4，全文索引（搜索引擎）

1.5，TokuDB使用分形树索引（fractal Tree index），
这是一类较新开发的数据结构，
有很多B-Tree的优点，同时避免了B-Tree的一些缺点。
多数情况下，针对InnoDB的讨论也都适用于TokuDB 。

（2014.7.1）

===============
2，








