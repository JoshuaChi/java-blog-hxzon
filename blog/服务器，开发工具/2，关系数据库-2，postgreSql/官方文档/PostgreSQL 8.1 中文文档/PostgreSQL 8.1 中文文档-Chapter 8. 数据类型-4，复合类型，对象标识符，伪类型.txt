PostgreSQL 8.1 中文文档-Chapter 8. 数据类型-4，复合类型，对象标识符，伪类型

8.1. 数值类型
8.1.1. 整数类型
8.1.2. 任意精度数值
8.1.3. 浮点数类型
8.1.4. Serial（序号）类型
8.2. 货币类型
8.3. 字符类型
8.4. 二进制数据类型
8.5. 日期/时间类型
8.5.1. 日期/时间输入
8.5.2. 日期/时间输出
8.5.3. 时区
8.5.4. 内部
8.6. 布尔类型
8.7. 几何类型
8.7.1. Point（点）
8.7.2. 线段
8.7.3. Box（方）
8.7.4. Path（路径）
8.7.5. Polygon（多边形）
8.7.6. Circle（圆）
8.8. 网络地址数据类型
8.8.1. inet
8.8.2. cidr
8.8.3. inet 与 cidr 对比
8.8.4. macaddr
8.9. 位串类型
8.10. 数组
8.10.1. 数组类型的声明
8.10.2. 数组值输入
8.10.3. 访问数组
8.10.4. 修改数组
8.10.5. 在数组中检索
8.10.6. 数组输入和输出语法

==
8.11. 复合类型
8.11.1. 声明复合类型
8.11.2. 复合类型值输入
8.11.3. 访问复合类型
8.11.4. 修改复合类型
8.11.5. 复合类型输入和输出语法
8.12. 对象标识符类型
8.13. 伪类型
============
8.11. 复合类型

复合类型描述一行或者一条记录的结构； 它实际上只是一个字段名和它们的数据类型的列表。 PostgreSQL 允许像简单数据类型那样使用复合类型。 比如，一个表的某个字段可以声明为一个复合类型。

8.11.1. 声明复合类型

下面是两个定义复合类型的简单例子：

CREATE TYPE complex AS (
    r       double precision,
    i       double precision
);

CREATE TYPE inventory_item AS (
    name            text,
    supplier_id     integer,
    price           numeric
);
语法类似与 CREATE TABLE，只是这里只可以声明字段名字和类型； 目前不能声明约束（比如 NOT NULL 这样的）。请注意 AS 关键字是很重要的； 没有它，系统会认为这是完全不同的 CREATE TYPE 命令，因此你会看到奇怪的语法错误。

定义了类型，我们就可以用它创建表：

CREATE TABLE on_hand (
    item      inventory_item,
    count     integer
);

INSERT INTO on_hand VALUES (ROW('fuzzy dice', 42, 1.99), 1000);
或者函数：

CREATE FUNCTION price_extension(inventory_item, integer) RETURNS numeric
AS 'SELECT $1.price * $2' LANGUAGE SQL;

SELECT price_extension(item, 10) FROM on_hand;
在你创建表的时候，也会自动创建一个复合类型，名字与表名字相同，表示该表的复合类型。 比如，如果我们说过

CREATE TABLE inventory_item (
    name            text,
    supplier_id     integer REFERENCES suppliers,
    price           numeric CHECK (price > 0)
);
然后，和上面显示的相同的 inventory_item 复合类型也会作为副产品创建， 并且可以和上面一样使用。不过，需要注意目前的实现的一个重要限制：因为现在还没有约束和复合类型联结， 所以在表定义中显示的约束并不适用于表之外的复合类型。 （一个部分绕开的办法是使用域类型作为复合类型的成员。）

8.11.2. 复合类型值输入

要以文本常量书写复合类型值，在圆括弧里包围字段值并且用逗号分隔他们。 你可以在任何字段值周围放上双引号，如果值本身包含逗号或者圆括弧，你必须用双引号括起。 （更多细节见下面。）因此，复合类型常量的一般格式如下：

'( val1 , val2 , ... )'
一个例子是

'("fuzzy dice",42,1.99)'
如果 inventory_item 类型在前面已经定义了，那么这是一个合法的数值。 要让一个字段是空，那么在列表里它的位置上不要写任何字符。比如，下面这个常量在第三个字段声明一个 NULL：

'("fuzzy dice",42,)'
如果你想要一个空字串，而不是 NULL，写一对双引号：

'("",42,)'
这里的第一个字段是一个非 NULL 空字串，第三个字段是 NULL。

（这些常量实际上只是我们在 Section 4.1.2.5 讨论的一般类型常量的一个特殊例子。 这些常量一开始只是当作字串，然后传递给复合类型输入转换过程。一个明确的类型声明可能是必须的。）

我们也可以用 ROW 表达式语法来构造复合类型值。 在大多数场合下，这种方法都比用字串文本的语法更简单，因为你不用操心多重引号。 我们已经在上面使用了这种方法了：

ROW('fuzzy dice', 42, 1.99)
ROW('', 42, NULL)
只要你在表达式里有超过一个字段，那么关键字 ROW 就实际上是可选的， 所以可以简化为

('fuzzy dice', 42, 1.99)
('', 42, NULL)
ROW 表达式语法在Section 4.2.11 里有更详细的讨论。

8.11.3. 访问复合类型

要访问复合类型字段的一个域，我们写出一个点以及域的名字，非常类似从一个表名字里选出一个字段。 实际上，因为实在太像从表名字中选取字段，所以我们经常需要用圆括弧来避免分析器混淆。 比如，你可能需要从 on_hand 例子表中选取一些子域，像下面这样：

SELECT item.name FROM on_hand WHERE item.price > 9.99;
这样将不能工作，因为根据 SQL 语法， item 是从一个表名字选取的，而不是一个域名字。 你必须像下面这样写：

SELECT (item).name FROM on_hand WHERE (item).price > 9.99;
或者如果你也需要使用表名字（比如，在一个多表查询里），这么写：

SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price > 9.99;
现在圆括弧对象正确地解析为一个指向 item 字段的引用，然后就可以从中选取子域。

类似的语法问题适用于在任何地点从一个复合类型值中查询一个域。 比如，要从一个返回复合类型值的函数中只选取一个字段，你需要写像下面这样的东西

SELECT (my_func(...)).field FROM ...
如果没有额外的圆括弧，会产生一个语法错误。

8.11.4. 修改复合类型

下面是一些插入和更新复合类型字段的正确语法。首先，插入或者更新整个字段：

INSERT INTO mytab (complex_col) VALUES((1.1,2.2));

UPDATE mytab SET complex_col = ROW(1.1,2.2) WHERE ...;
第一个例子省略了 ROW，第二个使用它；我们用哪种方法都行。

我们可以更新一个复合字段的独立子域：

UPDATE mytab SET complex_col.r = (complex_col).r + 1 WHERE ...;
请注意，这里我们不需要（实际上是不能）在 SET 后面出现的字段名周围放上圆括弧， 但是我们在等号右边的表达式里引用同一个字段的时候却需要圆括弧。

我们也可以声明子域是 INSERT 的目标：

INSERT INTO mytab (complex_col.r, complex_col.i) VALUES(1.1, 2.2);
如果我们没有为字段的所有子域提供数值，那么剩下的子域将用空值填充。

8.11.5. 复合类型输入和输出语法

一个复合类型的文本表现形式包含那些根据独立的子域类型各自 I/O 转换规则解析的项， 加上一些表明这是复合结构的修饰。这些修饰包括整个数值周围的圆括弧（( 和 )）， 加上相邻域之间的逗号（,）。圆括弧外面的空白被忽略，但是在圆括弧里面， 它被当作子域数值的一部分，根据该子域的数据类型，这些空白可能有用，也可能没用。 比如，在

'(  42)'
里，如果子域类型是整数，那么空白将被忽略，但是如果是文本，那么就不会忽略。

如前面显示的那样，在给一个复合类型写数值的时候，你可以在独立的子域数值周围用双引号包围。 如果子域数值会导致复合数值分析器歧义，那么你必须这么做。 特别是子域包含圆括弧，逗号，双引号，或者反斜杠的场合，必须用双引号括起来。 要想在双引号括起来的子域数值里面放双引号，那么你需要在它前面放一个反斜杠。 （同样，在一个双引号括起的子域数值里面的一对双引号表示一个双引号字符，就像 SQL 字串文本的单引号规则一样。） 另外，你可以用反斜杠逃逸的方法保护所有可能会当作复合类型语法的数据字符。

一个完全空的子域数值（在逗号或者逗号与圆括弧之间没有字符）表示一个 NULL。 要写一个空字串，而不是一个 NULL，写 ""。

假如子域数值是空字串或者包含圆括弧，逗号，双引号，反斜杠或者空白，复合类型输出过程会在子域数值周围放上双引号。 （为空白这么处理不是必须的，但是可以增强易读性。）在一个子域数值里面嵌入的双引号和反斜杠将会写成两份。

注意: 请注意你写的任何 SQL 命令都首先被当作字串文本解析，然后才当作复合类型。 这就加倍了你需要的反斜杠数目。比如，要插入一个包含双引号和一个反斜杠的 text 子域到一个复合类型数值里， 你需要写

INSERT ... VALUES ('("\\"\\\\")');
字串文本处理器先吃掉一层反斜杠，这样到大复合类型分析器的东西看起来像 ("\"\\")。 然后，字串填给 text 数据类型的输入过程，变成 "\。 （如果我们面对的数据类型还会对反斜杠另眼相看，比如 bytea， 那么我们可能需要在命令里多达八个反斜杠以获取在存储的复合类型子域中有一个反斜杠。） 美元符包围（参阅 Section 4.1.2.2）可以用于避免双份反斜杠的问题。

提示: 在 SQL 命令里写复合类型值的时候，ROW 构造器通常比复合文本语法更容易使用。 在 ROW 里，独立的子域数值的写法和并非作为复合类型的成员书写的方法一样。

===========
8.12. 对象标识符类型

PostgreSQL 在内部使用对象标识符（OID）作为各种系统表的主键。 同时，系统不会给用户创建的表增加一个 OID 系统字段（除非在建表时声明了 WITH OIDS 或者是配置参数 default_with_oids 设置成了真）。 类型 oid 代表一个对象标识符。除此以外还有几个 oid 的别名： regproc，regprocedure，regoper， regoperator，regclass，和 regtype。 Table 8-19 显示了概要。

目前 oid 类型是用一个无符号的四字节整数实现的。 因此，它是不够用于提供大数据库范围内的唯一性保证的， 甚至在单个的大表中也不行。因此，我们不鼓励在用户创建的表中使用 OID 字段做主键。OID 最好只是用于引用系统表。

oid 类型本身除了比较之外还有几个操作。 不过，它可以转换为整数，然后用标准的整数操作符操作。（如果你这么干， 那么请注意可能的有符号和无符号之间的混淆。）

OID 别名类型没有自己的操作，除指明的输入和输出过程之外。 这些过程可以为系统对象接受和显示符号名，而不仅仅是类型 oid 将要使用的行数值。别名类型允许我们简化为对象查找 OID 值的过程。 比如，检查和一个表 mytable 相关的pg_attribute 行， 我们可以写

SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;
而不用

SELECT * FROM pg_attribute
  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');
虽然看上去不坏，但是这个例子还是简化了好多，如果在不同的模式里有好多叫 mytable 的表，那么我们需要写一个更复杂的子查询。 regclass 的输入转换器处理根据模式路径设置的表检索工作，所以它自动干了"正确的事情"。 类似的还有，把一个表的 OID 转换成 regclass 是查找一个 OID 对应的符号名称的最简单方法。

Table 8-19. 对象标识类型

名字	引用	描述	数值例子
oid	任意	数字的对象标识符	564182
regproc	pg_proc	函数名字	sum
regprocedure	pg_proc	带参数类型的函数	sum(int4)
regoper	pg_operator	操作符名	+
regoperator	pg_operator	带参数类型的操作符	*(integer,integer)或者-(NONE,integer)
regclass	pg_class	关系名	pg_type
regtype	pg_type	数据类型名	integer
所有 OID 别名类型都接受有模式修饰的名字，并且如果在当前 搜索路径中，在不增加修饰的情况下无法找到该对象，那么在输出 时将显示有模式修饰的名字。regproc 和 regoper 别名类型将只接受唯一的输入名字(不能重载)，因此它们的用途有限； 对于大多数应用，regprocedure 或 regoperat或者 更合适。对于 regoperat或者，单目操作符是通过在那些未用的操作数 上写NONE来标识的。

OID 别名类型的一个额外的属性是如果这些类型之一的常量出现在一个存储的表达式里 （比如字段缺省表达式或者试图），它在被引用的对象上创建一个依赖性。 比如，如果一个字段有缺省的 nextval('my_seq'::regclass) 表达式， PostgreSQL 理解缺省表达式依赖于序列 my_seq； 系统将不允许在删除缺省的表达式之前删除该序列。

系统使用的另外一个标识符类型是 xid，或者说是事务(缩写xact) 标识符。它是系统字段 xmin 和 xmax 的 数据类型。事务标识符是 32 位的量。

系统需要的第三种标识符类型是 cid，或者命令标识符。 它是系统字段 cmin 和 cmax 的数据类型。 命令标识符也是 32 位的量。

系统使用的最后的标识符类型是 tid，或者说是元组标识符。 它是系统表字段 ctid 的数据类型。元组 ID 是一对儿数值 (块号，块内的元组索引)，它标识该元组在其所在表内的物理位置。

（系统字段在 Section 5.4 里有更多解释。）

==========
8.13. 伪类型

PostgreSQL 类型系统包含一系列特殊用途的 条目，它们按照类别来说叫做 伪类型。一个伪类型不能作为 字段的数据类型，但是它可以用于声明一个函数的参数或者结果类型。 每个可用的伪类型在一个函数不只是简单地接受并返回某种SQL数据类型的 情况下都很有用。 Table 8-20列出了现有的伪类型。

Table 8-20. 伪类型

名字	描述
any	表示一个函数接受任何输入数据类型
anyarray	表示一个函数接受任意数组数据类型（参阅 Section 32.2.5）
anyelement	表示一个函数接受任何数据类型（参阅 Section 32.2.5）。
cstring	表示一个函数接受或者返回一个空结尾的 C 字串
internal	表示一个函数接受或者返回一种服务器内部的数据类型
language_handler	一个过程语言调用句柄声明为返回 language_handler
void	表示一个函数不返回数值
record	标识一个函数返回一个未声明的行类型
trigger	一个触发器函数声明为返回 trigger
opaque	一个已经过时的类型，以前用于所有上面这些用途
用 C 编写的函数（不管是内置的还是动态装载的）都可以声明为接受或者返回 这样的伪数据类型。在把伪类型用做函数参数类型的时候，保证函数行为正常 就是函数作者的任务了。

用过程语言编写的函数只能根据它们的实现语言是否可以使用伪类型而使用 它。目前，过程语言都不允许使用伪类型作为参数类型，并且只允许使用 void 和 record 作为结果类型（如果函数用做触发器，那么加上 trigger）。 一些多态的函数还支持使用 anyarray 和anyelement类型。

伪类型 internal 用于声明那种只能在数据库系统内部调用的函数， 它们不能直接在SQL查询里调用。如果函数至少有一个 internal 类型 的参数，那么我们就不能从SQL里调用它。为了保留这个限制的类型安全， 我们一定要遵循这样的编码规则：不要创建任何声明为返回 internal 的函数，除非它至少有一个 internal 参数。

（本章完）