PostgreSQL 8.1 中文文档-Chapter 18. 数据库角色和权限
http://www.php100.com/manual/PostgreSQL8/

Chapter 18. 数据库角色和权限

18.1. 数据库角色
18.2. 角色属性
18.3. 权限
18.4. 角色成员
18.5. 函数和触发器

=========
PostgreSQL 使用角色的概念管理数据库访问权限。 根据角色自身的设置不同，一个角色可以看做是一个数据库用户，或者一组数据库用户。 角色可以拥有数据库对象（比如，表）以及可以把这些对象上的权限赋予其它角色， 以控制谁拥有访问哪些对象的权限。另外，我们也可以把一个角色的成员 （membership）权限赋予其它角色，这样就允许成员角色使用它被赋予成员权限的角色之权限。

角色的概念替换了"用户"和"组"。 在 PostgreSQL 版本 8.1 之前，用户和组是独立类型的记录， 但现在它们只是角色。任何角色都可以是一个用户，一个组，或者两者皆可。


 本章描述如何创建和管理角色，以及介绍权限系统。 更多各种各样数据库对象和其权限效果的信息可以在 Chapter 5 找到。

18.1. 数据库角色

数据库角色从概念上与操作系统用户是完全无关的。 在实际使用中把它们对应起来可能比较方便，但不是必须的。 数据库角色在整个数据库集群中是全局的（而不是每个库不同）。 要创建一个角色，使用 SQL 命令 CREATE ROLE：

CREATE ROLE name;
name 遵循 SQL 标识的规则： 要么完全没有特殊字符，要么用双引号包围（实际上你通常会给命令增加额外的选项，比如 LOGIN）。 要删除一个现有角色，使用类似的命令 DROP ROLE：

DROP ROLE name;
为了方便，程序 createuser 和 dropuser 提供了对了这些 SQL 命令的封装。 我们可以在 shell 命令上直接调用它们：

createuser name
dropuser name
要判断一套现有用户，检查 pg_role 系统表，比如

SELECT usename FROM pg_role;
psql 的元命令 \du 也可以用于列出现有角色。

为了能初创数据库系统，新建立的数据库总是包含一个预定义的角色。 这个角色将总是"超级用户"， 并且缺省时（除非在运行 initdb 时更改过）他将和初始化该数据库集群的用户有相同的名称。 通常，这个角色叫postgres。 为了创建更多角色，你必须首先以这个初始用户角色联接。

每一个和数据库的连接都必须由一个角色身份进行， 这个角色决定在该连接上发出的命令的初始权限。 和特定数据库联接的角色名是由初始化联接请求的应用以相关的方式声明的， 比如，psql 程序使用-U命令行选项声明它代表的进行联接的角色。 许多应用以当前操作系统的用户名为缺省（这样的应用包括 createuser 和 psql）。 所以，在系统用户和数据库角色之间有某种命名关系会让我们工作方便很多。

一个客户端联接可以用来联接的数据库角色集合是由客户认证设置决定的， 在 Chapter 20 里面有解释。 （因此，一个客户端并不局限于以它的操作系统用户同名的角色进行联接， 就象你登录系统的名称不一定要是你的真实姓名一样。） 因为角色的身份决定了一个已连接地客户端可用的权限， 所以在多用户环境里仔细配置这些内容是非常重要的。

========
18.2. 角色属性

一个数据库角色可以有一系列属性，这些属性定义他的权限，以及与客户认证系统的交互。

登录权限
只有具有 LOGIN 属性的角色可以用做数据库连接的初始角色名。 一个带有 LOGIN 属性的角色可以认为是和"数据库用户"相同的事情。 要创建一个具有登录权限的角色，用下列之一

CREATE ROLE name LOGIN;
CREATE USER name;
(CREATE USER is equivalent to CREATE ROLE except that CREATE USER assumes LOGIN by default, while CREATE ROLE does not.)

超级用户
数据库超级用户超越所有权限检查。这事一个危险的权限，应该小心使用； 最好使用非超级用户完成你的大多数工作。 要创建数据库超级用户，用 CREATE ROLE name SUPERUSER。 你必须用已经是超级用户的用户身份执行这条命令。

创建数据库
角色要想创建数据库，必须明确给出权限（对于超级用户是例外，因为他们超越所有权限检查）。 要创建这样的用户，用 CREATE ROLE name CREATEDB。

role creation
一个角色要想创建更多角色，必须明确给予其权限（除了超级用户之外， 因为超级用户绕开所有权限检查）。要创建这样的角色， 使用 CREATE ROLE name CREATEROLE。 一个带有 CREATEROLE 权限的角色也可以更改和删除其它角色， 以及给其它角色赋予或者撤销成员属性。 不过，要创建，更改，删除或者改变一个超级用户角色的成员关系，需要有超级用户状态； CREATEROLE 还不够处理这些。

口令
只有在对客户认证方法要求客户在与数据库建立连接是使用口令的时候，口令才比较重要。 password，md5，和 crypt 认证方法使用口令。 数据库口令与操作系统口令是无关的。在创建角色的时候声明一个口令是这样： CREATE ROLE name PASSWORD 'string'。

一个角色的属性可以在创建后用 ALTER ROLE 修改。 参考 CREATE ROLE 和 ALTER ROLE 的手册获取细节。

提示: 创建一个具有 CREATEDB 和 CREATEROLE 权限，但是并非超级用户的角色是一个很好的习惯， 你可以使用这个角色进行所有日常的数据库和角色的管理。这个方法避免了以超级用户操作时， 发生误操作导致的严重后果。

一个角色也可以为许多运行时配置设置个人缺省， 那些配置在 Chapter 17 里描述。 比如，如果出于某种原因你想在所有你做的连接中关闭索引扫描（提示：不是个好主意）， 你可以用

ALTER ROLE myname SET enable_indexscan TO off;
这样就会保存该设置（但是不是立即设置）。 这么做后，在这个角色随后的连接中就好像在会话开始之后都马上 SET enable_indexscan TO off;了一样。 你也可以在会话中修改这个设置；它只是缺省。要撤销任何这样的设置， 使用 ALTER ROLE username RESET varname;。 请注意，对那些没有 LOGIN 权限的角色，这些角色相关的缺省值几乎没什么用， 因为它们从来不会被调用。

========
18.3. 权限

在创建对象的时候，它会被赋予一个所有者。通常所有者就是执行创建语句的角色。 对于大多数类型的对象，初始状态是只有所有者（或者超级用户）可以对该对象做任何事情。 要允许其它用户使用这个对象，必须赋予权限。 系统里面有好几种不同类型的权限：SELECT，INSERT， UPDATE，DELETE，RULE， REFERENCES，TRIGGER，CREATE， TEMPORARY，EXECUTE，和 USAGE。 有关 PostgreSQL 支持的不同类型的权限的更多信息， 请参阅 GRANT 参考页。

要赋予权限，我们使用 GRANT 命令。 所以，如果 joe 是一个现有的角色， 而 accounts 是一个现有的表，那么可以用下面的命令更新表的权限

GRANT UPDATE ON accounts TO joe;
我们可以用特殊的名字 PUBLIC 把对象的权限赋予系统中的所有角色。 在权限声明的位置上写 ALL，表示把适用于该对象的所有权限都赋予目标角色。

要撤销权限，使用合适的 REVOKE 命令：

REVOKE ALL ON accounts FROM PUBLIC;
对象的所有者是一个特殊的权限（也就是说，修改和删除对象的权限）总是隐含地属于所有者， 不能赋予或者删除，但是所有者可以选择撤销他拥有的普通权限，比如， 把一个表做成对自己是只读的或者其它什么的东西。

只要对象的类型合适，我们可以用一个 ALTER 命令给这个对象赋予一个新的所有者。 超级用户总是能做这件事奇怪； 普通的角色只能是在他们目前是该对象的所有者（或者是所有角色的成员）并且是新的所有角色的成员的情况下做这个事情。

========
18.4. 角色成员

把用户组合起来简化权限管理是个常用的便利方法：用这样的方法， 权限可以赋予整个组，也可以对整个组撤消。在 PostgreSQL 里， 这些事情是通过创建代表一个组的角色，然后赋予组角色的成员权限给独立的用户角色的方法实现的。

要设置一个组角色，首先创建角色：

CREATE ROLE name;
Typically a role being used as a group would not have the LOGIN attribute, though you can set it if you wish.

一旦组角色存在了，那么你就可以用 GRANT 和 REVOKE 命令添加和撤消权限：

GRANT group_role TO role1, ... ;
REVOKE group_role FROM role1, ... ;
你还可以赋予成员权限给其它组角色（因为在组角色和非组角色之间没有实质的区别）。 唯一的制约是你不能建立循环的成员关系。

一个角色的成员可以用两种方法使用组角色的权限。首先，一个组的每个成员都可以明确用 SET ROLE 临时"变成"改组成员。在这个状态下，数据库会话具有该组角色的权限， 而不是原始的登录角色权限，这个时候创建的数据库对象被认为是由组角色拥有，而不是登录角色。 第二，拥有 INHERIT 属性的角色成员自动具有它们所属角色的权限。 例如，假如我们做了下面的事情：

CREATE ROLE joe LOGIN INHERIT;
CREATE ROLE admin NOINHERIT;
CREATE ROLE wheel NOINHERIT;
GRANT admin TO joe;
GRANT wheel TO admin;
那么在立即以角色 joe 连接之后，该数据库会话讲拥有直接赋予 joe 的权限加上任何赋予 admin 的权限，因为 joe "继承"了 admin 的权限。 不过，赋予 wheel 的权限不可用，因为即使 joe 是 wheel 的一个间接成员，但该成员关系是通过 admin 过来的， 而该组有 NOINHERIT 属性。在

SET ROLE admin;
之后，该会话将只拥有那些赋予 admin 的权限，而不包括那些赋予 joe 的权限。 在

SET ROLE wheel;
之后，该会话讲只能使用赋予 wheel 的权限，而不包括赋予 joe 或者 admine 的权限。原来的权限可以用下列之一恢复：

SET ROLE joe;
SET ROLE NONE;
RESET ROLE;
注意: SET ROLE 命令总是允许选取任意登录角色直接或者间接所在的组角色。 因此，在上面的例子里，我们没必要在变成 wheel 之前先变成 admin。

注意: 在 SQL 标准里，在用户和角色之间有一个明确的区别， 并且用户并不会自动继承权限，而角色可以。这个行为在 PostgreSQL 里面可以通过给予那些当作 SQL 角色使用的角色以 INHERIT 属性， 而给予当作 SQL 用户使用的角色以 NOINHERIT 属性来实现。 不过，PostgreSQL 缺省是给予所有角色 INHERIT 属性， 目的是和 8.1 之前的版本向下兼容，那些版本里，用户总是能使用他们所在组被赋予的权限。

角色属性 LOGIN，SUPERUSER 和 CREATEROLE 可以认为是特殊的权限，但是它们从来不会像数据库对象上的普通权限那样继承。 你必须真实地 SET ROLE 到一个特殊的角色，这个角色应该是拥有这些属性的角色， 然后才能利用这些属性。继续上面的例子，我们也可以选择给 admin 角色赋予 CREATEDB 和 CREATEROLE 权限。 然后，以 joe 连接的绘画不会立即有这些权限，只有在 SET ROLE admin 之后才有。

要删除一个组角色，用 DROP ROLE：

DROP ROLE name;
任何在组角色里面的成员关系都会自动撤消（但是成员角色自己则不会受影响）。 不过，请注意任何组角色拥有的对象都必须首先删除或者赋予其它所有者； 并且任何给该组角色赋予的权限都必须撤消。

=========
18.5. 函数和触发器

函数和触发器允许用户向后端服务器插入代码，这样其他用户可以在无意的情况下执行这些代码。 因此，两种机制都可以让用户相当隐蔽地给别人设置 "Trojan horse（木马）"， 唯一的有效防护就是严格控制谁可以定义函数。

后端服务器里面运行的函数都是以数据库服务器守护进程的操作系统权限运行的。 如果所使用的编程语言允许无检查的内存访问，那么是可能修改服务器的内部数据结构也是可能的。 因此，除了其他问题外，这样的函数可以绕过任何系统访问控制。 允许这样访问的函数语言都被认为是"不可信的（untrusted）"， PostgreSQL 只允许超级用户使用这样的语言书写函数。

（本章完）