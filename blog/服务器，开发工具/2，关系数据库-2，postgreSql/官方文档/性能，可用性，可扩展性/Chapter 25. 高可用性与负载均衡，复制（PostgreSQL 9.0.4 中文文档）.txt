PostgreSQL 9.0.4 中文文档-Chapter 25. 高可用性与负载均衡，复制
http://www.highgo.com.cn/docs/docs90cn/high-availability.html

======
25.1. 不同解决方案的比较

25.2. 日志传送备份服务器
25.2.1. 规划
25.2.2. 备用服务器操作
25.2.3. 为备用服务器准备主服务器
25.2.4. 建立备用服务器
25.2.5. 流复制

25.3. 失效切换

25.4. 日志传送的替代方法
25.4.1. 实施
25.4.2. 基于记录的日志传送

25.5. 热备
25.5.1. 用户概述
25.5.2. 处理查询冲突
25.5.3. 管理员概述
25.5.4. 热备参数参考
25.5.5. Caveats

=======
多个数据库服务器可以协同工作，比如在主服务器失效的时候备份服务器立即取代它的位置(高可用性)， 
或者几台机器同时服务于同一个数据库(负载均衡)。
理想状态多台服务器之间可以无缝协作。 
为静态页面提供服务的Web服务器可以轻松的通过将web请求分摊到多台机器从而实现负载均衡。 
事实上，只读数据库也能轻松的以相同的方法实现负载均衡。 
不幸的是，大多数数据库服务器都需要同时处理混合的读/写请求，将这些数据库联合起来工作是件很麻烦的事。 
虽然只读数据只需要在每台服务器上复制一份即可，
但是在任何一台服务器上的写动作都必须传播到其它所有服务器上， 这样才能保证将来对这些已修改数据的读取返回一致的结果。

这个“写同步问题”就是导致多台服务器协同工作麻烦重重的最基本原因。 
有多种解决此问题的方法，其思路也各不相同，但都不是既简单又高效的方案。

有一种解决方案是仅允许单独的一台"主"服务器修改数据，其它"从"服务器只能读取数据， 还可能存在平时不允许访问、
仅在失效切换后代替主服务器的"备用"服务器。 
跟踪“主”服务器数据变化的叫“备”或“从”服务器。
备用服务器不能连接到主服务器， 直到它晋升为“暖备”服务器。
可以接受连接而且只读服务器称为“热备”服务器。

一些失效切换和负载均衡方案是"同步的"，意思是直到所有服务器都完成了某个修改数据的事务之后，该事务才被认为是已经完成的。 
这将确保失效切换不会丢失任何数据并且所有服务器都将返回一致的结果。 

另一些方案是"异步的"，这种方案允许在事务提交之后与传播到所有其它服务器之间有一小段延时， 
但是在切换到备份服务器的时候某些事务可能会丢失，并且不同的服务器可能返回不一致的结果。 
当同步可能会很慢的时候可以使用异步通信。

还可以按照粒度对解决方案进行分类。 
某些方案只能将整个数据库集群作为一个整体，而某些方案可以针对每个数据库或每张表分别做不同的处理。

在选择任何失效切换或负载均衡方案的时候都必须考虑性能因素。 
功能和性能不可兼得，比如，一个完全同步的解决方案在慢速网络上可能削减性能一半以上， 
而完全异步的方案可能仅对性能有极其微小的影响。

下面的部分大致描述了各种常见的失效切换、复制、负载均衡方案。 
glossary也是可用的。

======
25.1. 不同解决方案的比较

共享磁盘失效切换
共享磁盘失效切换通过仅保存一份数据库副本来避免花在同步上的开销。 
这个方案让多台服务器共享使用一个单独的磁盘阵列。 
如果主服务器失效，备份服务器将立即挂载该数据库，就像是从一次崩溃中恢复一样。
这个方案允许快速的失效切换并且不会丢失数据。

共享硬件的功能通常由网络存储设备提供，也可以使用完全符合POSIX行为的网络文件系统(NFS)。 
这种方案的局限性在于如果共享的磁盘阵列损坏了，那么整个系统将会瘫痪。 
另一个局限是备份服务器在主服务器正常运行的时候不能访问共享的存储器。

文件系统复制（块设备）
一种改进的方案是文件系统复制：对文件系统的任何更改都将镜像到备份服务器上。 
这个方案的唯一局限是必须确保备份服务器的镜像与主服务器完全一致，特别是写入顺序必须完全相同。 
DRBD是Linux上的一种流行的文件系统复制方案。

使用即时恢复(PITR)的热备份
热备份服务器可以通过读取WAL记录流来保持数据库的当前状态。 
如果主服务器失效，那么热备份服务器将包含几乎所有主服务器的数据，并可以迅速的将自己切换为主服务器。 
这是一个异步方案，并且只能在整个数据库服务器上实施。

使用基于文件的日志传送或流复制，或两者相结合实现PITR备份服务器。
前者参阅Section 25.2, 后者参阅Section 25.2.5。请参阅Section 25.5获取关于热备的信息。

基于触发器的主备复制
这个方案将所有修改数据的请求发送到主服务器。
主服务器异步向从服务器发送数据的更改信息。 
从服务器在主服务器运行的情况下只应答读请求。
对于数据仓库的请求来说，从服务器非常理想的。

Slony-I是这个方案的一个例子，它支持针对每个表的粒度并支持多个从服务器。 
因为它异步、批量的更新从服务器，在失效切换的时候可能会有数据丢失。

基于语句的复制中间件
以使用一个基于语句的复制中间件程序截取每一个SQL查询，并将其发送到某一个或者全部服务器。 
每一个服务器都独立运行。 
写请求发送给所有服务器，读请求则仅发送给某一个服务器，从而实现读取的负载均衡。

如果只是简单的广播修改数据的SQL语句， 
那么类似random(),CURRENT_TIMESTAMP以及序列函数在不同的服务器上将生成不同的结果。 
这是因为每个服务器都独立运行并且广播的是SQL语句而不是如何对行进行修改。 
如果这种结果是不可接受的，那么中间件或者应用程序必须保证
始终从同一个服务器读取这些值并将其应用到写入请求中。 
另外还必须保证每一个事务必须在所有服务器上全部提交成功或者全部回滚， 
或者使用两阶段提交(PREPARE TRANSACTION 和COMMIT PREPARED)。 
Pgpool-II和Sequoia是这种方案的实例。

异步多主服务器复制
对于那些不规则连接的服务器(比如笔记本电脑或远程服务器)，要在它们之间保持数据一致是很麻烦的。 
在这个方案中，每台服务器都独立工作并周期性的与其他服务器通信以识别相互冲突的事务。 
可以通过用户或者冲突判决规则处理出现的冲突。

同步多主服务器复制
在这种方案中，每个服务器都可以接受写入请求，
修改的数据将在事务被提交之前必须从原始服务器广播到所有其它服务器。 
过多的写入动作将导致过多的锁定，从而导致性能低下。 
事实上，在多台服务器上同时写的性能总是比在单独一台服务器上写的性能低。 
读请求将被均衡的分散到每台单独的服务器。 
某些实现使用共享磁盘来减少通信开销。
同步多主服务器复制方案最适合于读取远多于写入的场合。 
它的优势是每台服务器都能接受写请求因此不需要在主从服务器之间划分工作负荷。
因为在服务器之间发送的是数据的变化，所以不会对非确定性函数(比如random())造成不良影响。

PostgreSQL不提供这种类型的复制。 
但是PostgreSQL的两阶段提交(PREPARE TRANSACTION和COMMIT PREPARED)
可以用于在应用层或中间件代码中实现这个功能。

商业解决方案
因为PostgreSQL是开放源代码并且很容易被扩展，
许多公司在PostgreSQL的基础上创建了商业的闭源解决方案， 提供独特的失效切换、复制、负载均衡功能。

Table 25-1总结了以上所列的各种解决方案的能力。

Table 25-1. 高可用性，负载均衡，和复制功能矩阵

Feature	SharedDiskFailover	FileSystemReplication	Hot/WarmStandbyUsingPITR	Trigger-BasedMaster-StandbyReplication	Statement-BasedReplicationM iddleware	AsynchronousMultimasterReplication	SynchronousMultimasterReplication
MostCommonImplementation	NAS	DRBD	PITR	Slony	pgpool-II	Bucardo	 
CommunicationMethod	shareddisk	diskblocks	WAL	tablerows	SQL	tablerows	tablerowsandrowlocks
Nospecialhardwarerequired	 	•	•	•	•	•	•
Allowsmultiplemasterservers	 	 	 	 	•	•	•
Nomasterserveroverhead	•	 	•	 	•	 	 
Nowaitingformultipleservers	•	 	•	•	 	•	 
Masterfailurewillneverlosedata	•	•	 	 	•	 	•
Standbyacceptread-onlyqueries	 	 	Hotonly	•	•	•	•
Per-tablegranularity	 	 	 	•	 	•	•
Noconflictresolutionnecessary	•	•	•	•	 	 	•

有几个解决方案不适合上边这些分类：

数据分区
数据分区将表拆分为数据集。每个数据集只有一台服务器可以修改。
例如，数据可以按办事处进行分区，例如，伦敦和巴黎，每个办公室用一个服务器。 
如果查询需要伦敦和巴黎相结合的数据，应用程序可以查询两台服务器，
或主/备用复制可以用来保持每个服务器上有其他办公室的只读数据副本。

多服务器并行查询执行
许多上述解决方案允许多个服务器来处理多个查询，但不是允许单个查询使用多个服务器来更快完成。 
此解决方案允许多个服务器上单个查询同时运行。
它通常被通过服务器之间的数据分开而执行其查询的一部分， 
并将结果返回到中央服务器，由它来联合结果并返回给用户。
Pgpool-II有这种能力。 也可以使用PL/Proxy工具集实现。

=========
25.2. 日志传送备份服务器

连续归档可以配合随时准备取代失效主服务器的一个或多个备份服务器，用于创建一个高可用性(HA)集群。 
这个能力通常被称为热备份或日志传送(LogShipping)。

虽然主服务器和备份服务器只是松散的耦合在一起，但它们必须同时运行。 
主服务器以连续归档模式运行，备份服务器以连续恢复模式运行并从主服务器不停的读取WAL文件。 
因为数据库的表无需为此进行任何改变，所以与其它复制方法相比，额外的管理开销很小。 
并且这种方法对主服务器的性能影响也很小。

直接移动WAL或在数据库服务器之间"传送"日志记录通常被称为日志传送(LogShipping)。 
PostgreSQL实现了基于文件的日志传送，意思是WAL记录每次移动一个完整的文件(WAL段)。 
WAL文件可以被轻易的在任意两个地点之间传送，不管是与邻近的系统还是地球另一面的系统。 
所需带宽取决于主服务器的事务发生速度。 
基于记录的日志传送也可以通过Section 25.2.5中讨论的自定义过程实现。

日志传送是异步的，也就是WAL记录在事务提交之后才被传送。 
也就是说主服务器遭遇致命故障后尚未传送的事务数据将会丢失。 
数据丢失的长度可以使用archive_timeout加以限制，比如限制为几秒钟。 
当然这么小的设置也导致了传送带宽的大幅增长。 
如果你期望将丢失的数据限制在一分钟之内，可能更好的办法是使用"基于记录"的日志传送。 
参考Section 25.2.5。

因为不停的执行恢复过程，备份服务器在通常情况下是不能被访问的。 
由于恢复速度非常快，备份服务器通常在启用后只有很短的时间不能使用。 
因此，我们认为这个方案可以作为热备份来提供高可用性。 
将服务器从一个已归档的基础备份中恢复将可能耗费大量时间，
所以这个方案只能用于灾难恢复而不能用于提供高可用性。

====
25.2.1. 规划

至少从数据库服务器的角度看，创建主服务器和备份服务器并令两者尽可能完全相同是非常明智的。 
特别是表空间的路径名必须保持完全一致，
这样主服务器和备份服务器就必须拥有同样的表空间挂载路径(如果使用了表空间的话)。 
需要记住的是如果在主服务器上执行了CREATE TABLESPACE命令， 
那么该命令需要的任何新挂载点必须在执行该命令之前
同时在主服务器和备份服务器上创建。 
硬件不必完全相同，但是经验显示维护两个完全相同的系统比维护两个不同的系统要少许多麻烦。 
无论如何，应尽量保持体系结构相同，比如一个是32-bit系统另一个是64-bit系统将不能正常工作。

通常，在主版本不同的服务器之间传送日志是不可能的，但是次版本不同是可以的，
因为它们的磁盘格式相同， 不过我们鼓励你尽可能使用完全相同的版本。 
在进行版本升级的时候，正确的做法是首先升级备份服务器， 
因为新版本的服务器通常可以读取老版本的WAL文件，但反之则不然。

25.2.2. 备用服务器操作

在备用模式，该服务器连续应用从主服务器收取的WAL。
备服务器可以从一个WAL归档（参阅restore_command）或 直接通过一个TCP连接（流复制）从主服务器上读取WAL。
备服务器也可以在备用集群pg_xlog尝试查找恢复任何WAL。 
这通常发生在服务器重启后，当备服务器重播，在备服务器重启前，从主服务器流复制的WAL，
但是你也可以手工复制文件到pg_xlog， 在任何时候可以重播它们。

在启动，备服务器恢复可用在所有的WAL开始存档位置,调用restore_command。 
一旦它到达可用WAL的结束，restore_command失败，将尝试恢复pg_xlog目录下任何可用的WAL。 
如果那也失败了，并且已经配置了流复制，
则尝试连接到主服务器，从在归档或pg_xlog找到最后一条有效的记录开始WAL流。 
如果那也失败了，或没有配置流复制，或连接断开，
备服务器再次回到步骤1，循环尝试从归档里恢复文件。
从归档，pg_xlog， 通过连续流复制直到服务器停止或有触发器文件触发的失效切换时。

当找到一个触发文件（trigger_file）时，退出备用模式并且服务器切换到正常运行。
在失效切换前，将立即恢复归档或pg_xlog 任何可用的WAL，但不做尝试连接主服务器。

25.2.3. 为备用服务器准备主服务器

在主服务器上设置连续归档到一个备服务器可访问的存档目录，像描述在Section 24.3。 
即使主服务器关掉，从备服务器应该可以访问这个归档位置。
即它应该驻留在被服务器自身或其它可信赖的服务器，而不是主服务器。

如果你想使用流复制，在主服务器上设置认证，允许从备用服务器复制连接； 
在pg_hba.conf提供一个或多个合适项使用数据库字段设置replication。 
还要在主服务器的配置文件确保设置max_wal_senders足够大。

启动备用服务器做一个基准备份，描述在Section 24.3.2.

25.2.4. 建立备用服务器

要建立备用服务器，从主服务器恢复基准备份（参阅Section 24.3.3）。 
在备用服务器的集群数据目录，创建一个恢复命令文件recovery.conf ，开启standby_mode。 
设置restore_command为一条从WAL归档复制文件的简单命令。

Note: 不要使用内置在这里描述的备用模式pg_standby或类似的工具。
如果该文件不存在，restore_command应该立即返回。 
如果必要服务器将再次尝试这个命令。
参阅Section 25.4关于使用工具像pg_standby。

如果你想使用流复制，在primary_conninfo填写一个libpq连接串，
其包括主机名（或IP地址）和连接到主服务器需要的其它详细信息。 
如果主服务器需要个密码验证，也要在primary_conninfo指定所需要的密码。

如果你要建立高可用目的备服务器，设置WAL归档，像主服务器的连接和身份验证，因为在失效切换后，备服务器要作为主服务器运行。 
你还需要设置trigger_file它可能失效切换。
如果你建立报告目的备服务器，没有规划失效切换到它，不必须要trigger_file。

如果你使用WAL归档，其大小可以使用archive_cleanup_command 这个参数设置最小，用来删除那些备服务器不再需要的文件。
专门设计的pg_archivecleanup 这个实用程序就是在通常的单备配置里，使用archive_cleanup_command的。 
请注意不过，如果你使用备份目的归档，你仍要保留需要恢复的至少最新的基准备份文件，即使备服务器不再需要。

recovery.conf一个简单例子是：

standby_mode='on'
primary_conninfo='host=192.168.1.50port=5432user=foopassword=foopass'
restore_command='cp/path/to/archive/%f%p'
trigger_file='/path/to/trigger_file'
archive_cleanup_command='pg_archivecleanup/path/to/archive%r'

你可能有任何数目的备服务器，但是如果你用流复制，确保你在主服务器上设置的max_wal_senders足够大允许它们同时连接。

====
25.2.5. 流复制

与基于文件日志传送相比，流复制允许保持备服务器更新。 
备服务器连接主服务器，其产生的流WAL记录到备服务器，而不需要等待填写WAL文件。

流复制是异步的，所以在主事务提交和变化成为在备服务器可见之间,还有一个小的延迟。 
这个延迟远小于基于文件日志传送，通常1秒内足够与负载保持。
使用流复制，为减少数据丢失窗口 archive_timeout不是必要的。

如果使用流复制而不是基于文件连续归档，
你要在主服务器设置wal_keep_segments为 一个足够大的值以使不太早的回收旧WAL段，当备服务器可能仍需要它们赶上。
如果备服务器落后太多， 需要用一个新基准备份重新初始化。
如果你设置一个备服务器可访问的WAL归档，wal_keep_segments是不必要的， 作为备服务器总是使用归档来赶上。

要使用流复制，建立一个基于文件的日志传送备服务器描述在Section 25.2。 
该步将一个基于文件的日志传送备服务器转为流复制备服务器，
在recovery.conf文件中设置primary_conninfo 指向主服务器。
在主服务器上设置listen_addresses和身份验证选项（见pg_hba.conf），
因此备用服务器 可以连接到在主服务器的replication伪数据库（参阅Section 25.2.5.1）。

在系统上支持保持活动的的套接字选项，设置tcp_keepalives_ idle， 
tcp_keepalives_interval和tcp_keepalives_count帮助主机及时发现断开的连接。

设置备用服务器的最大并发连接数。（参阅max_wal_senders关于详细信息）。

当启动了备服务器并且正确设置了primary_conninfo,该备服务器在回放所有可用的WAL文件后，将连接到主服务器。 
如果成功建立了该连接，你将在备服务器中看到WAL接收进程，并且在主服务器相应的一个WAL发送进程。

==
25.2.5.1. 身份验证

复制的访问权限设置是很重要的，所以只有受信任的用户可以读取WAL流，因为很容易从中提取权限信息。 
备服务器必须验证作为主服务器的超级用户。
所以需要在主服务器上创建一个有SUPERUSER和LOGIN权限的角色。

由一条pg_hba.conf记录指定replication在database字段，控制客户端的复制验证。 
例如，如果备服务器是运行在主机IP192.168.1.100和复制时超级用户名为foo，
管理员可以在主服务器 pg_hba.conf文件里添加下面行：

#Allowtheuser"foo"fromhost192.168.1.100toconnecttotheprimary
#asareplicationstandbyiftheuser'spasswordiscorrectlysupplied.
#
#TYPEDATABASEUSERCIDR-ADDRESSMETHOD
hostreplicationfoo192.168.1.100/32md5

主服务器的主机名和端口号，连接用户名，和在recovery.conf文件指定的密码。 
该密码也可以在备服务器的~/.pgpass文件里设置。 
（在database字段指定replication）。 
例如，如果主服务器是运行的主机IP192.168.1.50,端口号5432, 复制时超管用户名为foo，和密码为foopass，
管理员可以在备服务的recovery.conf文件里 添加下面行：

#Thestandbyconnectstotheprimarythatisrunningonhost192.168.1.50
#andport5432astheuser"foo"whosepasswordis"foopass".
primary_conninfo='host=192.168.1.50port=5432user=foopassword=foopass'

25.2.5.2. 监控

流复制的一个重要的健康指标是在主服务器生成的WAL记录数，而不是在备服务器应用的数量。 
通过比较在主服务器当前WAL写的位置和备服务器收到的最后一个WAL位置，就可以计算出这种滞后。 
在主服务器上使用pg_current_xlog_location和
在备服务器上使用pg_last_xlog_receive_location 可以分别检索到它们（参阅Table 9-56和Table 9-57关于详细信息）。	 
在备服务器收到最后的WAL位置也会进程状态的WAL接收进程显示，使用ps命令显示（参阅Section 27.1关于详细信息）。

=========
25.3. 失效切换

如果主服务器失败，则备服务器应该开始失效切换处理。

如果备服务器失败，则没有失效切换需要考虑。
如果可以重启备用服务器，甚至一段时间后，也可以立即重启恢复进程，发挥重启恢复的优势。 
如果不能重启备服务器，则应该创建一个全新的备服务器实例。

如果主服务器失败，并且备服务器成为新主服务器，
然后旧主服务器重启， 你必须有一个通知旧主服务器，其不再是主服务器的机制。
这有时被称为STONITH（在头去掉其它节点），这是必要的，
以避免系统都认为它们是主服务器的情况下，这将导致混乱和最终数据丢失。

许多失效切换系统只使用两个系统，主备服务器，通过某种心跳机制，不断验证两者连接和主服务器的活力。 
也可以使用一个第三方的系统（称为“证人服务器”），以防止某些情况下不适当的失效切换，
但额外的复杂性可能是不值得的， 除非设置它为充分仔细和严格的测试。

PostgreSQL 不提供所需的用来确定主服务器失败，并通知备用数据库服务器的系统软件。 
存在许多这样的工具和成功失效切换所需的集成操作系统的工具，如IP地址迁移。

一旦发生失效切换到备服务器，仅有一台服务器运行。这就是所谓的退化状态。 
前者备服务器现在是主服务器，但前者主服务器是可能会停留下来。 
要返回正常运行，必须重建一个备服务器，无论是在以前的服务器，或在第三，可能是新的系统。 
一旦完成主备服务器，可以考虑转换角色。
有些人选择使用第三方服务器，提供新主服务器的备份 直到新备服务器重建，尽管清楚这个复杂的系统配置和操作流程。

所以从主到备服务器可以快速切换，但需要一些时间重新准备失败切换集群。 
定期主备服务器切换是有用的,因为它允许定期停机进行每个系统的维修。 
这也是作为一个测试，以确保故失效切换机制，当你需要时会真的工作。 
建议写管理操作流程。

要触发日志传送备服务器的失效切换，创建一个触发文件,通过在recovery.conf文件中trigger_file设置文件名和路径。 
如果没有给trigger_file，便没有方法在备服务器退出恢复，推进它为主服务器。 
这对于例如报告服务器有用的，其仅用于可分载从主服务器的只读查询，而不是针对高可用性的目的。

===========
25.4. 日志传送的替代方法

一种替代在前节描述的内建备用模式的方法是使用restore_command轮询归档位置。 
这是只能在8.4及以下版本选择使用。
在此设置standby_mode关闭，因为你要实现备服务器运行你自己所需的轮询。 
请参考contrib/pg_standby（Section F.28）关于这类的实现。

请注意在这种模式，服务器将一次应用一个WAL文件，
所以如果你使用备服务器对于查询（见热备）， 
在主服务器中的动作和当这个动作在备服务器中可见之间有个延迟，相应的时间用在填写WAL文件。 
还要注意你不能用这种方法结合“流复制”。

主备用服务器上发生的操作是正常的连续归档和恢复任务。
两个数据库服务器相联系的仅有点是两者共享的WAL归档文件： 主写入归档，备从归档读取。
必须小心，以确保从单独的主服务器，不会混在一起或混淆WAL归档。
归档需要并不大， 如果只是备服务器操作要求。

使松散耦合的两个服务器一起工作简直是奇迹，
在备服务器上简单使用restore_command, 当询问下一个WAL文件，等待其为主服务器可用的。
在备服务器的recovery.conf文件指定restore_command。 
通常恢复进程将从一个WAL归档中请求文件，如果该文件不可用，则报告失败。 
对备服务器进程来说下一个WAL文件不可用是正常的，因此备服务器进程需要等待它出现。 
对于在.backup或.history文件结束不需要等待，并且返回一个非零值。 
等待restore_command可以写为一个自定义脚本，即循环轮询下一个WAL文件的存在。 
还必须有一些方法来触发失效切换，应该中断的restore_command，跳出循环，并返回备用服务器一个文件未找到错误。 
这两端的恢复和备用服务器，然后将作为一个正常的服务器。

一个合适restore_command的伪码是：

triggered=false;
while(!NextWALFileReady()&&!triggered)
{
sleep(100000L);/*waitfor~0.1sec*/
if(CheckForExternalTrigger())
triggered=true;
}
if(!triggered)
CopyWALFileForRecovery();

一个等待restore_command的工作例子由contrib模块名为pg_standby提供。 
应该用来作为参考如何正确地贯彻执行上述逻辑。
它也可以扩展需要，以支持特定的配置和环境。

触发失效切换的方法是规划和设计的一个重要组成部分。
一个潜在的选项是restore_command命令。 
每个WAL文件执行一次，但是运行restore_command的进程对于每个文件创建和消亡的， 
所以没有守护进程或服务器进程和信号或不能使用的信号处理。 
因此，restore_command不适合触发失效切换。
使用简单超时机制可能的，尤其如果与已知的archive_timeout 在主服务器上配合设置使用。
尽管，这有点容易出错，因为网络问题或繁忙的主服务器可能有足够的启动失效切换。 
通报机制，如显式创建一个触发器文件是理想的，如果可以安排。

====
25.4.1. 实施

配置备用服务器，使用这种替代方法简短步骤如下。 
对于每一步的细节，请参阅前面的章节。

建立主备系统尽可能接近相同，包括两个PostgreSQL副本在相同版本级别。

设置从主服务器上连续归档到备服务器WAL归档目录。
确保在主服务器上相应的设置archive_mode， archive_command和archive_timeout。

做一个主服务器的基准备份，到备服务器上加载这个数据。（请参阅Section 24.3.2）。

在备服务器上从一个本地的WAL归档开始恢复，如前所述等待使用recovery.conf所指定的restore_command。 （请参阅Section 24.3.3）。

恢复对WAL归档做只读处理，所以一旦在Wal的文件已被复制到备用系统，就可以在同一时间复制到磁带，因为正通过备用数据库服务器读取到。 
因此，运行高可用性的备用服务器可以同时作为文件存储长远的灾难恢复目的做处理。

出于测试目的，它是可以在同一系统上运行的主备服务器。 
没提供任何值得改进服务器的健壮性，也不会描述为HA。

====
25.4.2. 基于记录的日志传送

也有可能实现基于记录的日志传送使用这种替代方法，尽管这需要定制开发，
变化仍然只能为热备查询后一个完整的WAL文件传到成为可见的。

一个外部程序可以调用pg_xlogfile_name_offset()这个函数
用来找出文件名和当前WAL结尾的准确字节偏移。 
然后，可以直接访问WAL文件，并从WAL的上次已知的结尾到当前结束数据复制数据到备用服务器。
用这种方法，数据丢失窗口是复制程序的轮询周期时间， 其可以非常小，并没有迫使部分使用的段文件要归档的带宽浪费。
请注意备服务器上的restore_command脚本只能处理完整的WAL文件， 所以通常的增量备份数据到备服务器不可用。
只有在主服务器死掉，在允许它到来前，最后一部分WAL文件送到备服务器。 
在这个进程中的正确实现，需要restore_command脚本与数据复制程序协作。

PostgreSQLversion9.0开始，你可以使用流复制达到事半功倍的效果。 （请参阅Section 25.2.5）。

=========
25.5. 热备

热备术语是用来形容连接到服务器，并运行只读查询的能力，而服务器在归档恢复或备模式。 
对复制目的和非常精确的备份恢复到所需的状态，这是非常有用的。 
长期的热备，也指从恢复到正常运行的服务器的能力，而用户继续运行的查询和/或保持连接开放。

在热备用模式运行查询与正常的查询操作类似，虽然有几个使用和管理的差异解释如下。

25.5.1. 用户概述

当备用服务器上hot_standby参数的设置为真时，将开始接受连接，一旦恢复带来的系统到一致的状态。 
所有这些连接都严格只读的,甚至可能没有可写的临时表。

数据从主服务器到备服务器上需要一些时间，所以会有一个主备数据库间的可测量的延迟。 
因此，在主备服务器上几乎同时运行同样的查询返回不同的结果。
我们说在备服务器上的数据最终与主服务器上的一致。 
一旦事务提交记录在备服务器是上回放，由事务产生的变化对于在备服务器上的任何新快照来说是可见的。 
快照可能是在每个查询或事务的开始，取决于当前事务的隔离级别。请参阅Section 13.2获取更多的信息。

热备期间开始的事务可能会发出下面的命令：

查询访问-SELECT,COPYTO

游标命令-DECLARE,FETCH,CLOSE

参数-SHOW,SET,RESET

事务管理命令

BEGIN,END,ABORT,STARTTRANSACTION

SAVEPOINT,RELEASE,ROLLBACKTOSAVEPOINT

EXCEPTION阻塞其它内部的子事物。

LOCKTABLE，但是仅当明确在这些模式之一： ACCESSSHARE，ROWSHARE或ROWEXCLUSIVE.

规划和资源-PREPARE，EXECUTE， DEALLOCATE，DISCARD

Pluginsandextensions-LOAD

在热备期间开始的事务，将从不会分配事务ID，并且不能写入到系统预写日志。 
因此，以下操作将产生错误信息：

数据操纵语言(DML)-INSERT, UPDATE,DELETE,COPYFROM, TRUNCATE. 
请注意，不允许操作在恢复期间正执行触发器的结果。
此限制也适用于临时表，因为不分配一个事务ID，不能读取或写入表行， 在一个热备环境这种情况是不可能的。

数据定义语言(DDL)-CREATE， DROP，ALTER，COMMENT。 
甚至临时表也适用这个限制，因为执行这些操作将需要更新系统空间表。

SELECT...FORSHARE|UPDATE，因为行锁，不能不采取更新底层数据文件。

在SELECT语句上的规则产生DML命令。

LOCK明确要求一个高于ROWEXCLUSIVEMODE的模式。

LOCK简短的缺省形式,自它请求ACCESSEXCLUSIVEMODE.

事务管理命令明确设置非只读状态：

BEGINREADWRITE, STARTTRANSACTIONREADWRITE

SETTRANSACTIONREADWRITE, SETSESSIONCHARACTERISTICSASTRANSACTIONREADWRITE

SETtransaction_read_only=off

两阶段提交命令-PREPARETRANSACTION， COMMITPREPARED，ROLLBACKPREPARED 因为即使只读事务需要在准备阶段写WAL。（两种阶段提交的第一个阶段）。

序列更新-nextval()，setval()

LISTEN，UNLISTEN，NOTIFY

在正常的操作，允许"只读"事务更新序列，使用LISTEN、UNLISTEN、和 NOTIFY，所以热备会话下操作会比通常的只读会话限制稍微更严格。
在将来的版本中这些限制中的一些可能会放宽。

热备间，transaction_read_only这个参数总为真，可能不会变。
但只要没有试图修改数据库， 在热备的连接，将行动就像任何其它的数据库连接。
如果发生失效切换或倒换,数据库将切换到正常的处理模式。 
当服务器改变模式，会话将保持连接。一旦热备完成，有可能初始化读写事务（即使从热备间的会话）。

通过发出的SHOWtransaction_read_only将能告诉用户他们的会话是否只读的。 
另外，一组函数允许用户访问关于备服务器的信息。（请参阅Table 9-57） 
这些允许你写程序获知数据库的当前状态。
这些可以用来监视恢复进程，或允许你写复杂的程序来恢复数据库到特定状态。

====
25.5.2. 处理查询冲突

主备服务器是许多方式松散连接的。
在主服务器上的活动将在备服务器上生效。
作为一个结果， 它们之间有潜在的负面交互或冲突.最容易理解的冲突是性能：
如果在主服务器上发生大数据量加载， 然后将在备服务器上产生类似的WAL记录流，所以备服务器查询可能竞争系统资源，像I/O。

在热备也可能发生额外的类型冲突。
在该场景下，这些冲突是硬冲突。可能需要取消查询，在某些情况下， 为了解决它们，断开连接。
给用户提供几种解决这些冲突的方法。
冲突情况包括：

在主服务器上采取访问排斥锁，包括明确的LOCK命令和多种DDL操作，在备服务器查询访问表冲突。

在主服务器上删除表空间与备服务器查询使用该空间的临时工作文件冲突。

在主服务器上删除一个数据库与在备服务器上连接到那个数据库的会话冲突。

一个从WAL清空记录的应用程序vacuum与在备服务器上事务，其快照仍然可以"看到"已删除的行。

一个从WAL清空记录的应用程序vacuum与在备服务器上查询访问该目标页，不管要删除的数据是否可见。

在主服务器上，这些情况简单等待结果，用户可能选择取消任何冲突的操作。
尽管，在备服务器上没有选择： 在主服务器上已经发生的WAL日志，所以备服务器应用它一定不会失败。
此外，允许WAL应用无限期等待可能是很不明智的。 
因为备服务器的状态将变为增量远落后主服务器的。
因此，提供一个机制，强行取消备服务器上与将要应用WAL记录冲突的查询。

一个该问题情况的例子是管理员在主服务器上运行DROPTABLE一张表，而备服务器当前正查询这张表。 
如果在备服务器上执行了DROPTABLE，明确的备服务器查询不能继续。
如果这个问题情况发生在主服务器。
则DROPTABLE将等到 其它查询完成。
但是当DROPTABLE运行在主服务器时，主服务器不会有关于备服务器查询的信息，因此，将不等待任何备服务器查询。 
当备服务器查询在运行时，WAL改变的记录来到备服务器，导致一个冲突。
备服务器要么延迟应用WAL记录（任何事情也都要在它们之后），不然取消冲突的查询， 由此可以应用DROPTABLE。

当一个冲突查询短的，通常想要允许它完成而延迟WAL应用程序一点点。
但是长时间的延迟WAL应用程序通常不是想要的。 
所以取消机制有参数max_standby_archive_delay和max_standby_streaming_delay， 这定义在WAL应用程序中允许延迟最大值。
一旦查询冲突比应用任何新收取的WAL数据设定有关延迟长，则取消查询冲突。 
有两个参数，因此有两个不同延迟，为从归档读取WAL数据（即从一个基准备份初始化恢复或已经远落后的备服务器赶上） 和通过流复制读取WAL数据的指定延迟。

在备服务器存在高可用性的主服务器，最好设置延迟参数相对短，因此不会由备服务器查询所导致延迟使远落后主服务器。 
不过，如果备服务器意思为执行长时间的查询，那么一个高的或无期限的延迟值是可取的。
请记着如果延迟WAL记录应用程序，则长时间查询将导致 备服务器上的其它会话不能看到最新的变化。

在备服务器查询和WAL回放之间冲突，最常见的原因是"早清除"。 
正常地，PostgreSQL允许清除旧版本行，当根据MVCC规则确保正确的数据可见性,没有事务需要见到它们。 
尽管，这个规则只能应用于主服务器执行的事务。
所以在主服务器上清空将删除行版本，在备服务器上对于一个事务仍然可见。

有经验的用户应该知道行版本清理和行版本冻结都与备服务器查询冲突。
运行手工的VACUUMFREEZE很可能导致冲突，即使表上没有 更新和删除行。

一旦超过了由max_standby_archive_delay或max_standby_streaming_delay指定的延迟，将取消查询冲突。 
这通常结果是一个取消错误，虽然在回放DROPDATABASE整个数据库的情况下，将终止冲突会话。
此外，如果冲突由空闲事务保持， 终止冲突会话。（这个行为可能在将来版本改变）。

可能立即重试已取消的查询（在开始一个新事务之后，当然）。
自查询取消依赖于WAL记录正回放的本质，如果再次执行，已经取消的查询可能很成功。

请记住这些参数与从备服务器接收WAL数据开始所经过的时间比较。
允许备服务器上任何查询的宽期限，从不超过该延迟参数， 并且如果备服务器存在落后主服务器，那么期限的可能相当小。
如等待之前查询执行完成的结果，或不能跟上有大量的更新负载的结果。

用户应该清楚那些表，在主服务器上定期和大量更新表将会很快导致取消备服务器上长时间运行的查询。 
在这类情况下，对max_standby_archive_delay或max_standby_streaming_delay设置一个有限值, 类似于设置statement_timeout。

如果发现不能接受某些取消备服务器查询，补救存在的可能性。
第一个选项是连接主服务器，并保持一个查询活动的按照备服务器上运行查询 所需要的时间。
这阻止VACUUM删除最近的死行，因此清理冲突不会发生。
这能使用contrib/dblink和pg_sleep(), 或通过其它机制。
如果你这样做，你应该知道这将延迟主服务器清理死行，其可能不想要的表膨胀结果。
不过这种情况清理不逊于如果备服务器查询直接运行在 主服务器上，并且你仍然得到卸载执行在备服务器上的好处。
在这种情况下max_standby_archive_delay必须是保持大的，因为延迟WAL文件可能已经 包含了备服务器查询想要的记录项。

另一个选项是在主服务器上增加vacuum_defer_cleanup_age,从而将不会像通常很快的清理掉死行。 
这将允许在备服务器上取消它们前，更多时间给执行查询，无需设置一个高的max_standby_streaming_delay。 
虽然用这种方法保证窗口的执行时间是有困难的，因为vacuum_defer_cleanup_age在主服务器执行的事务中是可测的。

====
25.5.3. 管理员概述

如果在postgresql.conf启用了hot_standby，并且目前有个recovery.conf文件， 该服务器将运行在热备模式。
不过可能花些时间为允许的热备连接，因为该服务器不接受连接直到完成足够的恢复能提供一致的状态， 其查询能运行。
在这个期间，将带有一个错误信息拒绝客户端尝试连接。
为确认该服务器起来了，要么循环尝试从应用程序连接，或者 在服务器日志里查看这些错误信息：

LOG:enteringstandbymode

...thensometimelater...

LOG:consistentrecoverystatereached
LOG:databasesystemisreadytoacceptreadonlyconnections

在主服务器上每个检查点一致的信息记录一次。
在主服务器上没有将wal_level设置为 hot_standby时，当读取正在写的WAL时，启用热备是不可能的。 
存在这些条件的两者也可能延迟达到一致性状态：

一个写事务有多于64个子事务

很长时间活动的写事务

如果你正运行基于文件日志传送（“暖备”），你可能需要等到下一个WAL文件到来，其可能长如在主服务器设置的archive_timeout。

有些参数的设置在备服务器将需要重新配置，如果在主服务器改变了它们。
对于这些参数， 备服务器上的值要大于或等于主服务器上的。
如果这些参数没有设置足够高，那么备服务器将拒绝启动。 
提供了更高的值，重启该服务器再开始恢复。
这些参数是：

max_connections

max_prepared_transactions

max_locks_per_transaction

管理员选择合适的设置为max_standby_archive_delay和max_standby_streaming_delay是很重要的。
根据业务的优先级，最好的选择有所不同。 
例如：如果服务器是主要任务，作为高可用性的服务器，那么你想低延迟设置，也许设置为0，尽管这也是很积极的设置。 
如果备服务器的任务作为决策支持的额外服务器，那么可能接受设置最大延迟为几个小时，或甚至-1意味着永远等待查询完成。

在主服务器上写的事务状态"提示位"没有记录WAL日志，所以在备服务器上将或许再次重写该提示。 
因此，备服务器将仍然进行写磁盘即使所有用户是只读的，数据值自身没有发生改变。
用户将仍然写大量排序的临时文件和 重新生成缓存的信息文件，所以在热备模式数据库没有部分是真只读的。 
还要注意写到远程数据库使用dblink模块，外部数据的操作使用PL函数仍然是可能的，尽管事务是本地只读的。

在恢复模式里，不接受下面类型的管理命令：

数据定义语言(DDL)-如CREATEINDEX

权限和所有权-GRANT,REVOKE, REASSIGN

维护命令-ANALYZE,VACUUM, CLUSTER,REINDEX

再次，请注意在主服务器的“只读”模式事务中，允许这里的某些命令。

作为一个总结，你不能创建额外的索引，统计也不能仅在备服务器， 
如果需要这些管理命令，应该在主服务器执行，并且最终这些变化将传播到备服务器。

pg_cancel_backend()将在用户后台工作，但是不启动进程，其执行恢复。
pg_stat_activity 将不显示为一个启动进程项，也不显示做恢复事务的活动。
作为一个总结，pg_prepared_xacts在恢复中总是空。 
如果你愿解决有疑问准备的事务，在主服务器上查看pg_prepared_xacts和发出命令来解决这里的事务。

pg_locks将显示由后台持有的锁。
pg_locks也显示 由启动进程所管理的虚拟事务，其拥有由恢复正回放的事务所持有的AccessExclusiveLocks。 
请注意该启动进程不需要锁定数据库变化，并且因此非AccessExclusiveLocks其它锁，不会显示在启动进程的pg_locks里。 
它们只是推测存在。

Nagios插件check_pgsql将工作，因为用它检测存在的简单信息。 
check_postgres监控脚本将也工作，尽管有些报告值能给不同或迷惑的结果。 
例如：上次清理时间将不会保持，自在备服务器没有清理发生。
运行在主服务器的清理，将仍然发送它们的 改变到备服务器。

在恢复期间WAL文件控制命令将不工作，比如pg_start_backup，pg_switch_xlog等。

动态加载模块工作，包括pg_stat_statements。

在恢复中咨询锁将工作正常，包括死锁保护。 
请注意咨询锁从不写WAL日志，所以对于一个咨询锁在主服务器上或回放WAL在备服务器上冲突不可能的。 
在主服务器上需要一个咨询锁，在备服务器上已经初始化了一个类似咨询锁也是不可能的。 
咨询锁只是与需要它们的服务器相关。

基于触发器的复制系统像Slony,Londiste和Bucardo将不在备服务器运行， 尽管在主服务器运行的很好，但变化不会发送到备服务器应用。
WAL回放不是基于触发器的，所以你不能从备服务器中继到任何系统，其需要额外的写或 依赖使用触发器。

不能分配新OID，尽管某些UUID生成器可能仍然工作，只要不依靠它们写新状态到数据库。

当前，在只读事务中不允许创建临时表，所以在某些情况下存在的脚本将运行不正确。 
这个限制可能在以后的版本中放宽。
这是一个SQL标准的兼容性和技术问题。

如果表空间是空，DROPTABLESPACE只能成功。
有些备服务器用户可积极的通过temp_tablespaces参数使用 该表空间。
如果在表空间有临时文件，取消所有活动的查询来确保删除临时文件，所以可以删除表空间，可以继续WAL回放。

在主服务器上运行DROPDATABASE或ALTERDATABASE...SET TABLESPACE将产生一个WAL项，
其将导致已连接到在备服务器上的那个数据库的所有用户，强制断开连接。 
这个动作立即发生，不管max_standby_streaming_delay设置。
请注意ALTERDATABASE...RENAME不会断开连接的用户， 在多数情况下忽视，不过如果某些方式依赖数据库名，可能在某些情况下导致一个程序混乱。

在正常（非恢复）模式，如果你发出DROPUSER或DROPROLE对于一个有登录权限的角色，
当那个用户仍然已经连接，那么不会 发生什么对于已连接的用户-他们保持连接。
不过该用户不能再连接。
这个行为在恢复也适用，所以在主服务器上DROPUSER 不能断开备服务器上该用户连接。

在恢复中统计采集器是活动的。
所有扫描，读取，块，索引使用等，将在备服务器中记录。 
回放活动将不复制在主服务器上的影响，因此回放个插入，将不增加插入pg_stat_user_tables列。 
恢复开始删除该统计文件，所以性主备服务器的统计将不同，认为这是个特性，而不是一个臭虫。

在恢复中自动清理是不活动的。在恢复结束将正常启动。

在恢复中后台记录器是活动的，将执行重启点（类似于主服务器上的检查点）和正常块清理活动。
这可能包含 存储在备服务器上的提示信息更新。
在恢复中接受CHECKPOINT命令，尽管执行一个重启点而不是一个新检查点。

====
25.5.4. 热备参数参考

各种参数已经在上面提到Section 25.5.2和Section 25.5.3。

在主服务器上，可以使用参数wal_level和 vacuum_defer_cleanup_age。 
max_standby_archive_delay和max_standby_streaming_delay 如果在主服务器上设置没有影响。

在备服务器,可以使用参数hot_standby， max_standby_archive_delay和 max_standby_streaming_delay。 
只要服务器保留在备模式， vacuum_defer_cleanup_age没有影响，尽管变为相关的，如果备服务器成为主服务器。

====
25.5.5. Caveats

有几个热备限制。这些可能在将来的版本中解决：

在哈希索引的操作，不会记录在目前的WAL日志，索引回放将不更新这些索引。

在做快照之前充分认识运行的事务是必需的。
事务使用大量的子事务（当前大于64）将延迟 只读连接的开始直到运行最长写事务完成。
如果这种情况发生，说明信息将发送到服务器的日志。

对于备服务器查询的有效开始点是产生在主服务器上的每个检查点。
如果备服务器关机，当主服务器在关机状态， 不可能重进热备直到启动主服务器，所以在WAL日志里产生进一步的开始点。
在最常见的情况下这种情况不是一个问题，它可能发生。 
一般地，如果主服务器关机，不再可用，那可能由于一个严重的失败，需要将备服务器转化为新主服务器运行。 
并且有特意取下主服务器的情况，协调确保备服务器成为平滑的主服务器，也是标准的处理。

在恢复结束，由准备的事务持有的AccessExclusiveLocks需要锁表正常数量的条目的两倍。
如果你计划 运行大量并发的准备事务，正常地用AccessExclusiveLocks或你计划一个大事务用多个AccessExclusiveLocks， 
建议你选择一个大的max_locks_per_transaction值,可能为在主服务器上两倍这个参数值。
如果你设置max_prepared_transactions 为0，根本不需要考虑这个。

（本章完）

