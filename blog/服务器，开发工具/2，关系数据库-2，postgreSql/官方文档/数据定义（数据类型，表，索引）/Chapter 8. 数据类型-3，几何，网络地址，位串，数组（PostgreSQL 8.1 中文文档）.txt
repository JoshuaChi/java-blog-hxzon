PostgreSQL 8.1 中文文档-Chapter 8. 数据类型-3，几何，网络地址，位串，数组

8.1. 数值类型
8.1.1. 整数类型
8.1.2. 任意精度数值
8.1.3. 浮点数类型
8.1.4. Serial（序号）类型

8.2. 货币类型
8.3. 字符类型

8.4. 二进制数据类型

8.5. 日期/时间类型
8.5.1. 日期/时间输入
8.5.2. 日期/时间输出
8.5.3. 时区
8.5.4. 内部

8.6. 布尔类型

==
8.7. 几何类型
8.7.1. Point（点）
8.7.2. 线段
8.7.3. Box（方）
8.7.4. Path（路径）
8.7.5. Polygon（多边形）
8.7.6. Circle（圆）

8.8. 网络地址数据类型
8.8.1. inet
8.8.2. cidr
8.8.3. inet 与 cidr 对比
8.8.4. macaddr

8.9. 位串类型

8.10. 数组
8.10.1. 数组类型的声明
8.10.2. 数组值输入
8.10.3. 访问数组
8.10.4. 修改数组
8.10.5. 在数组中检索
8.10.6. 数组输入和输出语法

==
8.11. 复合类型
8.11.1. 声明复合类型
8.11.2. 复合类型值输入
8.11.3. 访问复合类型
8.11.4. 修改复合类型
8.11.5. 复合类型输入和输出语法

8.12. 对象标识符类型

8.13. 伪类型
============
8.7. 几何类型

几何数据类型表示二维的平面物体。 
Table 8-16 显示了PostgreSQL 里面可以用的几何类型。 
最基本的类型：点，是其他类型的基础。

Table 8-16. 几何类型
名字	存储空间	描述	表现形式

point	16 字节	空间中一点	(x,y)
line	32 字节	(无穷)直线（未完全实现）	((x1,y1),(x2,y2))
lseg	32 字节	（有限）线段	((x1,y1),(x2,y2))
box	32 字节	长方形	((x1,y1),(x2,y2))
path	16+16n 字节	闭合路径(与多边形类似)	((x1,y1),...)
path	16+16n 字节	开放路径	[(x1,y1),...]
polygon	40+16n 字节	多边形(与闭合路径相似)	((x1,y1),...)
circle	24 字节	圆(圆心和半径)	<(x,y),r>（圆心与半径）

我们有一系列丰富的函数和操作符可用来进行各种几何计算， 如拉伸，转换，旋转和计算相交等。 
它们在 Section 9.10 里有解释。

====
8.7.1. Point（点）

点是几何类型的基本二维构造单位。 
用下面语法描述 point 的数值：

( x , y )
  x , y

这里的参数是 是用浮点数表示的点的 x 坐标和 y 坐标。

====
8.7.2. 线段

线段 （lseg）是用一对点来代表的。 
lseg 的值用下面语法声明：

( ( x1 , y1 ) , ( x2 , y2 ) )
  ( x1 , y1 ) , ( x2 , y2 )  
    x1 , y1   ,   x2 , y2

这里的 (x1,y1)， (x2,y2) 是线段的端点。

====
8.7.3. Box（方）

方是用一对对角点来表示的。 box 的值用下面语法声明：

( ( x1 , y1 ) , ( x2 , y2 ) )
  ( x1 , y1 ) , ( x2 , y2 )  
    x1 , y1   ,   x2 , y2

这里的 (x1,y1) 和 (x2,y2) 是方形的一对对角点。

方的输出使用第一种语法。
在输入时将按先右上角后左下角的顺序重新排列。 
你也可以输入其他的一对对角点。 
但输入时将先从输入中和存储的角中计算出左下角和右上角然后再存储。

====
8.7.4. Path（路径）

路径由一系列连接的点组成。
路径可能是开放的， 也就是认为列表中第一个点和最后一个点没有连接， 
也可能是闭合的，这时认为第一个和最后一个点连接起来。

path 的数值用下面语法声明：

( ( x1 , y1 ) , ... , ( xn , yn ) )
[ ( x1 , y1 ) , ... , ( xn , yn ) ]
  ( x1 , y1 ) , ... , ( xn , yn )  
  ( x1 , y1   , ... ,   xn , yn )  
    x1 , y1   , ... ,   xn , yn    

这里的点是组成路径的线段的端点。 
方括弧（[]）表明一个开放的路径，圆括弧（()）表明一个闭合的路径。

路径的输出使用第一种语法输出。

====
8.7.5. Polygon（多边形）

多边形由一系列点代表（多边形的顶点）。
多边形可以认为与闭合路径一样， 但是存储方式不一样而且有自己的一套支持过程/函数。

polygon 的数值用下列语法声明：

( ( x1 , y1 ) , ... , ( xn , yn ) )
  ( x1 , y1 ) , ... , ( xn , yn )  
  ( x1 , y1   , ... ,   xn , yn )  
    x1 , y1   , ... ,   xn , yn    

这里的点是组成多边形边界的线段的端点。

多边形输出使用第一种语法。

====
8.7.6. Circle（圆）

圆由一个圆心和一个半径代表。 
circle 的数值用下面语法表示：

< ( x , y ) , r >
( ( x , y ) , r )
  ( x , y ) , r  
    x , y   , r  

这里的 (x,y) 是圆心，而r圆的半径

圆的输出用第一种格式。

==============
8.8. 网络地址数据类型

PostgreSQL 提供用于存储 IPv4，IPv6 和 MAC 地址的数据类型， 在 Table 8-17 里显示。 
用这些数据类型存储网络地址比用纯文本类型好，
因为这些类型提供输入错误检查和好些种特殊的操作和功能。 （见 Section 9.11）。

Table 8-17. 网络地址类型

名字	存储空间	描述

cidr	12 或 24 字节	IPv4 和 IPv6 网络
inet	12 或 24 字节	IPv4 或 IPv6 网络和主机
macaddr	6 字节	MAC 地址

在对 inet 或者 cidr 数据类型进行排序的时候， IPv4 地址将总是排在 IPv6 地址前面，
包括那些封装或者是映射在 IPv6 地址里 的 IPv4 地址，比如 ::10.2.3.4 或者 ::ffff::10.4.3.2。

====
8.8.1. inet

inet 在一个数据域里保存一个主机 IPv4 或 IPv6 地址， 以及一个可选的它所处的等效的子网。 
子网的等效是通过计算主机地址中有多少位表示网络地址的方法来 表示的 （"网络掩码"）。 
如果网络掩码是 32 并且地址是 IPv4 ，那么不表示任何子网，只是一台主机。 
在 IPv6 里，地址长度是 128 位，因此 128 位表明一个唯一的主机地址。 
请注意如果你想只接受网络地址，你应该使用 cidr 类型而不是 inet。

该类型的输入格式是 地址/y 这里 地址 是 IPv4 或者 IPv6 主机，y 是网络掩码的位数。 
如果 /y 部分未填， 则网络掩码对 IPv 而言是 32，对 IPv6 而言是 128， 所以该值表示只有一台主机。 
显示时，如果 /y 部分是 /32，将不会显示出来。

8.8.2. cidr

cidr 保存一个 IPv4 或 IPv6 网络地址声明。 
其输入和输出遵循无类的互联网域路由（Classless Internet Domain Routing）习惯。 
声明一个网络的格式是 地址/y 这里 地址 是 IPv4 或 IPv6 网络地址而 /y 是 网络掩码的二进制位数。 
如果省略 /y， 那么掩码部分用旧的有类的网络编号系统进行计算，
但要求输入的数据已经包括了确定掩码的所需的所有字节。 
如果声明了一个网络地址，它的指定掩码的右边置了位，那么算错误。

Table 8-18是些例子：

Table 8-18. cidr 类型输入举例

cidr 输入	cidr 显示	abbrev(cidr)
192.168.100.128/25	192.168.100.128/25	192.168.100.128/25
192.168/24	192.168.0.0/24	192.168.0/24
192.168/25	192.168.0.0/25	192.168.0.0/25
192.168.1	192.168.1.0/24	192.168.1/24
192.168	192.168.0.0/24	192.168.0/24
128.1	128.1.0.0/16	128.1/16
128	128.0.0.0/16	128.0/16
128.1.2	128.1.2.0/24	128.1.2/24
10.1.2	10.1.2.0/24	10.1.2/24
10.1	10.1.0.0/16	10.1/16
10	10.0.0.0/8	10/8
10.1.2.3/32	10.1.2.3/32	10.1.2.3/32
2001:4f8:3:ba::/64	2001:4f8:3:ba::/64	2001:4f8:3:ba::/64
2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128	2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128	2001:4f8:3:ba:2e0:81ff:fe22:d1f1
::ffff:1.2.3.0/120	::ffff:1.2.3.0/120	::ffff:1.2.3/120
::ffff:1.2.3.0/128	::ffff:1.2.3.0/128	::ffff:1.2.3.0/128

====
8.8.3. inet 与 cidr 对比

inet 和 cidr 类型之间的基本区别是 inet 接受右边有非零位的网络掩码， 而 cidr 不接受。

提示: 如果你不喜欢 inet 或 cidr 值的输出 格式，请试一下 host ，text 和 abbrev 函数。

8.8.4. macaddr

macaddr 类型存储 MAC 地址，也就是以太网卡硬件地址 （尽管 MAC 地址还用于其它用途）。
可以接受多种客户化的格式， 包括

'08002b:010203'
'08002b-010203'
'0800.2b01.0203'
'08-00-2b-01-02-03'
'08:00:2b:01:02:03'

它们声明的都是同一个地址。 
对于数据位 a 到 f，大小写都行。 
输出总是我们上面给出的最后一种形式。
在 PostgreSQL 源代码发布的 contrib/mac 目录里有一些可以将 MAC 地址映射为硬件制造商的名字的工具。

==============
8.9. 位串类型

位串就是一串 1 和 0 的字串。它们可以用于存储和视觉化位掩码。 
我们有两种类型的 SQL 位类型： 
bit(n) 和 bit varying(n); 这里的 n是一个正整数。

bit类型的数据必须准确匹配长度n; 试图存储短些或者长一些的数据都是错误的。
类型 bit varying 数据是最长 n 的变长类型； 更长的串会被拒绝。
写一个没有长度的 bit 等效于 bit(1)，没有长度的bit varying 意思是没有长度限制。

注意: 如果我们明确地把一个位串值转换成 bit(n)， 那么它的右边将被截断或者在右边补齐零，
直到刚好 n 位， 而不会抛出任何错误。
类似地，如果我们明确地把一个位串数值转换成 bit varying(n)，如果它超过了n 位， 那么它的右边将被截断。

注意: 在PostgreSQL7.2 之前，不管是否有明确的转换， bit 都会在右边自动截断或者在在右边填充零的。
这个行为现在已经为了和SQL标准兼容修改过来了。

请参考 Section 4.1.2.3 获取有关位串常量的语法的信息。
还有一些位逻辑操作符和位处理函数可用； 见Section 9.6。

Example 8-3. 使用位串类型

CREATE TABLE test (a bit(3), b bit varying(5));
INSERT INTO test VALUES (B'101', B'00');
INSERT INTO test VALUES (B'10', B'101');
ERROR:  Bit string length 2 does not match type bit(3)
INSERT INTO test VALUES (B'10'::bit(3), B'101');
SELECT * FROM test;
  a  |  b
-----+-----
 101 | 00
 100 | 101

==============
8.10. 数组（hxzon：重要）

PostgreSQL 允许记录的字段定义成定长或不定长的多维数组。 
数组类型可以是任何基本类型或用户定义类型。
（不过，复合类型和域的数组还不支持。）

====
8.10.1. 数组类型的声明

为说明这些用法，我们先创建一个由基本类型数组构成的表：

CREATE TABLE sal_emp (
    name            text,
    pay_by_quarter  integer[],
    schedule        text[][]
);

如上所示，一个数组类型是通过在数组元素类型名后面附加方括弧（[]）来命名的。 
上面的命令将创建一个叫 sal_emp 的表，它的字段中有一个 text 类型字符串（name）， 
一个一维 integer型数组（pay_by_quarter）， 代表雇员的季度薪水和一个两维 text 类型数组（schedule）， 表示雇员的周计划。

CREATE TABLE 的语法允许声明数组的确切大小，比如：

CREATE TABLE tictactoe (
    squares   integer[3][3]
);

不过，目前的实现并不强制数组尺寸限制 — 其行为和用于未声明长度的 数组相同。

实际上，目前的声明也不强制数组维数。
特定元素类型的数组都被认为是相同的类型， 不管他们的大小或者维数。
因此，在 CREATE TABLE 里定义数字或者维数都只是简单的文档，它并不影响运行时的行为。

另外还有一种语法，它遵循 SQL 标准，可以用于声明一维数组。 
pay_by_quarter 可以定义为：

    pay_by_quarter  integer ARRAY[4],

这个语法要求一个整数常量表示数组尺寸。
不过，和以前一样，PostgreSQL 并不强制这个尺寸限制。

====
8.10.2. 数组值输入

把一个数组数值写成一个文本值的时候， 我们用花括弧把数值括起来并且用逗号将它们分开。 
（如果你懂 C，那么这与初始化一个结构很像。） 
你可以在任何数组值周围放置双引号，如果这个值包含逗号或者花括弧， 那么你就必须加上双引号。
（下面有更多细节。）
因此，一个数组常量的常见格式如下：

'{ val1 delim val2 delim ... }'

这里的 delim 是该类型的分隔符， 就是那个在它的 pg_type 记录里指定的那个。 
在 PostgreSQL 发布提供的标准数据类型里， 类型 box 使用分号（;），但是所有其它类型都用逗号（,）。 
每个 val 要么是一个数组元素类型的常量，要么是一个子数组。一个数组常量的例子是

'{{1,2,3},{4,5,6},{7,8,9}}'

这个常量是一个两维的，3乘3的数组，由三个整数子数组组成。

（这种数组常量实际上只是我们在 Section 4.1.2.5 里讨论过的一般类型常量的一种特例。
常量最初是当作字串看待并且传递给数组输入转换过程。
可能需要我们用明确的类型声明。）

现在我们可以显示一些 INSERT 语句。

INSERT INTO sal_emp
    VALUES ('Bill',
    '{10000, 10000, 10000, 10000}',
    '{{"meeting", "lunch"}, {"meeting"}}');

ERROR:  multidimensional arrays must have array expressions with matching dimensions
请注意多维数组必须匹配每个维的元素数。
如果不匹配则导致错误发生。

INSERT INTO sal_emp
    VALUES ('Bill',
    '{10000, 10000, 10000, 10000}',
    '{{"meeting", "lunch"}, {"training", "presentation"}}');

INSERT INTO sal_emp
    VALUES ('Carol',
    '{20000, 25000, 25000, 25000}',
    '{{"breakfast", "consulting"}, {"meeting", "lunch"}}');

目前的数组实现的一个局限是一个数组的独立元素不能是 SQL 空值。 
整个数组可以设置为空，但是你不能有这么一个数组，里面有些元素是空， 而有些不是。
（这一点将来可能改变。）

前面的两个插入的结果看起来像这样：

SELECT * FROM sal_emp;
 name  |      pay_by_quarter       |                 schedule
-------+---------------------------+-------------------------------------------
 Bill  | {10000,10000,10000,10000} | {{meeting,lunch},{training,presentation}}
 Carol | {20000,25000,25000,25000} | {{breakfast,consulting},{meeting,lunch}}
(2 rows)

我们还可以使用 ARRAY 构造器语法：

INSERT INTO sal_emp
    VALUES ('Bill',
    ARRAY[10000, 10000, 10000, 10000],
    ARRAY[['meeting', 'lunch'], ['training', 'presentation']]);

INSERT INTO sal_emp
    VALUES ('Carol',
    ARRAY[20000, 25000, 25000, 25000],
    ARRAY[['breakfast', 'consulting'], ['meeting', 'lunch']]);

请注意数组元素是普通的 SQL 常量或者表达式；
比如，字串文本是用单引号包围的， 而不是像数组文本那样用双引号。
ARRAY 构造器语法在 Section 4.2.10 里有更详细的讨论。

====
8.10.3. 访问数组

现在我们可以在这个表上运行一些查询。 
首先，我们演示如何一次访问数组的一个元素。 
这个查询检索在第二季度薪水变化的雇员名：

SELECT name FROM sal_emp WHERE pay_by_quarter[1] <> pay_by_quarter[2];

 name
-------
 Carol
(1 row)

数组的脚标数字是写在方括弧内的。 
PostgreSQL 缺省使用以一为基的数组习惯， 也就是说，一个 n 元素的数组从array[1]开始， 到 array[n] 结束。

这个查询检索所有雇员第三季度的薪水：

SELECT pay_by_quarter[3] FROM sal_emp;

 pay_by_quarter
----------------
          10000
          25000
(2 rows)

我们还可以访问一个数组的任意长方形片断，或称子数组。 
对于一维或更多维数组，一个数组的某一部分是用 脚标下界： 脚标上界 表示的。 
比如，下面查询检索 Bill 该周头两天的第一件计划。

SELECT schedule[1:2][1:1] FROM sal_emp WHERE name = 'Bill';

        schedule
------------------------
 {{meeting},{training}}
(1 row)

我们还可以这样写

SELECT schedule[1:2][1] FROM sal_emp WHERE name = 'Bill';

获取同样的结果。
如果任何脚标写成 lower： upper 的形式，那么任何数组脚标操作总是当做一个数组片断对待。 
如果只声明了一个数值，那么都是假设下界为 1，比如：

SELECT schedule[1:2][2] FROM sal_emp WHERE name = 'Bill';

                 schedule
-------------------------------------------
 {{meeting,lunch},{training,presentation}}
(1 row)

从一个数组的当前范围之外抓取数据生成一个 SQL 空值，而不是导致错误。 
比如，如果 schedule 目前的维是 [1:3][1:2]， 然后我们抓取 schedule[3][3] 会生成 NULL。
类似的还有， 一个下标错误的数组引用生成空，而不是错误。
还有就是抓取一个完全在数组的当前范围之外的数组片断， 也是生成一个空值数组；
但是如果要求的片断部分覆盖数组的范围，那么它会自动缩减为抓取覆盖的范围。

任何数组的当前维数都可以用 array_dims 函数检索：

SELECT array_dims(schedule) FROM sal_emp WHERE name = 'Carol';

 array_dims
------------
 [1:2][1:1]
(1 row)

array_dims 生成一个 text 结果， 对于人类可能比较容易阅读，但是对于程序可能就不那么方便了。 
我们也可以用 array_upper 和 array_lower 函数检索，它们分别返回指定数组维的上界和下界。

SELECT array_upper(schedule, 1) FROM sal_emp WHERE name = 'Carol';

 array_upper
-------------
           2
(1 row)

====
8.10.4. 修改数组

一个数组值可以完全被代替：

UPDATE sal_emp SET pay_by_quarter = '{25000,25000,27000,27000}'
    WHERE name = 'Carol';

或者使用 ARRAY 表达式语法：

UPDATE sal_emp SET pay_by_quarter = ARRAY[25000,25000,27000,27000]
    WHERE name = 'Carol';

或者只是更新某一个元素：

UPDATE sal_emp SET pay_by_quarter[4] = 15000
    WHERE name = 'Bill';

或者更新某个片断：

UPDATE sal_emp SET pay_by_quarter[1:2] = '{27000,27000}'
    WHERE name = 'Carol';

我们可以通过给一个和已存在的元素相邻元素赋值的方法， 或者是向已存在的数据相邻或重叠的区域赋值的方法来扩大一个数组。 
比如，如果一个数组 myarray 当前有 4 个元素，那么如果我们给 myarray[5] 赋值后，它就有五个元素。
目前，这样的扩大只允许多一维数组进行， 不能对多维数组进行操作。

数组片段赋值允许创建不使用一为基的下标的数组。 
比如，我们可以给 array[-2:7] 赋值， 创建一个脚标值在 -2 和 7 之间的数组。

新的数组值也可以用连接操作符 || 构造。

SELECT ARRAY[1,2] || ARRAY[3,4];
 ?column?
-----------
 {1,2,3,4}
(1 row)

SELECT ARRAY[5,6] || ARRAY[[1,2],[3,4]];
      ?column?
---------------------
 {{5,6},{1,2},{3,4}}
(1 row)

连接操作符允许把一个元素压入一个一维数组的开头或者结尾。
它还接受两个 N 维的数组，或者一个 N 维和一个 N+1 维的数组。

在向一个一维数组的开头压入一个元素后，结果是这样的一个数组： 
它的低界下标等于右手边操作数的低界下标减一，如果向一个一维数组的结尾压入一个元素， 
结果数组就是一个保持左手边操作数低界的数组。比如：

SELECT array_dims(1 || ARRAY[2,3]);
 array_dims
------------
 [0:2]
(1 row)

SELECT array_dims(ARRAY[1,2] || 3);
 array_dims
------------
 [1:3]
(1 row)

如果两个相同维数的数组连接在一起，结果保持左手边操作数的外层维数的低界下标。 
结果是这样一个数组：它包含左手边操作数的每个元素，后面跟着右手边操作数的每个元素。比如：

SELECT array_dims(ARRAY[1,2] || ARRAY[3,4,5]);
 array_dims
------------
 [1:5]
(1 row)

SELECT array_dims(ARRAY[[1,2],[3,4]] || ARRAY[[5,6],[7,8],[9,0]]);
 array_dims
------------
 [1:5][1:2]
(1 row)

如果一个 N 维的数组压到一个 N+1 维数组的开头或者结尾， 结果和上面的数组元素的情况类似。
每个 N 维的子数组实际上都是 N+1 维数组的外层维数。比如：

SELECT array_dims(ARRAY[1,2] || ARRAY[[3,4],[5,6]]);
 array_dims
------------
 [0:2][1:2]
(1 row)

数组也可以用函数 array_prepend， 和 array_append， 以及 array_cat 构造。
头两个只支持一维数组， 而 array_cat 支持多维数组。 
请注意使用上面讨论的连接操作符要比直接使用这些函数好。
实际上， 这些函数主要用于实现连接操作符。
不过，在用户定义的创建函数里直接使用他们可能有必要。一些例子：

SELECT array_prepend(1, ARRAY[2,3]);
 array_prepend
---------------
 {1,2,3}
(1 row)

SELECT array_append(ARRAY[1,2], 3);
 array_append
--------------
 {1,2,3}
(1 row)

SELECT array_cat(ARRAY[1,2], ARRAY[3,4]);
 array_cat
-----------
 {1,2,3,4}
(1 row)

SELECT array_cat(ARRAY[[1,2],[3,4]], ARRAY[5,6]);
      array_cat
---------------------
 {{1,2},{3,4},{5,6}}
(1 row)

SELECT array_cat(ARRAY[5,6], ARRAY[[1,2],[3,4]]);
      array_cat
---------------------
 {{5,6},{1,2},{3,4}}

====
8.10.5. 在数组中检索

要搜索一个数组中的数值，你必须检查该数组的每一个值。 
你可以手工处理（如果你知道数组尺寸）。比如：

SELECT * FROM sal_emp WHERE pay_by_quarter[1] = 10000 OR
                            pay_by_quarter[2] = 10000 OR
                            pay_by_quarter[3] = 10000 OR
                            pay_by_quarter[4] = 10000;

不过，对于大数组而言，这个方法很快就会让人觉得无聊，并且如果你不知道数组尺寸，那就没什么用了。 
另外一个方法在 Section 9.17 里描述。 
上面的查询可以用下面的代替：

SELECT * FROM sal_emp WHERE 10000 = ANY (pay_by_quarter);

另外，你可以用下面的语句找出所有数组有值等于 10000 的行：

SELECT * FROM sal_emp WHERE 10000 = ALL (pay_by_quarter);

提示: 数组不是集合；象我们前面那些段落里描述的那样使用数组通常表明你的库设计有问题。 
数组字段通常是可以分裂成独立的表。 
很明显表要容易搜索得多。并且在元素数目非常庞大的时候也可以更好地伸展。

====
8.10.6. 数组输入和输出语法

一个数组值的外部表现形式由一些根据该数组元素类型的 I/O 转换规则分析的项组成， 再加上一些标明该数组结构的修饰。 
这些修饰由围绕在数组值周围的花括弧（{ 和 }）， 加上相邻项之间的分隔字符组成。
分隔字符通常是一个逗号（,）， 但也可以是其它的东西：它由该数组元素类型的 typdelim 设置决定。 
（在 PostgreSQL 版本提供的标准数据类型里， 类型 box 使用分号（;），但所有其它的类型使用逗号。） 
在多维数组里，每个维（行，面，体，等）有自己级别的花括弧，并且在同级相邻的花括弧项之间必须写分隔符。

如果数组元素值是空字串或者包含花括弧，分隔符，双引号，反斜杠或者空白， 那么数组输出过程将在这些值周围包围双引号。
在元素值里包含的双引号和反斜杠将被反斜杠逃逸。 
对于数值数据类型，你可以安全地假设数值没有双引号包围，
但是对于文本类型，我们就需要准备好面对有双引号包围， 和没有双引号包围两种情况了。
（这是对 7.2 以前的 PostgreSQL 版本的行为的一个改变。）

缺省时，一个数组的某维的下标索引是设置为一的。
如果一个数组的某维的下标不等于一， 那么就会在数组结构修饰域里面放置一个实际的维数。
这个修饰由方括弧（[]） 围绕在每个数组维的下界和上界索引，中间有一个冒号（:）分隔的字串组成。 
数组维数修饰后面跟着一个等号操作符（=）。比如：

SELECT 1 || ARRAY[2,3] AS array;

     array
---------------
 [0:2]={1,2,3}
(1 row)

SELECT ARRAY[1,2] || ARRAY[[3,4]] AS array;

          array
--------------------------
 [0:1][1:2]={{1,2},{3,4}}
(1 row)

这个语法也可以用于在一个数组文本中声明非缺省数组脚标。比如：

SELECT f1[1][-2][3] AS e1, f1[1][-1][5] AS e2
 FROM (SELECT '[1:1][-2:-1][3:5]={{{1,2,3},{4,5,6}}}'::int[] AS f1) AS ss;

 e1 | e2
----+----
  1 |  6
(1 row)

如上所述，在书写一个数组的数值的时候你要用双引号包围任意独立的数组元素。 
如果元素数值可能令数组数值分析器产生歧义，那么你必须这么做。 
比如，那些包含花括弧，逗号（或者任何其它的分隔字符）， 双引号，反斜杠，或者前导的空白元素都必须加双引号。 
要把双引号或者反斜杠放到数组元素值里，给它们加一个反斜杠前缀。 
另外，你可以用反斜杠逃逸的方法保护所有那些可能被当做数组语法的字符。

你可以在左花括弧前面或者右花括弧后面写空白。
你还可以在任意独立的项字串前面或者后面写空白。 
所有这些情况下，这些空白都会被忽略。
不过，在双引号包围的元素里面的空白，或者是元素里被两边非空白字符包围的空白，都不会被忽略。

注意: 请记住你在 SQL 命令里写的任何东西都将首先解释成一个字串文本， 然后才是一个数组。
这样就造成你所需要的反斜杠数量翻了翻。 
比如，要插入一个包含反斜杠和双引号的 text 数组， 你需要这么写

INSERT ... VALUES ('{"\\\\","\\""}');

字串文本处理器去掉第一层反斜杠，然后省下的东西到了数组数值分析器的时候看起来象 {"\\","\""}。 
接着，该字串传递给 text 数据类型的输入过程，分别变成 \ 和 "。 
（如果我们用的数据类型对反斜杠也有特殊待遇，比如 bytea， 
那么我们可能需要在命令里放多达八个反斜杠才能在存储态的数组元素中得到一个反斜杠。） 
我们也可以用美元符包围（参阅 Section 4.1.2.2）来避免双份的反斜杠。

提示: ARRAY 构造器语法（参阅 Section 4.2.10）通常比数组文本语法好用些，尤其是在 SQL 命令里写数组值的时候。 
在 ARRAY 里，独立的元素值的写法和数组里没有元素时的写法一样。

