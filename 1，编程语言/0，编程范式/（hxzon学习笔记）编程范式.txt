（hxzon学习笔记）编程范式

========
面向过程

========
面向对象
《王垠-为什么说面向对象编程和函数式编程都有问题》：
有些东西不是对象。函数就不是对象。

========
面向切面

hxzon：面向对象编程所导致的解决方案？

========
函数式

《王垠-为什么说面向对象编程和函数式编程都有问题》：
有些东西不是纯的。副作用是真实存在的。

《王垠-“One语言”是不存在的》：
函数的结构组合能力却不是万能的。
函数接受一些参数，返回一个结果。
然而有些我们需要表达的概念却不是这样的结构，
比如一个带有多根电线的黑匣子，它可以从任何电线输入东西，然后从剩下的电线输出。
每根电线的输入和输出方式，在不同的“调用”可以随意的更改。

比如对于逻辑语言的黑匣子，当我们在调用它的时候，宏就会知道它的输入和输出的“方向”。
一旦知道了这个方向，它的行为方式就会像一个函数，所以我们就可以以此把它编译成函数。
在下一个调用的地方，输入输出的方向又有不同，所以就把它编译成另外一个函数。

========
逻辑编程

========
模板编程（C++）
类似java中的泛型编程。

========
声明式编程

《程序的本质复杂性和元语言抽象》

========
reactive programming （响应式编程）

hxzon理解：
构造“事件流”，监听事件并执行操作。
事件流可被过滤，转换，组合等。

==
《函数式反应型编程(FRP) —— 实时互动应用开发的新思路》：

那些“对外部环境具有反应能力、随时间变化”的“数据”被抽象为一种叫“信号”(Signal)的概念。
信号分为两种，分别叫事件流(Event Stream)和行为(Behavior)。

behavior可以看成这样一个函数：
输入某个时刻，它计算得到“在那个时刻自身的采样值”。

event stream也可以看成这样一个函数：
输入也是某个时刻，如果在这个时刻有事件发生就把相应的 event 数据返回出来，
否则就返回一个特殊的nothing表示没有任何事件发生。

回调与回调之间是无法直接传递类型丰富的数据的，
它们只能通过“修改应用程序的共享状态”来“间接地通讯”，（hxzon：重要）
这迫使程序员不得不把应用逻辑分割得支离破碎，从而丧失了核心的组合能力！
这便是callback风格程序的最大问题。

Callback模型关注控制流，但它对控制流的描述不具有很好的组合性。
FRP模型换了一个视角，关注数据流，且数据流的组合能力极佳，
使得代码更接近于只描述做什么(what)的声明式(declarative)代码，
而不是描述怎么做(how)的命令式(imperative)代码，相当简洁和直观，更符合人的自然思维!

========
actor

========
异步


========
非确定性计算

(amb e1 e2 e3 ...)
上述表达式的返回值可能是e1，e2，e3... 中的某一个。
(amb) 表示“失败”。

一个amb表示一个选择点。
非确定性求值器在遇到失败时，会自动尝试下一个返回值，
当前选择点可能的返回值用尽时，会退到上一个选择点。

========
continuation （续延）

----
什么是scheme continuation?

(+ 1 (call/cc
       (lambda (k)
         (+ 2 (k 3)))))

the rest of the program, from the point of view of the call/cc-application, 
is the following program-with-a-hole (with [] representing the hole):

(+ 1 [])

In other words, this continuation is a program 
that will add 1 to whatever is used to fill its hole.

上面这段英文是说，从call/cc开始的剩下的代码，也就是(+ 1 [])，"[]"就代表了一个位置，
而continuation k就代表了(+ 1 []) ，
其实 k 就是个保存了加1运算的全局变量，只要你以后绑定k的值，
比如(k 100) ，那么就会把100放在[]处，然后继续加1运算。

----
假设我们调试一个很简单的lisp表达式：

(+ x (* y z)) 

如果现在计算子表达式(* y z)，这个时候程序的continuation表示为lambda表达式，可以简化的写为：

(lambda (v) (+ x v)) 

一边是当前子表达式(* y z)，
另一边所谓延续就是等待子表达式结果的一个函数，
这个函数将完成剩下的全部计算，得到整个表达式的最终值。 

在scheme中，可以用call/cc在程序中获得当前的continuation。

把上面那个表达式写成这样： 

(+ x (call/cc (lambda (k) (k (* y z))))) 	;hxzon：将 (* y z) 绑定到 k ，并且立即返回 k 。

执行结果是一样的，那个k参数就代表获得的continuation。

(* y z)的求值结果通过v传递给continuation。

========
CSP（Continuation Passing Style，续延传递风格）

正常函数的返回都隐含一个continuation，就是利用这个函数的返回值来做的后续事情，
而cps的本质就是将这个隐式的continuation显式的当做参数传递进去，
并在函数中完成应有的continuation并将最终结果返回。

这跟尾递归似乎很像，在改造递归为尾递归的时候，
就将当前状态通过accumulator汇集到函数内部的操作，
当达到结束条件时返回汇集结果，而不必再返回来收集递归过程中的返回值。

cps似乎就是同样的道理，每次将continuation传递到内部进行操作的组合，
当达到底部的时候直接将汇集的continuation的计算结果返回，而不必返回来再去计算每一步的continuation。

========
python yield

一个带有 yield 的函数就是一个 generator，它和普通函数不同，生成一个 generator 看起来像函数调用，
但不会执行任何函数代码，直到对其调用 next()（在 for 循环中会自动调用 next()）才开始执行。

虽然执行流程仍按函数的流程执行，但每执行到一个 yield 语句就会中断，并返回一个迭代值，
下次执行时从 yield 的下一个语句继续执行。
看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。

=======
monad

《王垠-为什么说面向对象编程和函数式编程都有问题》：
有些人认为monads的价值在于，它们“圈定”了副作用的范围。
但如果monads不能真正的使程序变得易于分析或更安全，这种“圈定”有什么用呢？
事实上就是没用处。
本身就跟副作用一样难于分析理解。

