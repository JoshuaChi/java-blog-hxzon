论面向组合子程序设计方法（一、二）

论面向组合子程序设计方法 之一 创世纪

http://www.blogjava.net/ajoo/articles/27838.html

新开张。先炒些冷饭过来。狡兔三窟，万一哪天javaeye倒台了（robbin气的脸都青了），我辛辛苦苦码的字就丢了，就象当年在allaboutprogram的遭遇一样，哭都找不到庙门。




发现老庄的连载方法很好.又能吸引眼球又能好整以暇.于是从善如流. 


这几天在完善我的neptune系统和jaskell语言。顺手发现了一个logging的需求。如获至宝阿。 

为什么呢？不是因为这个需求多么难，或者我的解决方法多么巧妙，而是因为，这个例子足够简单，直观，要说明它，背景知识几乎不大需要，三两句话大家就明白需要达到什么效果。这种例子可不是随便就想得到的。 

而同时，它又对实现提出了一定程度的灵活性要求，正好方便我展示我叫做“面向组合子”的程序设计方法。 


说到这里，不禁又有点沮丧，我也挺想象别人那样，先高举高打，玄之又玄，弄些哲学思辨，什么佛法呀，道德经阿，西游记亚，以及各位西方先哲的亟语，甚至量子力学的悖论。这样才能吸引眼球，增加人气呀。 
可是，等而下之的工匠气作祟，说着说着就要拐到具体例子上去了。不争气呀。 


算了，不想那么多了。论道不是俺这种俗人所擅长的，还是鼓捣“器”吧。 


大致的背景是这样： 
我的neptune是一个build system，在build的过程中会产生很多log信息。这些信息分为不同的重要级别。 

说到这里，肯定有人已经按奈不住：用Log4j！ 

先不要急，我们这里不是要告诉你怎么处理你得程序中的logging需求，而是要通过这样一个容易理解的例子来说明以下“面向组合子”的编程方法。所以，这里让我们先假设我们不知道什么log4j。什么是log4j呀？ 

当然，大致的思路总归差不多的。因为我的neptune系统只需要一个logging的工具，而不关心这个logging工具是什么，这就是一个perfect的依赖注射的场合。 

先定义接口Logger，然后从构造函数传递近来一个Logger实例，接着就直接调用Logger就是了。 

java代码: 

public interface Logger{ 
  void print(int level, String msg); 
  void println(int level, String msg); 
  void logException(Throwable e); 
} 



print用来输出信息，但是不折行，println可以折行。 
logException用来直接纪录异常。这样，对异常是直接printStackTrace，还是println(e.getMessage())就是由具体的Logger实现来决定，我的neptune只需要把遇到的异常报告给Logger就是了。 


好。接下来我吭哧吭哧地把neptune完成了，剩下的就是从哪里找一个Logger实现了。 

最简单的Logger实现自然就是直接往屏幕上打印了： 

java代码: 

class SimpleLogger implements Logger{ 
  public void print(int lvl, String msg){ 
    System.out.print(msg); 
  } 
  public void println(int lvl, String msg){ 
    System.out.println(msg); 
  } 
  public void printException(Throwable e){ 
    e.printStackTrace(); 
  } 
} 




直接把这个SimpleLogger注射进我的neptune，整个系统就可以工作了。 
no big deal，对么？ 


好了，下面我们开始真正实现完整的logging系统了。经过分析，我们大致有以下的需要： 

1。logger可以把信息打印到log文件中。 

2。不同的重要程度的信息也许可以打印到不同的文件中？象websphere，有error.log, info.log等。 
如果这样，那么什么重要程度的信息进入error.log，什么进入warning.log，什么进入info.log也需要决定。 

3。也许可以象ant一样把所有的信息都打印到一个文件中。 

4。每条logging信息是否要同时打印当前的系统时间？也是一个需要抉择的问题。 

5。不仅仅是log文件，我们还希望能够在标准错误输出上直接看见错误，普通的信息可以打印到log文件中，对错误信息，我们希望log文件和标准输出上都有。

6。标准输出上的东西只要通知我们出错了就行，大概不需要详细的stack trace，所以exception stack trace可以打印到文件中，而屏幕上有个简短的exception的message就够了。 

7。warning似乎也应该输出到屏幕上。 

8。不管文件里面是否要打印当前系统时间，屏幕上应该可以选择不要打印时间。 

9。客户应该可以通过命令行来决定log文件的名字。 

10。客户可以通过命令行来决定log的细节程度，比如，我们只关心info一样级别的信息，至于debug, verbose的信息，对不起，不要打印。 

11。neptune生成的是一些Command对象，这些对象运行的时候如果出现exception，这些exception会带有execution trace，这个execution trace可以告诉我们每个调用栈上的Command对象在原始的neptune文件中的位置（行号）。 
这种exception叫做NeptuneException，它有一个printExecutionTrace(PrintWriter)的方法来打印execution trace。 
所以，对应NeptuneException，我们就不仅仅是printStackTrace()了，而是要在printStackTrace()之前调用printExecutionTrace()。 


12。neptune使用的是jaskell语言，如果jaskell脚本运行失败，一个EvaluationException会被抛出，这个 类有一个printEvaluationTrace(PrintWriter)的方法来打印evaluation trace，这个trace用来告诉我们每个jaskell的表达式在脚本文件中的位置。 
所以，对应EvaluationException，我们要在printStackTrace()之前，调用printEvaluationTrace()。 

13。execution trace和evaluation trace应该被打印到屏幕上和log文件两个地方。 

14。因为printExecutionTrace()和printEvaluationTrace()本身已经打印了这个异常的getMessage()，所以，对这两种异常，我们就不再象对待其它种类的异常那样在屏幕上打印getMessage()了，以免重复。 

15。也许还有一些暂时没有想到的需求， 比如不是写入log文件，而是画个图之类的变态要求。


大致上，我目前遇到的需求也就是这些了。 

好了，允许我卖个关子，下回分解的时候再说怎么用“面向组合子”和依赖注射的方法来解决这个问题吧。 

在本节结束之前，我稍微提一下“面向组合子”的来历。 


组合子，英文叫combinator，是函数式编程里面的重要思想。如果说OO是归纳法（分析归纳需求，然后根据需求分解问题，解决问题），那么 “面向组合子”就是“演绎法”。通过定义最基本的原子操作，定义基本的组合规则，然后把这些原子以各种方法组合起来。我最近一段时间做的东西， jaskell不用说了，函数式语言。yan, neptune, jparsec全是用面向组合子的思想开发的。 

OO就像是猜谜，给你一个苹果，然后问你：这个苹果是怎么得到的呢？然后你分析一番，说：我认为这个苹果是由分子组成的，这些分子如此这般排列，然后分子又由原子组成，如此这般排列... 

而CO（面向组合子），就等于是说：这有H, C, O三种原子，强弱两种作用力，你来看看能做点什么出来吧，然后你就像搭积木一样，把这三种原子，两种作用力搭建出这大千世界，什么毛毛虫，狗熊，周星星，不小心，一下就做出了一个苹果。 

OO的关键是需求。 
所谓"refactor"，不过也是强调需求，让你不要自作聪明地瞎假设需求而复杂化设计。时刻着眼于当前的需求。这样，一旦需求变更，所浪费的力气可以保证最小，而且，船小才好调头嘛。 
如果需求分析的不好，一切就歇菜了，虽然因为一些比如ioc之类的设计方法能让你不至于推到重来，但是需求仍然是重中之重。 


那些什么上下文没有，上来就说“怎么用OO来做一个人骑车呀？”，“是人.骑(车)呀？还是车.被骑(人)？”纯粹是没头没脑地瞎掰。 

而CO的关键则是组合子和组合规则的设计。这些组合方法必须非常精巧，尽量正交。组合子的设计既要简单（越简单才越容易被组合），还要完整。 
比如说，对整数这个组合子，我们有+-*等组合方法，这样只要有了0,1这两个组合子，我们就可以构造出整个整数世界。 
可是，精巧的组合子设计也不是那么容易的。需要有一点点数学的感觉和严密的逻辑思维基础。 


有人说，上帝是用OO设计的世界，可要我是上帝，我宁可用CO。 
设计几个简单的基本粒子，几个简单的相互作用力，然后让这些东西自己组合，随意发展，不是比事必躬亲，先想透彻了自己想让世界是什么样子，然后一张一张图纸地具体设计，一个一个人地造， 
“撒旦，你去干坏事，往死了整这帮贱人！” 
“天使，你去干好事，打个巴掌再给他们点甜枣吃。” 
“儿子，你下去混混，看丫敢不敢钉死你！” 
来的容易美妙？ 

OO的世界观是一个决定性的机械世界观。你想让世界是什么样子就要从头一点一点朝这个方向凑。设计者是全知全能的犹太教上帝耶和华。
而CO的世界观是非确定性的。我自己设计出一套组合子和组合规则，然后具体这些东西会组合出什么怪物来我肚子里也没谱。就象James Gosling，他设计出了Java语言，但是他也没办法预测Java语言都能干些什么。这是一个希腊宙斯式的，或者中国盘古式的创世纪。世界创造出来 了。怎么演化？我死后哪管它洪水滔天。



哈。终于形而上起来了，爽！
发表于 2006-01-13 05:17 AJOO

论面向组合子程序设计方法 之二 失乐园

http://www.blogjava.net/ajoo/articles/27839.html

前面我们讲到一些OO和CO的区别。肯定有人不以为然。什么CO？OO包罗万象，你所谓的CO也不过是OO的一个分支而已。 


是啊，易经也包罗万象，也许太极图或者伏羲六十四卦早就可以描述蒸汽机，喷气战斗机，计算机，烤火鸡，等等，更何况什么OO，CO呢？ 

其实，如果把OO当作一个大箩筐，什么都往里装，自然，我这里要说的也不会跳出它的藩篱。毕竟我这CO还是用java实现的呢，归根结底，不是还要用class, interface之类的东西乱搞？ 

而我所谈的OO，和老庄不同，不是那么一个宽泛的概念。实际上，我说的OO包括两个阶段。 

第一个阶段： 
1。认识到数据和行为的统一性。用类来封装数据，隐藏数据，并且对行为建模。这种更高级的ADT应该是OO的最基本形态。 
2。用类继承的方式来渐进式地描述现实生活中的概念。对概念之间的差别用子类覆盖父类某一个方法的途径来表达。


在这个阶段，传统的“封装，继承，多态”就已经被提了出来。 

这种看上去很美的非常符合人的直觉的方法被人们很快地接受了。 

毕竟，Person, Vehicle, Animal等等做成类是多么直白，vehicle.start(), person.work(), animal.eat()看上去是多么简单。 
人们象吃了善恶果一样发现眼睛似乎一下子明亮了，世界看上去竟然那么分明。靠，老子怎么没早知道有这个果子？还有没有？再给两个！ 

但是，真正应用到变化莫测的现实世界，人们逐渐发现这个方法不象它看上去那么简单。多重继承的困扰，父子类之间的强烈的耦合都造成了巨大的麻烦。 
我们经常发现，或者父类提供了很多东西，可我根本不需要。或者我想要某个东西，可是父类偏偏没有设想到这个可能，没有提供，而父类自作聪明预先设计好的某个设施，不但没用，反而给子类造成麻烦。 

于是，四人帮们振臂高呼：不要以为OO就是随意设计你自己的类。你要遵守一定的模式！ 

于是，二十几片树叶被精心编织成一块遮羞布遮在OO的私处上，我们真的知道了“善恶”。一个完善的OO道德体系被圣人们建立了起来。 


第二个阶段： 
模式真的解放了我们吗？还是我们更糊涂了？曾几何时，我们开始痛恨singleton，鄙视template method，害怕visitor。 
是时候该反思一下了。我们真的需要“继承”吗？“重载”真的很好吗？ 

理论界早就在研究subtype和subclass的区别，我们发现，似乎有必要区分这两个概念，subtype不见得就必须subclass，甚至，连subclass也不一定就非得subtype。 

c++阵营里出现了gp的声音。大有一举将OO这个老朽打翻在地的气势。模板！到处是模板。我们用模板组合模板，代替了传统的继承，一些人甚至做出了一些相当技巧性的东西。 

java跳了出来，坚定地把subtype和subclass分开。于是，我们有了interface。 

所谓interface，理论上就是一个type。它和class不同，type/interface只定义方法的签名，但是不包含具体数据和实现，它只表示：给你这个类型的对象后，你能用它来做什么。它不包含：这个类型的对象具体是怎么做某一件事的。 

这样，class代表实现，interface代表规范。"implements"代表subtype，"extends"是subclass同时也是subtype。 
subtype和subclass被初步地分开了。我们不再仅仅有几片树叶来遮挡私出，现在我们还有了bra。 

“继承”的作用被弱化，甚至被反对。要求用接口组合来代替继承的呼声日高。确实仍然有用继承和template method比较方便的场合，但是这不再对系统的整体架构产生影响。“继承”更多地被用作一种局部的实现手段，它影响的不再是整个系统骨架，而是三两个本 身就紧密耦合的类。 

interface的出现在OO内部是一个决定性的事件——如果不是一个革命的话。 


它进一步完善了OO的“职责分派”体系。功能的“消费者”和“提供者”可以被明确地区分。 

消费者只看见接口，而看不见类，这样，留下了一块切换不同“提供者”的空间。 

OO的整体哲学甚至被上升了一个高度：我们不再执著于用树形结构，渐进式地描述世界，因为我们认识到这不大可行，世界比我们想象的要复杂得多。 

OO在这个阶段被重新诠释为：一个责任分工体系。 
遇到一个问题，我们通过分析需求，把它分解成互相协作的子模块。每个子模块有精确定义的职责。子模块之间通过精心设计的接口来互相通信，在保证最小耦合的基础上实现了分工合作。 

所谓ioc就是这样的思想的一种表达。子模块需要一个外部提供的功能时，不是直接去找到某个具体实现模块，而是通过接口把协议公开出去。这和上帝 他老人家的设计有点形似了：夏娃需要生儿子，但是虽然暂时旁边只有一个adam gg，但是夏娃的身体构造却不是仅仅为adam设计的，上帝他老人家给夏娃的是一个跟任何男人都能生儿子的通用接口。 
女人这个模块的职责被定义为：跟男人（们）生孩子。 
男人这个模块的职责被定义为：跟女人（们）生孩子。 


在这种思路成为系统的主导思想的时候，子模块的组装成为了一个问题。谁负责把鸡犬相闻（只看见接口），老死不相往来（看不见类）的子模块最终组合在一起呢？当只有adam夏娃的时候，上帝一努嘴，俩人就睡一起了。但是当天下呼呼嚷嚷都是男人女人的时候，这就不够效率了。 
于是，月下老人就开了一个ioc容器，来负责把这些用ioc方式设计的组件们用一种最经济的方式拉到一起。 



但是，有一点从OO的前驱PO那里开始到现在都没有变化，那就是，它们始终都是自顶向下的逐渐细化求精的方法论。 


还有一个不太为人所关注的共同点：他们,PO, OO，都是命令式的。它们都同样以一个状态机的状态变迁为着眼点来运作系统。 

回头看看还在不甘心地吵嚷不休的c++的gp，它真是一个单独的方法论吗？ 
它难道不是也通过自顶向下的方法逐步求精？concept-model难道不就是interface-class的另一种表达形式？它难道不是也 基于状态变迁的命令式系统？（meta-programming不是，但是此处我们暂时不考虑这种生成式编程，因为它在gp里面并不算主流） 
它难道不是仍然用类来封装数据，用方法来实现行为？ 

确实，模板因为concept不是一个强制性的类型，任何类，只要具有某个concept要求的函数签名（实际上甚至要求比这个还要松的），就可以被当作实现这个concept的一个model。如此节省了我们写adapter的工作。 
另外，模板组合也比基于运行时多态，以来gc的接口组合效率高。 
但是，这些细枝末节并不能qualify一个单独的方法论。 

所以，我们认为，gp和programming against interface在方法论上殊途同归，在实现层面上则各有利弊。 

好了，絮絮叨叨这么多，就是要给我所谈到和要进行比较的“oo”画一个圈子，不能说是“权威定义”，但是，这就是我要谈的那个“OO”。 

下一节开始，我们就可以正式开始看看怎么用CO来解决我前面提出的那个例子。 

与此同时，有心人也可以想想用OO（inheritance-oriented也好，interface-oriented也好）这种自顶向下的方式怎么实现这个需求繁杂，甚至有些条款还不确定的例子。 

我自己是想不出太好的方法。一大堆if-else我不喜欢，父子类之间混乱的override这种乱伦行为我也有力不从心之感。
发表于 2006-01-13 05:29 AJOO

