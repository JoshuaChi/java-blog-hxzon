（hxzon学习笔记）java nio netty-编码解码

by hxzon
=========
netty5

1，
消息到消息的解码
StringDecoder extends MessageToMessageDecoder<ByteBuf>

    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, List<Object> out) throws Exception {
        out.add(msg.toString(charset));
    }

放入out，传到下一个处理器。

StringEncoder extends MessageToMessageEncoder<CharSequence>

    @Override
    protected void encode(ChannelHandlerContext ctx, CharSequence msg, List<Object> out) throws Exception {
        if (msg.length() == 0) {
            return;
        }

        out.add(ByteBufUtil.encodeString(ctx.alloc(), CharBuffer.wrap(msg), charset));
    }

2，固定长度的解码
FixedLengthFrameDecoder extends ByteToMessageDecoder

    protected Object decode(
            @SuppressWarnings("UnusedParameters") ChannelHandlerContext ctx, ByteBuf in) throws Exception {
        if (in.readableBytes() < frameLength) {
            return null;
        } else {
            return in.readBytes(frameLength);
        }
    }

如果可读字节不足，返回null，否则读取指定长度的字节。

3，基于“长度”字段的解码
LengthFieldBasedFrameDecoder extends ByteToMessageDecoder

2 bytes length field at offset 0, do not strip header
The value of the length field in this example is 12 (0x0C) which represents the length of "HELLO, WORLD". 
By default, the decoder assumes that the length field represents the number of the bytes that follows the length field. 
Therefore, it can be decoded with the simplistic parameter combination. 
 lengthFieldOffset   = 0
 lengthFieldLength   = 2
 lengthAdjustment    = 0
 initialBytesToStrip = 0 (= do not strip header)

长度字段的偏移，长度字段的长度，
长度矫正（如果长度指整个报文长度，需要矫正。这里长度指后续内容长度，不需要矫正），
弃掉头部字节数（这里不忽略）。

BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)
 +--------+----------------+      +--------+----------------+
 | Length | Actual Content |----->| Length | Actual Content |
 | 0x000C | "HELLO, WORLD" |      | 0x000C | "HELLO, WORLD" |
 +--------+----------------+      +--------+----------------+
 
2 bytes length field at offset 0, strip header
Because we can get the length of the content by calling ByteBuf.readableBytes(), 
you might want to strip the length field by specifying initialBytesToStrip. 
In this example, we specified 2, that is same with the length of the length field, to strip the first two bytes. 

 lengthFieldOffset   = 0
 lengthFieldLength   = 2
 lengthAdjustment    = 0
 initialBytesToStrip = 2 (= the length of the Length field)

弃掉“长度”字段。

 BEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)
 +--------+----------------+      +----------------+
 | Length | Actual Content |----->| Actual Content |
 | 0x000C | "HELLO, WORLD" |      | "HELLO, WORLD" |
 +--------+----------------+      +----------------+

2 bytes length field at offset 0, do not strip header, the length field represents the length of the whole message
In most cases, the length field represents the length of the message body only, as shown in the previous examples. 
However, in some protocols, the length field represents the length of the whole message, including the message header. 
In such a case, we specify a non-zero lengthAdjustment. 
Because the length value in this example message is always greater than the body length by 2, 
we specify -2 as lengthAdjustment for compensation. 
前面的例子，“长度”字段表示的是后续内容的长度，但有时，“长度”字段指的是整个报文的长度。

 lengthFieldOffset   =  0
 lengthFieldLength   =  2
 lengthAdjustment    = -2 (= the length of the Length field)
 initialBytesToStrip =  0

 BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)
 +--------+----------------+      +--------+----------------+
 | Length | Actual Content |----->| Length | Actual Content |
 | 0x000E | "HELLO, WORLD" |      | 0x000E | "HELLO, WORLD" |
 +--------+----------------+      +--------+----------------+
 
3 bytes length field at the end of 5 bytes header, do not strip header
The following message is a simple variation of the first example. 
An extra header value is prepended to the message. 
lengthAdjustment is zero again because the decoder always takes the length of the prepended data 
into account during frame length calculation. 

 lengthFieldOffset   = 2 (= the length of Header 1)
 lengthFieldLength   = 3
 lengthAdjustment    = 0
 initialBytesToStrip = 0

 BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)
 +----------+----------+----------------+      +----------+----------+----------------+
 | Header 1 |  Length  | Actual Content |----->| Header 1 |  Length  | Actual Content |
 |  0xCAFE  | 0x00000C | "HELLO, WORLD" |      |  0xCAFE  | 0x00000C | "HELLO, WORLD" |
 +----------+----------+----------------+      +----------+----------+----------------+
 
3 bytes length field at the beginning of 5 bytes header, do not strip header
This is an advanced example that shows the case where there is an extra header between the length field and the message body. 
You have to specify a positive lengthAdjustment so that the decoder counts the extra header into the frame length calculation. 

 lengthFieldOffset   = 0
 lengthFieldLength   = 3
 lengthAdjustment    = 2 (= the length of Header 1)
 initialBytesToStrip = 0

 BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)
 +----------+----------+----------------+      +----------+----------+----------------+
 |  Length  | Header 1 | Actual Content |----->|  Length  | Header 1 | Actual Content |
 | 0x00000C |  0xCAFE  | "HELLO, WORLD" |      | 0x00000C |  0xCAFE  | "HELLO, WORLD" |
 +----------+----------+----------------+      +----------+----------+----------------+
 
2 bytes length field at offset 1 in the middle of 4 bytes header, strip the first header field and the length field
This is a combination of all the examples above. 
There are the prepended header before the length field and the extra header after the length field. 
The prepended header affects the lengthFieldOffset and the extra header affects the lengthAdjustment. 
We also specified a non-zero initialBytesToStrip to strip the length field and the prepended header from the frame. 
If you don't want to strip the prepended header, you could specify 0 for initialBytesToSkip. 

 lengthFieldOffset   = 1 (= the length of HDR1)
 lengthFieldLength   = 2
 lengthAdjustment    = 1 (= the length of HDR2)
 initialBytesToStrip = 3 (= the length of HDR1 + LEN)

 BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)
 +------+--------+------+----------------+      +------+----------------+
 | HDR1 | Length | HDR2 | Actual Content |----->| HDR2 | Actual Content |
 | 0xCA | 0x000C | 0xFE | "HELLO, WORLD" |      | 0xFE | "HELLO, WORLD" |
 +------+--------+------+----------------+      +------+----------------+
 
2 bytes length field at offset 1 in the middle of 4 bytes header, strip the first header field and the length field, 
the length field represents the length of the whole message

Let's give another twist to the previous example. 
The only difference from the previous example is that the length field represents the length of the whole message 
instead of the message body, just like the third example. 
We have to count the length of HDR1 and Length into lengthAdjustment. 
Please note that we don't need to take the length of HDR2 into account because the length field already includes the whole header length. 

 lengthFieldOffset   =  1
 lengthFieldLength   =  2
 lengthAdjustment    = -3 (= the length of HDR1 + LEN, negative)
 initialBytesToStrip =  3

 BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)
 +------+--------+------+----------------+      +------+----------------+
 | HDR1 | Length | HDR2 | Actual Content |----->| HDR2 | Actual Content |
 | 0xCA | 0x0010 | 0xFE | "HELLO, WORLD" |      | 0xFE | "HELLO, WORLD" |
 +------+--------+------+----------------+      +------+----------------+
 

4，基于“长度”字段的编码
LengthFieldPrepender extends MessageToMessageEncoder<ByteBuf>

An encoder that prepends the length of the message. The length value is prepended as a binary form. 

For example, LengthFieldPrepender(2) will encode the following 12-bytes string: 

 +----------------+
 | "HELLO, WORLD" |
 +----------------+
 
into the following: 
 +--------+----------------+
 + 0x000C | "HELLO, WORLD" |
 +--------+----------------+
 
If you turned on the lengthIncludesLengthFieldLength flag in the constructor, 
the encoded data would look like the following (12 (original data) + 2 (prepended data) = 14 (0xE)): 
 +--------+----------------+
 + 0x000E | "HELLO, WORLD" |
 +--------+----------------+
 

5，




