（hxzon学习笔记）clojure-与java一起工作-类型提示

by hxzon
========
1，通过 ^ 给参数添加类型元数据。

[^ClassnameXX c]，内部扩展成^{:tag ClassnameXX}，clojure内部用tag来表示类型。

clojure中只有long和double两种原始类型，没有int、short、byte、char、boolean等。
最多只能对4个参数进行类型提示。

(defn ch>= ^Boolean [ ^Character ch1 ^Character ch2]
   (>= (int ch1) (int ch2)))

(defn integer-sum-to [n]
	(let [n (int n)]
	  (loop [i (int 1) sum (int 0)]
		(if (<= i n)
			(recur (inc i) (+ i sum))
			sum))))

(defn ^long integer-sum-to [^long n]
	(loop [i 1 sum 0]
		(if (<= i n)
			(recur (inc i) (+ i sum))
			sum)))

只在必要时才用类型提示。这会使得clojure编译代码时不使用反射，从而提高运行时速度。
如果对参数提示类型，但函数体代码不受该类型限制，那么实际调用时用不匹配的类型实参，不会出错。

(defn accepts-anything
  [^java.util.List x]
  x)
;= #'user/accepts-anything

(accepts-anything (java.util.ArrayList.))
;= #<ArrayList []>

(accepts-anything 5)
;= 5

(accepts-anything false)
;= false

==
为了便于阅读函数定义，还可以将元数据放到函数定义最后：
user=> (defn shout
              ([s] (.toUpperCase s))
              {:tag String})

==
从Clojure1.1开始，你能够为数组声明基本类型提示：
Java的boolean[], char[], byte[], short[], int[], long[], float[], 和 double[]数组能被分别标识为
^booleans, ^chars, ^bytes, ^shorts, ^ints, ^longs, ^floats, and ^doubles。
（同样可以采用 ^objects 标识 Object[]）
https://code.google.com/p/clojure-doc-en2ch/wiki/Chapter_14_performance

==
可以对形式加类型提示：
(defn split-name
	[user]
	(zipmap [:first :last]
		(.split ^String (:name user) " ")))

这里对(:name user)添加类型提示。

==
可以对返回值加类型提示（加在函数的参数上面）：
(defn file-extension
	^String [^java.io.File f]
	(-> (re-seq #"\.(.+)" (.getName f))
		first
		second))

==
可以给var添加类型提示：

(def a "image.png")
;= #'user/a

(java.io.File. a)
; Reflection warning, NO_SOURCE_PATH:1 - call to java.io.File ctor can't be resolved.
;= #<File image.png>

(def ^String a "image.png")
;= #'user/a

(java.io.File. a)
;= #<File image.png>

========
========
《clojure编程》第11章：数字和数学-Use Primitive Arrays Judiciously（优化数值效率）

使用原始类型数组。

1，如果可变对象只在函数内使用，这是可取的，不违背clojure的。

====
2，p446，《Multidimensional  concerns.》
访问多维数组的性能问题。

(def arr (make-array Double/TYPE 1000 1000))
;= #'user/arr

(time (dotimes [i 1000]
	(dotimes [j 1000]
		(aset arr i j 1.0)
		(aget arr i j))))
; "Elapsed time: 50802.798 msecs"

这是aget和aset不支持直接访问多维数组。
因为中间层是对象数组，它们通过递归使用apply来支持多维操作、获取或设置多维数组的每一层。
因为aset不为n维数组提供直接的函数变体，在使用apply传播到其它参数时，1.0被装箱。
因为没有办法提示arr是一个原始类型数组，所以所有操作都是靠反射。

解决办法是通过手工展开中间层，加上必要的类型提示，如下：

(time (dotimes [i 1000]
	(dotimes [j 1000]
		(let [^doubles darr (aget ^objects arr i)]
			(aset darr j 1.0)
			(aget darr j)))))
; "Elapsed time: 21.543 msecs"
;= nil

如上，提示最终类型是double数组，中间层是Object数组。

但维数增加，代码会迅速复杂，可自定义宏来解决这个问题。

(defmacro deep-aget
	"Gets a value from a multidimensional array as if via `aget`,
	but with automatic application of appropriate type hints to
	each step in the array traversal as guided by the hint added
	to the source array.
	e.g. (deep-aget ^doubles arr i j)"

	([array idx]
		`(aget ~array ~idx)) 
	([array idx & idxs]
		(let [a-sym (gensym "a")]
			`(let [~a-sym (aget ~(vary-meta array assoc :tag 'objects) ~idx)] 
				(deep-aget ~(with-meta a-sym {:tag (-> array meta :tag)}) ~@idxs)))))

--
(defmacro deep-aset
	"Sets a value in a multidimensional array as if via `aset`,
	but with automatic application of appropriate type hints to
	each step in the array traversal as guided by the hint added
	to the target array.
	e.g. (deep-aset ^doubles arr i j 1.0)"
	[array & idxsv]
	(let [hints '{booleans boolean, bytes byte 
		chars char, longs long
		ints int, shorts short
		doubles double, floats float}

		hint (-> array meta :tag)
		[v idx & sxdi] (reverse idxsv)
		idxs (reverse sxdi)
		v (if-let [h (hints hint)] (list h v) v)

		nested-array (if (seq idxs)
			`(deep-aget ~(vary-meta array assoc :tag 'objects) ~@idxs)
			array)

		a-sym (gensym "a")]

		`(let [~a-sym ~nested-array]
			(aset ~(with-meta a-sym {:tag hint}) ~idx ~v))))

使用示例：
(time (dotimes [i 1000]
	(dotimes [j 1000]
		(deep-aset ^doubles arr i j 1.0)
		(deep-aget ^doubles arr i j))))
; "Elapsed time: 25.033 msecs"

--
(macroexpand-1 '(deep-aset ^doubles arr 2 3 1.0))
;(clojure.core/let [a1335 (user/deep-aget arr 2)] (clojure.core/aset a1335 3 (double 1.0)))

(def arr (make-array Double/TYPE 100 100 100))
(macroexpand-1 '(deep-aset ^doubles arr 2 3 4 1.0))
;(clojure.core/let [a1366 (user/deep-aget arr 2 3)] (clojure.core/aset a1366 4 (double 1.0)))

(macroexpand `(deep-aset ^doubles arr 2 3 4 1.0))
;(let* [a1376 (user/deep-aget user/arr 2 3)] (clojure.core/aset a1376 4 1.0))

（hxzon：macroexpand没有继续展开deep-aget？）

==
hxzon代码注释：

(defmacro deep-aget
	"Gets a value from a multidimensional array as if via `aget`,
	but with automatic application of appropriate type hints to
	each step in the array traversal as guided by the hint added
	to the source array.
	e.g. (deep-aget ^doubles arr i j)"

	([array idx]
		`(aget ~array ~idx)) 
对于一维数组，直接使用aget。这里假设array已经合理的提示了类型。

	([array idx & idxs]
		(let [a-sym (gensym "a")]
			`(let [~a-sym (aget ~(vary-meta array assoc :tag 'objects) ~idx)] 
				(deep-aget ~(with-meta a-sym {:tag (-> array meta :tag)}) ~@idxs)))))
对于多维数组，首先生成一个名字a-sym，它表示下一层数组。
~(vary-meta array assoc :tag 'objects)，给array添加object类型提示。
~(with-meta a-sym {:tag (-> array meta :tag)})，给下一层数组添加array所带的类型提示。

--
(defmacro deep-aset
	"Sets a value in a multidimensional array as if via `aset`,
	but with automatic application of appropriate type hints to
	each step in the array traversal as guided by the hint added
	to the target array.
	e.g. (deep-aset ^doubles arr i j 1.0)"
	[array & idxsv]
解构成“数组（带类型提示）”及“下标和值”两部分。

	(let [hints '{booleans boolean, bytes byte 
		chars char, longs long
		ints int, shorts short
		doubles double, floats float}

		hint (-> array meta :tag)
hint为array带的类型提示。

		[v idx & sxdi] (reverse idxsv)
反转“下标和值”，取得值v，和最底层下标idx。

		idxs (reverse sxdi)
恢复中间层的下标。

		v (if-let [h (hints hint)] (list h v) v)
if-let宏接受两个参数，第一个参数为绑定变量，第二个参数为表达式。
并根据第二个表达式参数返回的值确定执行then、else语句。
(hints hint)，返回hint对应的强制转换函数，如果找到，绑定到h，if-let返回(list h v)，否则返回v。

		nested-array (if (seq idxs)
			`(deep-aget ~(vary-meta array assoc :tag 'objects) ~@idxs)
			array)
如果中间层下标不只一个，用deep-aget取得最底一层数组，否则直接返回array（已经是最底一层数组）。

		a-sym (gensym "a")]

		`(let [~a-sym ~nested-array]
			(aset ~(with-meta a-sym {:tag hint}) ~idx ~v))))

