（hxzon学习笔记）clojure学习摘要

====
1，定义函数

(fn [p1 p2] s1 s2)

(defn xxx [^long p1 ^String p2] s1 s2)

注意，只有long和double两种类型。

==
fn的第一个参数是一个可选的函数名字，使得可以在函数体中引用函数自己。

(def strange-adder (fn  adder-self-reference
                        ([x] (adder-self-reference x 1))
                        ([x y] (+ x y))))
;= #'user/strange-adder

==
定义本地变量，(let [x1 v1 x2 v2] ...)

中途return，使用内部私有函数，(let [fn1 ...]) 。

==
循环：

          (loop [ sb "" cmds (keys @adm-cmds)]
            (if(empty? cmds)
              (.writeAndFlush ctx (str sb "\r\n"))
              (recur (str sb (first cmds) "  ") (rest cmds))))


====
2，宏

宏在读取器展开，它的返回值就是展开的结果。
宏返回的值是“clojure代码”，这些生成的代码插入到自己所在位置。


(defmacro defCompFn [name method & body]
  ;`(dosync (alter ~name assoc (keyword ~method) (fn ~@body))))
  (list 'dosync (list 'alter name 'assoc (list 'keyword method ) (cons 'fn body ))))

==
(defmacro kfn [name method & body]
  (let [bs (if (vector? (first body))  (list body)  body)
        bs 
        (for [ [a & b] bs]    ;向量解构
          (cons (into ['this] a) b))]    ;添加隐式参数“this”
    `(dosync (alter ~name assoc (keyword ~method) (fn ~@bs) ))  ))

(defmacro kfns [name & methods]
  (let [ms 
        (for [ [methodName & methodBody] methods]
          `(defCompFn ~name ~methodName ~@methodBody))]
    `(do ~@ms)))

;相当于给宏重命名：

(defmacro defCompFn [name method & body]
  `(kfn ~name ~method ~@body))

(defmacro defCompFns [name & methods]
  `(kfns ~name ~@methods))

==
~'，波浪号和单引号是一种常见的搭配，如下。
~'session，外层已经阻止求值，为什么不直接使用 session ？
因为直接使用session，会加上当前的命名空间，见下。
let绑定是不允许有名字空间的。

'~xxx ，对xxx求值，再引述。

==
引述（单引号'）：返回参数的不求值形式。

语法引述（反引号`）：跟引述很像，但语法引述把无命名空间限定的符号求值成当前命名空间的符号。
符号的默认空间化对于产生正确的代码非常关键。
它使我们不会因为疏忽而重定义一个已经定义过的值。这被称为“宏卫生”。
另，语法引述里面允许“反引述”。

反引述（波浪号~）。在语法引述里面，表示求值。

编接反引述（波浪地址号~@）。在语法引述里面，表示求值成一个列表，再嵌入外层。

====
3，常用

(import 'io.netty.buffer.ByteBuf)

(def cmd-fns (ref {}))

(defmacro def-cmd [cmd & body]
	`(dosync (alter cmd-fns assoc ~cmd (fn [ ~'byteBuf  ~'ctx] ~@body))))

(defn remove-client [^Channel channel]
	(dosync (alter dissoc clientChannels channel)))

给宏生成的代码添加类型提示（通过引入本地绑定）：

(defmacro def-cmd [cmd & body]
  (let [byteBuf (with-meta 'byteBuf { :tag ByteBuf } ) 
          ctx (with-meta 'ctx { :tag ChannelHandlerContext }) ]
    `(dosync (alter cmd-fns assoc ~cmd (fn [ ~byteBuf  ~ctx] ~@body)))))

====
4，(with-out-str & body)
将“打印输出”绑定到一个StringWriter，返回这个字符串。

====
5，在需要do的地方，漏写do，会抛出空指针异常。


