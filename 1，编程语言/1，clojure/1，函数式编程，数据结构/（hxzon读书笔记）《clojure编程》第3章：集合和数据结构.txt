（hxzon读书笔记）《clojure编程》第3章：集合和数据结构

by hxzon
《clojure编程》第3章：集合和数据结构
--------
摘要：

主要抽象：Collection，Sequence（序列），Associative（关系型的），
Indexed（索引的），Stack（栈），Set，Sorted（有序的）。

不可变性，持久性，结构共享。

易变集合（只是一种性能优化手段）。

group-by，reduce-by。

==========
1，《3.1，Abstractions over Implementations，抽象优于实现》

一百种算法对一种数据结构操作，优于十种算法对十种数据结构操作。
—Alan J. Perlis in the foreword to Structure and Interpretation of Computer Programs,
http://mitpress.mit.edu/sicp/toc/toc.html

clojure：更优的是一百种算法对一种抽象操作。

clojure的集合抽象以及具体的数据结构的实现是整个语言的核心。
它比clojure的其它任何特性都更能代表这门语言的能力、特征以及世界观。


2，《3.6，Putting Clojure’s Collections to Work，用Clojure的集合来小试牛刀》

在《人月神话》中，Frederick Brooks说：“
Show me your flowchart and conceal your tables, and I shall continue to be mystified.
Show me your tables, and I won’t usually need your flowchart; it’ll be obvious.”

告诉我数据库表就可以了，我不需要你的流程图。

Eric Raymond说：“
Show me your code and conceal your data structures, and I shall continue to be mystified.
Show me your data structures, and I won’t usually need your code; it’ll be obvious.”。
告诉我数据结构就可以了，我不需要你的代码。

就像Brooks说的，具体的代码怎么编写是由你的数据建模方式决定的，
同样的道理，要编写好的clojure代码也需要你正确地使用好的数据结构，
而这些“好的数据结构”通常是自然标识符、set以及map。
参见《（hxzon读书笔记）《clojure编程》第3章：集合和数据结构-生命游戏》
和《（hxzon读书笔记）《clojure编程》第3章：集合和数据结构-迷宫，zipper》。

==
标识符和循环引用。

数据结构本身就是它们的最佳自然标识，不再需要复杂的人工的唯一标识。
循环引用容易导致不一致性。

========
3，主要的抽象：

• Collection
• Sequence 序列
• Associative 关系型的
• Indexed 可索引的
• Stack 栈
• Set
• Sorted 有序的

====
3.1，Collection，所有数据结构都实现了此抽象。

seq
(conj coll & e)，保证高效的添加元素。（向量在尾部插入，列表在头部插入）
(into coll & coll)
count ，保证高效的。（但序列除外，因为序列的长度可能是未知的。）
empty ，返回一个同样具体类型的空集合。
= 比较集合相等。

====
3.2，序列

seq。
可序列类型：
所有clojure集合类型。
所有java集合类型，即java.util.* 。
所有java map。
所有java.lang.CharSequence，包括String。
实现了java.lang.Iterable的任意类型。
数组。
nil。
任何实现了clojure.lang.Seqable接口的类型。

seq对于任何nil或者任何类型的空集合都返回nil。
很多函数都在内部对参数调用seq。

==
遍历序列：first，rest，next 。

lazy-seq，创建一个内容是一个表达式结果的惰性序列。

empty?

==
序列不是迭代器。有状态的迭代器一旦被遍历，就不能再遍历了。

序列不是列表。计算一个序列的长度是耗时的，而列表会保存它的长度。
序列的内容可能是惰性的，可能是无限的，所以也就是不可数的。

==
延迟序列
map,  for,  filter,  take, 和  drop 都返回延迟序列。
file-seq, line-seq, 和 xml-seq 。

next始终返回nil而不是空的序列，因为它始终会去强制实例化序列尾巴的第一个元素。
而rest则始终简单的返回序列的尾巴。
顺序结构始终使用next而不是rest。所以如果你在解构一个惰性序列时，始终会实例化它的尾巴的头元素。

hxzon注意：对于空集合和nil，next始终返回nil，rest始终返回空集合。

(defn random-ints
    [limit]
    (lazy-seq
        (println "realizing random number") 
        (cons (rand-int limit)
            (random-ints limit))))

(let [[x & rest] (random-ints 50)])
; realizing random number
; realizing random number
;= nil

==
doall
dorun

iterate([f x]) ，返回一个延迟序列，元素为x, (f x), (f (f x))。f不能有副作用。

reverse ，返回一个非延迟序列，元素逆序。

==
“头保持”问题（hxzon：注意）

==
split-with，分割序列。

====
3.3，关系型

assoc
dissoc
get
contains? ，是否含有指定的键。

注意nil值（无法区分正好是nil值还是找不到），使用find，因为返回的是键值对，或者nil（找不到）。

====
3.4，可索引的

下标是新的指针。

nth。下标越界，nth会跑出异常，而get返回nil。

====
3.5，栈

clojure没有独立的“栈”集合，可使用以下操作实现栈的功能。

conj。
pop。
peek。

====
3.6，set

disj，移除元素。

subset?,  superset?,  union,  intersection,  project。

====
3.7，有序的

rseq。
subseq。
rsubreq。
sorted-map。
sorted-set。
sorted-map-by。
sorted-set-by。

compare：默认顺序，即正序。

clojure如何把二元谓词变成排序器？

----
线性插值。
(defn interpolate
	"Takes a collection of points (as [x y] tuples), returning a function
	which is a linear interpolation between those points."
	[points]
	(let [results (into (sorted-map) (map vec points))] 
		(fn [x]
			(let [[xa ya] (first (rsubseq results <= x)) 
				[xb yb] (first (subseq results > x))]
				(if (and xa xb) 
					(/ (+ (* ya (- xb x)) (* yb (- x xa))) 
						(- xb xa))
					(or ya yb))))))

(def f (interpolate [[0 0] [10 10] [15 5]]))
;= #'user/f

(map f [2 10 12])
;= (2 10 8)


========
向量，映射，集，本身就是函数。
列表不是函数。

([:a :b :c] 2)
;= :c

({:a 5 :b 6} :b)
;= 6

({:a 5 :b 6} :c 7)
;= 7

(#{1 2 3} 3)
;= 3

等价于：
(get [:a :b :c] 2)
;= :c

(get {:a 5 :b 6} :b)
;= 6

(get {:a 5 :b 6} :c 7)
;= 7

(get #{1 2 3} 3)
;= 3

注意，
([:a :b :c] -1)
;= #<IndexOutOfBoundsException java.lang.IndexOutOfBoundsException>

====
集合的键也是函数，用来从集合中查找自己对应的值。

(:b {:a 5 :b 6})
;= 6

(:c {:a 5 :b 6} 7)
;= 7

(:d #{:a :b :c})
;= nil

优先使用键，因为键是字面量，不会出现空指针异常。
(coll idx)不能保证coll不为nil，也不能保证coll为集合。

====
(filter (comp (partial <= 25) :age) 
	[{:age 21 :name "David"}
		{:gender :f :name "Suzanne" :age 20}
		{:name "Sara" :location "NYC" :age 34}])
;= ({:age 34, :name "Sara", :location "NYC"})

========
4，数据结构的类型

----
列表。

向量。
公共api优先使用map作为参数和返回值，因为向量（元组）不是自解释的，
除非是含义很清晰的，例如点的坐标。

set。
set，将集合转成set。

映射。

keys。
vals。
key。
val。

map作为临时结构。
defrecord。

====
分组

(group-by key-fn coll)：根据key-fn函数把一个集合分成多组。

(group-by #(rem % 3) (rang 10))
;= {0 [0 3 6 9] , 1 [1 4 7] , 2 [2 5 8]}

(def playlist
[   {:title "Elephant", :artist "The White Stripes", :year 2003}
    {:title "Helioself", :artist "Papas Fritas", :year 1997}
    {:title "Stories from the City, Stories from the Sea",
        :artist "PJ Harvey", :year 2000}
    {:title "Buildings and Grounds", :artist "Papas Fritas", :year 2000}
    {:title "Zen Rodeo", :artist "Mardi Gras BB", :year 2002}])

;按某个键分组。
(group-by :artist playlist)
;= {"Papas Fritas" [{:title "Helioself", :artist "Papas Fritas", :year 1997}
;= {:title "Buildings and Grounds", :artist "Papas Fritas"}]
;= ...}

;按两个键分组。
(group-by (juxt :col1 :col2) data)

====
分组聚合

;分组，计算每组的聚合信息。
;key-fn，分组函数。summarize，聚合函数。
(into {} (for [[k v] (group-by key-fn coll)]    ;将group-by的结果解构成键和值。
              [k (summarize v)]))

;reduce-by，对任意种类的数据计算聚合数据。
(defn reduce-by
    [key-fn f init coll]    ;f为聚合函数。
    (reduce (fn [summaries x]   ;summaries为上一轮的聚合结果，是一个map。
                (let [k (key-fn x)]
                    (assoc summaries k (f (summaries k init) x))))
            {} coll))

(def orders
    [   {:product "Clock", :customer "Wile Coyote", :qty 6, :total 300}
        {:product "Dynamite", :customer "Wile Coyote", :qty 20, :total 5000}
        {:product "Shotgun", :customer "Elmer Fudd", :qty 2, :total 800}
        {:product "Shells", :customer "Elmer Fudd", :qty 4, :total 100}
        {:product "Hole", :customer "Wile Coyote", :qty 1, :total 1000}
        {:product "Anvil", :customer "Elmer Fudd", :qty 2, :total 300}
        {:product "Anvil", :customer "Wile Coyote", :qty 6, :total 900}])

;按照客户名字分组，每个分组求和total值。
(reduce-by :customer #(+ %1 (:total %2)) 0 orders)
;= {"Elmer Fudd" 1200, "Wile Coyote" 7200}

;按照产品名字分组，收集每个产品的客户名字。
(reduce-by :product #(conj %1 (:customer %2)) #{} orders)
;= {"Anvil" #{"Wile Coyote" "Elmer Fudd"},
;=  "Hole" #{"Wile Coyote"},
;=  "Shells" #{"Elmer Fudd"},
;=  "Shotgun" #{"Elmer Fudd"},
;=  "Dynamite" #{"Wile Coyote"},
;=  "Clock" #{"Wile Coyote"}}

;查看每个客户在每种产品上的金额。（下面三种方式是等价的。）
(fn [order]
    [(:customer order) (:product order)])

#(vector (:customer %) (:product %))

(fn [{:keys [customer product]}]
    [customer product])

(juxt :customer :product)

(reduce-by  (juxt :customer :product)
            #(+ %1 (:total %2)) 0 orders)
;= {["Wile Coyote" "Anvil"] 900,
;=  ["Elmer Fudd" "Anvil"] 300,
;=  ["Wile Coyote" "Hole"] 1000,
;=  ["Elmer Fudd" "Shells"] 100,
;=  ["Elmer Fudd" "Shotgun"] 800,
;=  ["Wile Coyote" "Dynamite"] 5000,
;=  ["Wile Coyote" "Clock"] 300}

;如果需要包含map的map，需要将assoc和get（隐式调用）换成assoc-in和get-in。
(defn reduce-by-in
    [keys-fn f init coll]
    (reduce (fn [summaries x]
                (let [ks (keys-fn x)]
                     (assoc-in summaries ks
                        (f (get-in summaries ks init) x))))
            {} coll))

(reduce-by-in (juxt :customer :product)
              #(+ %1 (:total %2)) 0 orders)
;= {"Elmer Fudd" {  "Anvil" 300,
;=                  "Shells" 100,
;=                  "Shotgun" 800},
;= "Wile Coyote" {  "Anvil" 900,
;=                  "Hole" 1000,
;=                  "Dynamite" 5000,
;=                  "Clock" 300}}

;或者直接对结果转换。
(def flat-breakup
    {   ["Wile Coyote" "Anvil"] 900,
        ["Elmer Fudd" "Anvil"] 300,
        ["Wile Coyote" "Hole"] 1000,
        ["Elmer Fudd" "Shells"] 100,
        ["Elmer Fudd" "Shotgun"] 800,
        ["Wile Coyote" "Dynamite"] 5000,
        ["Wile Coyote" "Clock"] 300})

(reduce #(apply assoc-in %1 %2) {} flat-breakup)    ;前面的向量正好是键序列。
;= {"Elmer Fudd" {  "Shells" 100,
;=                  "Anvil" 300,
;=                  "Shotgun" 800},
;= "Wile Coyote" {  "Hole" 1000,
;=                  "Dynamite" 5000,
;=                  "Clock" 300,
;=                  "Anvil" 900}}

========
5，不可变和持久性

书： Okasaki《Purely  Functional  Data  Structures》

树的森林。
See http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwicefor an
overview of the hash array mapped trie implementation in Clojure’s PersistentHashMapclass.

See  http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation
for an overview of the implementation in Clojure’s PersistentVectorclass.

http://eclipsesource.com/blogs/2009/12/13/persistent-trees-in-git-clojure-and-couchdb-data-structure-convergence

持久性与结构共享。
持久性图解。

======
元数据。见《（hxzon翻译）clojure元数据》。


