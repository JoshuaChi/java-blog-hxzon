王垠-Unix的缺陷(1) - 从命令行谈起
2012/05/17 09:50
http://blog.sina.com.cn/s/blog_5d90e82f01014k5j.html
作者：王垠 | 来自：寂静之声

hxzon摘要：文本没有固定格式。
hxzon：json，clojure 的字面量。

========
希望这篇文章能帮助大家看清楚“Unix哲学”的本质，
从而可以灵活的应用它的潜力，避免它的缺点。
通常所谓的“Unix哲学”包括以下三条原则[Mcllroy]：

一个程序只做一件事情，并且把它做好。
程序之间能够协同工作。
程序处理文本流，因为它是一个通用的接口。

这三条原则当中，前两条其实早于Unix就已经存在，
它们描述的其实是程序设计最基本的原则——模块化原则。
任何一个具有函数和调用的程序语言都具有这两条原则。
简言之，第一条针对函数，第二条针对调用。
所谓“程序”，不过是一个main函数（详见下文）。

====
所以只有第三条（用文本流做接口）是Unix所特有的。
下文的“Unix哲学”如果不加修饰，就特指这第三条原则。
但是许多的事实已经显示出，这第三条原则其实包含了实质性的错误。
它不但一直在给我们制造无需有的问题，并且在很大程度上影响了前两条原则的实施。
然而，这条原则却被很多人奉为神圣。
许多程序员在他们自己的程序和协议里大量的使用文本流来表示数据，
引发了各种头痛的问题，却对此视而不见。

Linux有它优于Unix的革新之处，但是我们必须看到，
它其实还是继承了Unix的这条哲学。
Linux系统的命令行，配置文件，各种工具之间都通过文本流传递数据。
这造成了信息格式的不一致，程序之间协作非常困难。
当然，我这样说并不等于Windows或者Mac就做得好很多（虽然它们对此有所改进）。
实际上，几乎所有常见的操作系统都受到Unix哲学的潜移默化的影响，
以至于它们身上或多或少都存在它的阴影。

Unix哲学的影响是多方面的。
从命令行到程序语言，到数据库，Web…… 
计算机和网络系统的方方面面无不显示出它的影子。
在将来的几篇博文里，我会把众多的问题与它们的根源——Unix哲学相关联。
今天我就从最简单的命令行开始吧。
（文本流的实质就是字符串，所以在下文里这两个名词通用。）

====
一个Linux命令运行的基本过程

几乎每个Linux用户都为它的命令行困惑过。
很多人（包括我在内）用了好几年Linux也没有完全的掌握命令行的用法。
虽然看文档看书以为都看透了，到时候还是会出现莫名其妙的问题，
有时甚至会耗费整天的时间在上面。
其实如果看透了命令行的本质，你就会发现很多问题其实不是用户的错。
Linux遗传了Unix的“哲学”，
用文本流来表示数据和参数，才导致了命令行难学难用。

我们首先来分析一下Linux命令行的工作原理吧。
下图是一个Linux命令运行的过程。当然这不是全过程,但是更具体的细节跟我现在要说的主题无关。

从上图我们可以看到，在ls命令运行的整个过程中，发生了如下的事情：

Shell（在这个例子里是bash）从终端得到输入的字符串"ls -l *.c"。
Shell以空白字符为界，切分这个字符串，得到 "ls", "-l" 和 "*.c" 三个字符串。

Shell发现第二个字符串是通配符 "*.c"，
于是在当前目录下寻找与这个通配符匹配的文件。
它找到两个文件： foo.c 和 bar.c。

Shell把这两个文件的名字和其余的字符串一起
做成一个字符串数组 {"ls", "-l", "bar.c", "foo.c"}. 
它的长度是4.

Shell生成一个新的进程，在里面执行一个名叫 "ls" 的程序，
并且把字符串数组 {"ls", "-l", "bar.c", "foo.c"}和它的长度4，作为ls的main函数的参数。
main函数是C语言程序的“入口”，这个你可能已经知道。

ls程序启动并且得到的这两个参数（argv，argc）后，
对它们做一些分析，提取其中的有用信息。
比如ls发现字符串数组argv的第二个元素("-l")以"-"开头，
就知道那是一个选项
——用户想列出文件详细的信息，
于是它设置一个布尔变量表示这个信息，以便以后决定输出文件信息的格式。

ls列出 foo.c 和 bar.c 两个文件的“长格式”信息之后退出。
以整数0作为返回值。

Shell得知ls已经退出，返回值是0。
在shell看来，0表示成功，而其它值（不管正数负数）都表示失败。
于是shell知道ls运行成功了。
由于没有别的命令需要运行，shell向屏幕打印出提示符，开始等待新的终端输入……

从上面的命令运行的过程中，我们可以看到文本流（字符串）在命令行中的普遍存在：

用户在终端输入是字符串。
Shell从终端得到的是字符串，分解之后得到3个字符串，展开通配符后得到4个字符串。
ls程序从参数得到那4个字符串，看到字符串"-l"的时候，就决定使用长格式进行输出。

接下来你会看到这样的做法引起的问题。

====
冰山一角

在《Unix痛恨者手册》(The Unix-Hater's Handbook, 以下简称UHH)这本书开头，
作者列举了Unix命令行用户界面的一系列罪状，
咋一看还以为是脾气不好的初学者在谩骂。
可是仔细看看，你会发现他们某些人的话里面有非常深刻的道理。
其实这些命令行问题的根源就是“Unix哲学”
——用文本流（字符串）来表示参数和数据。
很多人都没有意识到，文本流的过度使用，引发了太多问题。
我举一个简单的例子吧，你现在就可以自己动手试一下：

在你的Linux终端里执行如下命令（依次输入：大于号，减号，小写字母l）。
这会在目录下建立一个叫 "-l" 的文件。
$ >-l
执行命令 ls * （你的意图是以短格式列出目录下的所有文件）。

你看到什么了呢？
你没有给ls任何选项，文件却出人意料的以“长格式”列了出来，
而这个列表里面却没有你刚刚建立的那个名叫 "-l" 的文件。
比如我得到如下输出：

-rw-r--r-- 1 wy wy 0 2011-05-22 23:03 bar.c
-rw-r--r-- 1 wy wy 0 2011-05-22 23:03 foo.c

到底发生了什么呢？
重温一下上面的示意图吧，特别注意第二步。
原来shell在调用ls之前，把通配符*展开成了目录下的所有文件，
那就是"foo.c", "bar.c", 和一个名叫"-l"的文件。
它把这3个字符串加上ls自己的名字，
放进一个字符串数组 {"ls", "bar.c", "foo.c", "-l"}，交给ls。

接下来发生的是，ls拿到这个字符串数组，
发现里面有个字符串是"-l"，就以为那是一个选项：
用户想用“长格式”输出文件信息。
因为"-l"被认为是选项，就没有被列出来。
于是我就得到上面的结果：长格式，还少了一个文件！

这说明了什么问题呢？是用户的错吗？
“高手”们也许会笑，怎么有人会这么傻，在目录里建立一个叫 "-l" 的文件。
但是我可以告诉你，就是这样喜欢自诩“高手”的态度，
导致了我们对Unix的错误视而不见，甚至让它发扬光大。
如果撇除心里的优越感，从理性的观点看一看，
我们就发现这一切都是系统设计的错误，而不是用户的错误。
如果用户要上法庭状告Linux，他可以这样写：

====
起诉状
原告：用户luser
被告：Linux操作系统
事由：合同纠纷
被告的文件系统给用户提供了机制建立这样一个叫 "-l" 的文件，这表示原告有权使用这个文件名。
既然"-l"是一个合法的文件名，而"*"通配符表示匹配“任何文件”，
那么在原告使用"ls *"命令的时候，被告就应该像原告所期望的那样，
以正常的方式列出目录下所有的文件，包括"-l"在内。
但是实际上原告没有达到他认为理所当然的结果。
"-l"被ls命令认为是一个命令行选项，而不是一个文件。
原告认为自己的合法权益受到侵犯。

像这样的命令行问题真是举不胜举。
如果你想更加确信这个问题的存在，可以试试如下的做法。
在这之前，请新建一个测试用的目录，以免丢失你的文件！

在新目录里，我们首先建立两个文件夹dir-a, dir-b和三个普通文件file1，file2和"-rf"。
然后我们运行rm *，意图是删除所有普通文件，而不删掉目录。

$ mkdir dir-a dir-b
$ touch file1 file2
$ > -rf
$ rm *

然后用ls查看目录。

你会发现最后只剩下一个文件: "-rf"。
本来 rm * 只能删除普通文件，现在由于目录里存在一个叫"-rf"的文件。
rm以为那是叫它进行强制递归删除的选项，
所以它把目录里所有的文件连同目录全都删除了，只剩下"-rf"！

====
表面的解决方案

难道这说明我们应该禁止任何以"-"开头的文件名的存在，
因为这样会让程序分不清选项和文件名？
可是不幸的是，由于Unix给程序员的“灵活性”，
并不是每个程序都认为以"-"开头的参数是选项。
比如，Linux下的tar，ps等命令就是例外。
所以这个方案不大可行。

从上面的例子我们可以看出，问题的来源似乎是因为ls根本不知道通配符*的存在。
是shell把通配符展开以后给了ls。
ls只得到文件名和选项混合在一起的字符串数组。
所以UHH的作者提出的一个看法就是：
Shell根本不应该展开通配符。
通配符应该直接被送给程序，由程序自己调用一个库函数来展开。
这个方案确实可行：
如果shell把通配符直接给ls，那么ls会只看到"*"一个参数。
它会调用库函数在文件系统里去寻找当前目录下的所有文件，
它会很清楚的知道"-l"是一个文件，而不是一个选项，
因为它根本没有从shell那里得到任何选项(它只得到一个参数："*")。
所以问题貌似就解决了。

但是这样每一个命令都自己检查通配符的存在，
然后去调用库函数来解释它，大大增加了程序员的工作量和出错的概率。
况且shell不但展开通配符，还有环境变量，花括号展开，~展开，命令替换，算术运算展开……
这些每个程序都自己去做？
这恰恰违反了第一条Unix哲学——程序的模块化原则。
而且这个方法并不是一劳永逸的，它只能解决这一个问题。
我们还将遇到文本流引起的更多的问题，它们没法用这个方法解决。
下面就是一个例子。

====
冰山又一角

其实这些症状只是冰山的一角，
这些看似微不足道的问题里面其实包含了Unix本质的问题。
如果不能正确认识到它，我们跳出了一个问题，还会进入另一个。
我讲一个自己的亲身经历吧。
我前年夏天在Google实习快结束的时候发生了这样一件事情……

由于我的项目对一个开源项目的依赖关系，
我必须在Google的Perforce代码库中提交这个开源项目的所有文件。
这个开源项目里面有9000多个文件，而Perforce是如此之慢，
在提交进行到一个小时的时候，突然报错退出了，说有两个文件找不到。
又试了两次（顺便出去喝了咖啡，打了台球），还是失败，这样一天就快过去了。
于是我搜索了一下这两个文件，确实不存在。
怎么会呢？
我是用公司手册上的命令行把项目的文件导入到Perforce的呀，怎么会无中生有？
这条命令是这样：

find -name *.java -print | xargs p4 add

它的工作原理是，find命令在目录树下找到所有的以".java"结尾的文件（Java源程序），
把它们用空格符隔开做成一个字符串，然后交给xargs。
xargs以空格符把这个字符串拆开成多个字符串，
然后放在"p4 add"后面，组合成一条命令，然后执行它。

问题出在哪里呢？
经过一下午的困惑之后我终于发现，原来这个开源项目里有一个叫做"App Launcher.java"的文件。
由于它的名字里面含有一个空格，被xargs拆开成了两个字符串："App"和"Launcher.java"。
当然这两个文件都不存在，所以Perforce在提交的时候抱怨找不到它们。
我告诉组里的负责人这个发现后，他说：
“怎么能给Java程序起这样一个名字？这也太菜了吧！”

但是我却不认为是这个开源项目的程序员的错误，这其实显示了Unix的问题。
这个问题的根源是因为Unix的命令(find, xargs)把文件名以字符串的形式传递，
它们默认以空格符隔开文件名。
而这个项目里恰恰有一个文件的名字里面有空格符，所以导致了歧义的产生。
该怪谁呢？
Linux允许文件名里面有空格符，那么用户就有权使用这个功能。
到头来因此出了问题，用户却被叫做菜鸟，
为什么自己不小心！这不是霸王条约是什么？ :-)

后来我仔细看了一下find和xargs的man page，
发现其实它们的设计者其实已经意识到这个问题。
所以find和xargs各自有一个选项："-print0"和"-0"。
它可以让find和xargs不用空格符，而用"NULL"（ASCII字符0）作为文件名的分隔符，
这样就可以避免文件名里有空格导致的问题。
然而可笑的是，连Google这样大量使用find和xargs的公司都不知道这个选项的存在！

====
文本流不是可靠的接口

其实这个例子和我之前给出的那些，都显示了Unix哲学（用文本流来传递数据）的错误。
是的，文本流是一个“通用”的接口，
但是它却不是一个“可靠”的接口。
Unix命令的工作原理基本是这样：

从标准输入得到文本流，处理，向标准输出打印文本流。
程序之间用管道进行通信，让文本流可以在程序间传递。

这其中主要有两个过程：

第一，程序向标准输出“打印”的时候，数据被转换成文本。
这是一个编码过程。

第二，文本通过管道（或者文件）进入另一个程序，
这个程序需要从文本里面提取它需要的信息。
这是一个解码过程。

编码的貌似很简单，你只需要随便设计一个“语法”，
比如“用空格隔开”，就能输出了。
可是编码的设计远远不是想象的那么容易。
要是编码格式没有设计好，解码的人就麻烦了，
轻则需要正则表达式才能提取出文本里的信息，
遇到复杂一点的编码（比如程序文本），就得用parser。
最严重的问题是，由于鼓励使用文本流，
很多程序员很随意的设计他们的编码方式而不经过严密思考。
这就造成了Unix的几乎每个程序都有各自不同的输出格式，
使得解码成为非常头痛的问题，经常出现歧义和混淆。

上面find/xargs的问题就是因为find编码的分隔符（空格）和文件名里可能存在的空格相混淆
——此空格非彼空格也。
而之前的ls和rm的命令行参数问题就是因为shell把文件名和选项都“编码”为“字符串”，
所以ls程序无法通过解码来辨别它们的到底是文件名还是选项
——此字符串非彼字符串也！

如果你使用过Java或者函数式语言（Haskell，ML），
你可能会了解一些类型理论(Type Theory)。
在类型理论里，数据的类型是多样化的，
Integer, String, Boolean, List, 自定义结构类型…… 
程序之间传递的所谓“数据”，只不过就是这些类型的数据结构。
然而按照Unix的设计，所有的类型都被转化成String之后在程序间传递。
这样带来这样一个问题：
由于无结构的String没有足够的表达力来区分其它的数据类型，
所以经常会出现歧义。
相比之下，如果用Haskell来表示命令行参数，它应该是这样：

data Parameter = Option String | File String | ...

虽然两种东西的实质都是String，
但是Haskell会给它们加上“标签”以区分Option还是File。
这样当ls接收到参数列表的时候，它就从标签判断哪个是选项，哪个是参数，
而不是通过字符串的内容来瞎猜。

综上所述，文本流的危害在于：
本来简单明了的信息，被编码成为文本流之后，
就变得难以提取，甚至丢失。

====
文本流，一个历史性的错误

但是不幸的是，文本流的思想已经影响了无数的设计。
比如：

Unix/Linux下的各种配置文件，每一个都用不同的文本格式保存数据，
这样用户需要了解太多的格式，然而它们并没有什么本质区别。
各大公司为了这些文件带来的麻烦花费了大量的人力物力。

程序与关系式数据库之间的交互使用含有SQL语句的字符串，
由于字符串里的内容跟程序的类型之间并无关联，
导致了这种程序非常难以调试。

XML设计的初衷就是解决数据编码的问题，
然而不幸的是，它自己都难以编码解码。
它跟SQL类似，与程序里的类型关联性很差。
程序里的类型名字即使跟XML里面的定义有所偏差，编译器也不会报错。
Android程序经常出现"force close"，大部分时候是这个原因。

在Web应用中，Javascript经常被作为字符串插入到网页中。
由于字符串可以被任意组合，这引起很多安全性问题。
所谓的“Web安全”研究，很多就是解决这类问题的。

很多编译器给编辑器和IDE提供的接口是基于文本流的。
编译器打印出出错的行号和信息，
然后由编辑器和IDE从文本里面去提取这些信息，跳转到相应的行号。
一旦编译器改变打印格式，这些编辑器和IDE就得修改。

很多公司的产品模块在debug的时候打印出文本log信息，
然后专门请人写程序分析这种log，从里面提取有用的信息，非常费时费力。

很多人写unit test的时候，
喜欢把数据结构通过toString等函数转化成字符串之后，
与一个标准的字符串进行比较，
导致这些test在字符串格式改变之后失效而必须修改。

还有很多，很多，很多的例子，你只需要在你的身边去发现。

====
什么是“人类可读”和“通用”接口？

当我提到文本流做接口的各种弊端时，
经常有人会指出，虽然文本流不可靠又麻烦，但是它比其它接口更通用，
因为它是唯一人类可读(human-readable)的格式，
任何编辑器都可以直接看到文本流的内容，而其它格式都不是这样的。
对于这一点我想说的是，

首先，什么叫做“人类可读”？
文本流真的就是那么的可读吗？
几年前，普通的文本编辑器遇到中文的时候经常乱码，
要折腾好一阵子才能让它们支持中文。
幸好经过全世界的合作，我们现在有了Unicode。
现在要阅读Unicode的文件，你不但要有支持Unicode的编辑器/浏览器，
你还得有能显示相应码段的字体。
文本流达到“人类可读”真的不费力气？

其次，除了文本流，其实还有很多人类可读的格式，比如JPEG。
它可比文本流“可读”和“通用”多了，连字体都用不着。

所以，文本流的根本就不是“人类可读”和“通用”的关键。
真正的关键在于“标准化”。（hxzon：重要）
如果其它的数据类型被标准化，那么我们可以在任何编辑器，浏览器，终端里加入对它们的支持，
完全达到人类和机器都可轻松读取，就像我们今天读取文本和JPEG一样。

====
解决方案

其实有一个非常简单的方式可以一劳永逸的解决所有这些问题：

保留数据类型本来的结构。
不用文本流来表示除文本以外的数据。

用一个开放的，标准化的，可扩展的方式来表示所有数据类型。

程序之间的数据传递和存储，就像程序内部的数据结构一样。

