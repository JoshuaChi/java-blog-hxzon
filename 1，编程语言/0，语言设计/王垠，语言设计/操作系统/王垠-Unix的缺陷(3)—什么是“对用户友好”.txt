王垠-Unix的缺陷(3)—什么是“对用户友好”
2012/05/18 07:25
http://blog.sina.com.cn/s/blog_5d90e82f01014m7t.html
作者：王垠 | 来自：寂静之声


当我提到一个工具“对用户不友好”(user-unfriendly)的时候，我总是被人“鄙视”。难道这就叫做以其人之道还治其人之身？想当年有人对我抱怨 Linux 或者 TeX 对用户不友好的时候，我貌似也差不多的态度吧。现在当我指出 TeX 的各种缺点，提出新的解决方案的时候，往往会有美国同学眼角一抬，说：“菜鸟们抱怨工具不好用，那是因为他们不会用。LaTeX 是‘所想即所得’，所以不像 Word 之类的上手。”

殊不知他面前这个“菜鸟”，其实 TeX 功底比他高好几倍。他早已把 TeX 的配置搞得滚瓜烂熟，把 TeXbook 翻来覆去看了两遍，"double bend" 的习题都全部完成，可以用 TeX 的语言来写宏包，而且知道 TeX 语言设计上的缺陷。而他被叫做“菜鸟”，这是一个非常有趣的问题。所以现在抛开个人感情不谈，我们来探讨一下这种“鄙视”现象产生的原因，以及什么叫做“对用户友好”。

首先我们从心理的角度来分析一下为什么有人对这种“对用户不友好”的事实视而不见，而称抱怨的用户为“菜鸟”。这个似乎很明显，答案是“优越感”。如果每个人都会做一件事情，如何能体现出我的超群智力？所以我就是要专门选择那种最难用，最晦涩，最显得高深的东西，把它折腾会。这样我就可以被称为“高手”，就可以傲视群雄。我不得不承认，我以前也有类似的思想。从上本科以来我就一直在想，同样都会写程序，是什么让计算机系的学生与非计算机系的学生有所不同？经过多年之后的今天，我终于得到了答案（以后再告诉你们）。可是在多年以前，我犯了跟很多人一样的错误：把“难度”与“智力”或者“专业程度”相等同。但是其实，一个人会用难用的工具，并不等于他智力超群或者更加专业。

可惜的是，我发现世界上有非常少的人明白这个道理。在美国的大学里，公司里，彰显自己对难用的工具的掌握程度的人比比皆是。这不只是对于计算机系统，这也针对数学以及逻辑等抽象的学科。经常听人很自豪的说：“我准备用XX逻辑设计一个公理化的系统……”可是这些人其实只知道这个逻辑的皮毛，他们会用这个逻辑，却不知道它里面所有含混晦涩的规则都可以用更简单的方法推导出来。

爱因斯坦说：“Any intelligent fool can make things bigger and more complex... It takes a touch of genius - and a lot of courageto move in the opposite direction.”我现在深深的体会到这句话的道理。想要简化一个东西，让它更“好用”，你确实需要很大的勇气。而且你必须故意的忽略这个东西的一些细节。但是由于你的身边都是不理解这个道理的人，他们会把你当成菜鸟或者白痴。即使你成功了，也很难说服他们去尝试这个简化后的东西。

Dennis Ritchie也说：“Unix is simple. It just takes a genius to understand its simplicity.”可是我并不觉得他懂得这句话的道理。Unix其实不简单，它相当的复杂。我希望你看过这系列文章之后，能理解我为什么这样说。

那么现在我们来谈一下什么是“对用户友好”。如何定义“对用户友好”？如何精确的判断一个东西是否对用户友好？我觉得这是一个现在仍然非常模糊的概念，但是程序语言的设计思想可以比较好的解释它。我们可以把机器和人看作一个多层的系统:

机器在下层，人在上层，机器为人提供服务。
人机交互的界面就是信息从机器到人，以及从人到机器的接口。
机器里面又分多层结构，每层之间有一个界面。
每层界面必须提供一定的抽象，用于防止上一层模块得到它不该知道的细节。
抽象使得系统具有可扩展性。因为只要界面不变，下层系统改动之后，上层系统完全不用修改。

在机器的各个层次，这些抽象表现为函数或者方法的类型，程序的模块定义，操作系统的系统调用，等等。但是它们的本质都是一样的：他们告诉上一层系统“你能用我来干什么”。很多程序员都会注意到这些界面的抽象，使得上层系统尽量少的接触到下层细节。可是他们却往往忽视了人和机器之间的界面。也许他们没有忽视它，但是他们却用非常不一样的设计思想来考虑这个问题。他们没有设计良好的界面给人，而是把纷繁复杂的系统内部结构无情的暴露给人（包括他们自己），所以人对“我能用这个程序干什么”这个问题总是很糊涂。当程序被修改之后，经常需要让人的操作发生改变，所以这个系统对于人的可扩展性就差。通常程序员都考虑到机器各界面之间的扩展性，却没有考虑到机器与人之间界面的可扩展性。

举个例子。很多Unix程序都有配置文件，它们也设置环境变量，它们还有命令行参数。这样每个用户都得知道配置文件的名字，位置和格式，环境变量的名字以及意义，命令行参数的意义。一个程序还好，如果有好几个程序，这些配置会把人给搞糊涂。经常出现程序说找不到配置文件，看手册吧，手册说配置文件的位置是某某环境变量FOO决定的。改了环境变量却发现没有解决问题。没办法，只好上论坛问，终于发现配置文件起作用当且仅当在同一个目录里没有一个叫 ".bar" 的文件。好不容易记住了这条规则，这个程序升级到了2.0之后，又把规则给改了，所以这个用户又继续琢磨，继续上论坛，如此反复。也许这就叫做“折腾”？

TeX 系统的配置就更为麻烦。成千上万个小文件，很少有人理解kpathsea的结构和用法，折腾好久才会明白。但是其实它只是解决一个非常微不足道的问题。

一个良好的界面不应该是这样的。它给予用户的界面，应该只有一些简单的设定。用户应该用同样的方法来设置所有程序的所有参数，因为它们只不过是一个从变量到值的映射表（就像一个哈希表，或者数据库）。至于系统要在什么地方存储这些设定，如何找到它们，具体的格式，用户根本不应该知道。这跟高级语言的运行时系统(runtime system)的内存管理是一个道理。程序请求建立一个对象，系统收到指令后分配一块内存，进行初始化，然后把对象的引用(reference)返回给程序。程序并不知道对象存在于内存的哪个位置，而且不应该知道。程序不应该用对象的地址来进行运算。

所以我们看到，“用户不友好”的背后，其实是程序设计的失误使得他们缺少抽象，而不是用户的问题。

