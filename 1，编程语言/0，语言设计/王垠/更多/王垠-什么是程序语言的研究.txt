王垠-什么是程序语言的研究
2012/05/19 04:20
作者：王垠 | 来自：寂静之声

========
介绍一下我现在做的事情吧。我的领域叫“程序语言”(programming languages)，这是一个国内大学里几乎不存在的领域。虽然国内有人研究编译器，但是编译器的研究其实很少改变语言本身。它们一般是实现已经设计好的语言，而且很多专注于底层的语言（比如C，C++）。国外的大学里也只是少数人在做程序语言本身的研究，所以很少有人理解这个专业是干什么的，就连我身边的朋友同学也几乎不知道。但是其实这是一个非常重要的领域。在我看来，它就是计算机科学的全部（为什么这么说，我以后再慢慢讲）。

朋友见面一个常见的问题是：“那你肯定很会写程序了？”我确实很会写程序，但是写程序和设计程序语言，是很不一样的事情。会设计程序语言的人一般都很会写程序，但是会写程序的人却不一定会设计程序语言。也有人问我：“你研究什么语言？C++吗？”或者问一些很刁钻的Java问题，期望我能解决。事实是，我如果仔细看一会儿，肯定知道怎么回事，但是我不一定能解决问题。为什么呢？因为那个问题也许在我设计的语言里根本就不存在。也就是说，我更愿意消灭问题的根源，从而可以不解决它们。以后我会讲一下，编程的某些棘手问题，其实是不存在的。

程序语言的研究不是针对某一种语言，而是针对所有语言。它是一种基础性，普适性的研究。它专注于设计更为简单，合理和高效的语言，而不只是改进已有的语言。C，C++，Java，Python，JavaScript，Perl，PHP 这样的语言，一般都不是很重要的研究对象，虽然我们清楚的知道它们是怎么回事。像 Scheme, Haskell，Coq 或者 Agda 这样的语言研究的人比较多，因为它们简单，安全而且表达力很强。但是就我个人而言，我不倾向于任何一种特定的语言。我有自己的解释器，类型系统，编译器，我经常更改语言的设计。所以用哪种语言，其实对我来说没有很大的关系。

从广义一点的角度来说，程序语言研究的东西其实是计算的本质。如果你了解一点历史，就会理解我为什么这样说。其实，早期的程序语言研究直接导致了计算机科学的诞生。它的历史可以追述到20世纪30年代，甚至更早（看你怎么定义“程序语言”这个概念）。最早的时候产生这个想法是因为人们想给数学提供一个可靠的“基础”(foundation of mathematics)。之前对数学的描述都使用一些稀奇古怪的数学记号，夹杂一些自然语言。这是非常脆弱，不可靠，而且难于理解的。不小心看错一个句子，你可能就会接受一个错误的证明，或者无法验证一个正确的证明。而且数学记号的设计也缺乏一致性。所以有人就提出了这样的想法，想让数学的描述和证明完全的机械化，这样人就可以用机器，而不是用自己的脑子去验证证明的正确性。这就像现在大家都用计算器来做算术一样，基本不需要动脑筋。所以这个领域最早就是致力于帮助数学家偷懒的。

我每天都使用的一个概念叫 lambda calculus，它是几乎所有程序语言的精髓。几乎所有程序语言的所有构造，都可以用它来表示。这个东西是在1930年代由逻辑学家 Alonzo Church 发明的。Church 有很多学生，包括通常被认为是计算机科学鼻祖的图灵(Alan Turing)。当时还有其他一些重要的人物。在我看来，他们有些人的贡献比起图灵的还要重要，比如 Church 的另外的一个学生 Stephen Kleene。

有人也许会觉得基础性的研究没有应用前景。确实有些基础性的研究纯粹是扯淡，是不能应用的，但是其它一些却有很大的应用前景。举一个例子就是我在 Google 实习的时候给他们做的一个东西。他们需要为 Python 做一个可以像 Eclipse 一样能够精确跳转到定义的工具。因为 Python 是动态类型的，所以这个工作的难度比起 Java 这样的静态类型语言来说要大很多。通常来说这种东西需要一个团队好几年的工作，比如 Google 的 JS Compiler（开源之后叫做 closure compiler)，花费了四年时间才完成。但是因为理解程序语言的本质，我在一个周末的时间内设计出了这个系统的雏形。而在这之前，我对 Python 语言的了解几乎为零。所以我也可以依葫芦画瓢，为任何一个其它的动态类型语言（比如 JavaScript, Ruby等等）做同样的东西。

很多研究程序语言的人也进行一些程序验证的研究。简而言之，就是用机械化的逻辑来证明程序的正确性。这种证明与通常的单元测试(unit test)很不一样，在于它能100%的保证程序的正确，而测试的方法几乎总是会漏掉一些情况。这种研究在关键性的领域很有应用，比如航空航天，核电，武器，芯片设计等等。因为没有任何国家愿意因为程序出错而发射一颗核弹，所以他们愿意花很大的价钱保证控制程序的万无一失。Intel的浮点运算bug当年导致好几亿美元的经济损失，所以在那以后很多芯片厂商都开始使用定理证明程序（比如ACL2）来彻底的消灭芯片模块里可能存在的bug。

其它重要的应用真是举不胜举。我现在比较感兴趣的事情是类型系统(type system)，supercompilation，和自动定理证明。我也利用程序语言的知识来解释其它领域的东西，或者做其它好玩的东西。具体的我以后再慢慢介绍。

