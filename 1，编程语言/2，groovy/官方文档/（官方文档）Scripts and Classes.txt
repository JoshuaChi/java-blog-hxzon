（官方文档）Scripts and Classes
http://groovy.codehaus.org/Scripts+and+Classes

注释by hxzon
======
Classes are defined in Groovy similarly to Java. 
Methods can be class (static) or instance based and can be public, protected, private 
and support all the usual Java modifiers like synchronized.  

Package and class imports use the Java syntax (including static imports).  

Groovy automatically imports the following:
自动导入以下包：

java.lang
java.io
java.math
java.net
java.util
groovy.lang
groovy.util

One difference between Java and Groovy is that by default things are public unless you specify otherwise.
默认访问权限是public。

Groovy also merges the idea of fields and properties together to make code simpler, 
please refer to the Groovy Beans section for details of how they work.

Each class in Groovy is a Java class at the bytecode / JVM level. 
Any methods declared will be available to Java and vice versa. 
You can specify the types of parameters or return types on methods so that they work nicely in normal Java code. 
Also you can implement interfaces or overload Java methods using this approach.

If you omit the types of any methods or properties they will default to java.lang.Object at the bytecode/JVM level.

You can also use another class implemented in Groovy. e.g.


//Callee.groovy
class Callee {
  void hello() {
     println "hello, world"
  }
}

//Caller.groovy
c = new Callee()
c.hello()

groovy -cp . caller

Make sure the classpath is OK.

====
Scripts
脚本

Groovy supports plain scripts, which do not have a class declaration. 
Imports are supported at the front of a script in the same way that they can be a the front of a class. 
Here's the hello world script:


println "Nice cheese Gromit!"

You can run scripts in the interactive terminal, from the command-line, 
in your IDE, as a Unix script, or embeded in your own Java code.

If you compile the above script to bytecode using groovyc, you get a single class named after the name of the script. 
e.g. if this was saved in Foo.script you'd get a Foo.class file.

You can run this Java code on the command line (assuming you're classpath has groovy.jar and asm.jar).

java Foo

This will execute the autogenerated main(String[] args) method in the bytecode which instantiates the Foo class, which extends the 

Error formatting macro: link: java.lang.IllegalArgumentException: Link needs a name and a URL as arguments.
class and then call its run() method. 
You may also use this class directly in Java code, passing in variables to the script.
与java的交互：

import groovy.lang.Binding;
import groovy.lang.Script;

public class UseFoo {
	public static void main(String[] args) {
		// lets pass in some variables
		Binding binding = new Binding();
		binding.setVariable("cheese", "Cheddar")
		binding.setVariable("args", args)

		Script foo = new Foo(binding);
		foo.run();
	}
}

There's no need to use a Binding if you don't want to; Foo will have a no-argument constructor as well.  
Though using a Binding you can easily pass in variables. 
After the end of the script any variables created will be in the Binding for you to access in Java.

Unlike classes, variables are not required to be declared (def is not required) in scripts. 
Variables referenced in a script are automatically created and put into the Binding.

====
Scripts and functions

If you just want to write some simple scripts and need some simple functions you can declare functions without writing a class. 

One difference from normal class-based groovy is that the def keyword is required to define a function outside of a class.
在类之外定义函数，需要使用 def 关键字。

Here's an example of a simple script with a function.  
Note that if ever you need things like static or instance variables and so forth then maybe its time to actually write a class (smile)


def foo(list, value) {
    println "Calling function foo() with param ${value}"
    list << value
}

x = []
foo(x, 1)
foo(x, 2)
assert x == [1, 2]

println "Creating list ${x}"

