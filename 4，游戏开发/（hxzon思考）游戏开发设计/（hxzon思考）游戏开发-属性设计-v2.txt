（hxzon思考）游戏开发-属性设计-v2

by hxzon
========
1，游戏对象的数据

-1，值类型
-2，其他游戏对象的引用

========
2，数据来源

来自定义文件：不必保存
固定的公式值：不必保存

不固定的公式值（含随机因子）：需要保存

====
2.1，公式

==
-1，求和，只依赖本属性的各个段

calc-set-value-grs go :final a & 
    :base 3 
    :equip 2

==
-2，求和，只依赖某一段的属性

calc-set-value-ars go :final a :base & 
    atk 3 
    def 2

==
-3，求和，只依赖属性（任意段，任意属性）

calc-set-value-gars go :final a & 
    :base atk 3 
    :base def 2
    :final zdl 1

==
-4，复杂公式

额外的被加数
非属性值
属性值乘以属性值（或开方）


========
3，数据生命周期

始终不变的值
不断变化的值

========
4，值的分段，值的分组

分段，为了公式计算。

同一属性的不同的段，可看成是“有依赖性的不同的属性”。

分组，将不同属性的同一段放在一起，为了显示。

==
可消耗，但会恢复的属性，有两个值：当前值，最大值

========
5，级联更新

多个系统间的属性级联更新

装备/技能=》玩家=》技能

========
6，api设计

考虑的问题：批量重算，避免浪费，
例如 atk ，def 都影响 zdl ，
同时更新前两个属性时，重复计算 zdl 。

==
attrbar-get-value [go g a vd]
获取属性值
外部api

==
动态变量，用于跟踪所有的值变化
（不仅仅是“最终段”，在通知时再做筛选）

*attrs-orig*
*attrs-now*

动态变量，用于记录那些值需重置
*attrs-need-reset*

==
attrbar-set-values [go & gavs]
更新属性值（多个段，多个属性）
外部api
最高层调用，初始化三个动态变量，
然后调用 attrbar-set-values-impl

==
attrbar-set-values-impl [go & gavs]
内部api
非最高层调用，不初始化动态变量
调用 attrbar-just-set-values-impl
再根据 *attrs-need-reset* 
调用 attrbar-reset-value-impl （业务实现）

==
attrbar-just-set-values-impl [go & gavs]
内部api
转发给 attrbar-just-set-value-impl

==
attrbar-just-set-value-impl [go g a v]
设置值，并记录更改前后的值（不仅仅是“最终段”）
收集受影响的属性，稍后重置
内部api

==
attrbar-reset-value-impl [go a ]
业务逻辑的实现
根据 “游戏对象类型”，
更新属性各个段的值（重算所有基于公式的段）
（通过 attrbar-just-set-value-impl ）

示例，见下。

========
7，api设计2

此版本，会导致不必要的重复运算，
例如 zdl 依赖 atk 和 def ，
当同时更新 atk 和 def 时，
zdl 会计算两次，且第1次计算，基于旧的 def 值 。

==
attrbar-get-value [go g a vd]
获取属性值
外部api

==
动态变量，用于跟踪所有的值变化
（不仅仅是“最终段”，在通知时再做筛选）

*attrs-orig*
*attrs-now*

==
attrbar-set-values [go & gavs]
更新属性值（多个段，多个属性）
外部api
最高层调用，初始化两个动态变量

==
attrbar-set-values-impl [go & gavs]
内部api
非最高层调用，不初始化动态变量
转发给 attrbar-set-value-impl （业务实现）

==
attrbar-just-set-value-impl [go g a v]
设置值，并记录更改前后的值（不仅仅是“最终段”）
内部api

==
attrbar-set-value-impl [go g a v]
业务逻辑的实现
先调用 attrbar-just-set-value-impl
根据 游戏对象类型，分组，属性，更改其他值
（通过 attrbar-set-values-impl 或 attrbar-just-set-value-impl ）

示例：

(defn attrbar-set-value-impl
  [go g a v]
  (attrbar-just-set-value-impl go g a v)
  ;; 受影响的属性
  (cond
    (g-attr-go? :base Attr-lvl Go-User )
    (do
      (attrbar-set-values-impl 
        :base Attr-atk xxx
        :base Attr-def xxx)    ;;  zdl 会计算两次（且第1次计算，基于旧的 def ）
      )
    
    (g-attr? :base Attr-atk)
    (do
      (attrbar-just-set-value-impl go :final a xxx)
      (attrbar-just-set-value-impl go :final Attr-zdl xxx)
      )
    
    (g-attr? :base Attr-def)
    (do
      (attrbar-just-set-value-impl go :final a xxx)
      (attrbar-just-set-value-impl go :final Attr-zdl xxx)
      )
    )
  )

第6节示例：

(defn attrbar-reset-value-impl
  [go a ]
  (cond
    (attr-go? Attr-lvl Go-User )
    (do
      (attrbar-calc-set-value-grs
        go :final a
        :base 1)
      )
    
    (= Attr-atk a)
    (do
      (attrbar-calc-atk-base go)    ;; 计算攻击力的基础段：复杂公式
      (attrbar-calc-set-value-grs    ;; 计算攻击力的最终段：求和其它段
        go :final a 
        :base 3
        :equip 2
        :skill 2)
      )
    
    (= Attr-def a)
    (do
      (attrbar-calc-def-base go)
      (attrbar-calc-set-value-grs
        go :final a 
        :base 3
        :equip 2
        :skill 2)
      )
    
    (= Attr-zdl a)
    (do
      (attrbar-calc-set-value-ars    ;; 计算战斗力的最终段：求和其它属性
        go :final a
        :base
        Attr-atk 1
        Attr-def 2
        )
      )
    )
  )

