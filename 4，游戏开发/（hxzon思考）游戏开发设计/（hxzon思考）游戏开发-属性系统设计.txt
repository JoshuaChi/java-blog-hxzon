（hxzon思考）游戏开发-属性系统设计

========
1，需求：

更新一组属性，如何自动更新受影响的其它属性？

结论：只能通过“重算”。
“反操作（减法）”行不通。

====
1.1，
初始输入：go，#{ [a g] }
输入格式所蕴含的两个维度：游戏对象，系统（g）

====
2，

[atk base] [atk forge] [atk final]

方案：不使用g，算法不同时，视为不同的属性，
例如 Attr-atk-base , Attr-atk-forge , Attr-atk-final 。
缺陷：变成单维度，爆炸。
结论：使用g 。

====
3，级联更新

3.1，
方案：上层属性监听属性的变更事件，
将自己添加到“级联集合”中。

事件处理函数
(if [a g go] (add [b g] ))
（即用函数来表达“级联关系”）
最终可以转化成一张静态表：
[a g go-key] -> #{[a g] [a g]}

结论：使用全局变量表达“级联关系”。
结论：如何更新级联属性，最终只有这一种方案。

====
3.2，使用状态机？

使用事件订阅？
更新属性[a :base b :base ] 后发出事件，
在事件处理器中更新[a :final b :final]，发出事件，
在事件处理器中更新[z :final]，发出事件，
在事件处理器中，更新其他系统的属性值。

可以在一轮事件中更新所有受影响的属性，
那和3.1本质上是一样的。

分为多轮处理，需要更新[a :final]时，不立即更新[z :final]，
复杂化，不可行。

========
4，g 用来标识系统类别。
go-key 用来标识对象特征。
为什么没有更多的维度？
这是初始输入本身就携带的两个维度。

方案：对象特征和系统类别合并，
例如 user-base , item-base , item-forge 
缺陷：少了一个维度，爆炸。
对比：当 [:base item] [:base user] 算法相同时，可简化为 [:base nil] 。

====
4.1，

方案：级联关系不放入对象特征。
缺点：不加入游戏对象，会得到无关的级联属性段。
但在 attrbar-reset-value-impl 中，
根据游戏对象特征（例如游戏对象类型），
进行不同的计算（包括不计算）即可。

========
5，级联更新

有些属性能唯一确定另外的属性的值，
例如 user-lvl 唯一确定 atk base ,def base 。

atk base,def base 共用一个额外参数，
且这个参数计算较费资源。

方案：在更新 user-lvl 时，
立即重算 atk base,def base，
并将它们视为原始的外部输入。
缺点：复杂化。

方案：将共用的这个额外参数视为一个属性。
结论：可行。

========
6，初始化

初始化时，属性值分多个阶段设置。

问题：
设置某个值，但不想立刻重算级联的属性。
设置值，重算级联的属性，但不想重算其它系统（其它对象）的值。
不想发出事件。

====
7，

